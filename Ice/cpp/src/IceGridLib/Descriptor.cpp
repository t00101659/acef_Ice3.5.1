// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `Descriptor.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef ICE_GRID_API_EXPORTS
#   define ICE_GRID_API_EXPORTS
#endif
#include <IceGrid/Descriptor.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/BasicStream.h>
#include <Ice/Object.h>
#include <Ice/SliceChecksums.h>
#include <IceUtil/Iterator.h>
#include <IceUtil/DisableWarnings.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace
{

}

namespace Ice
{
#ifdef ICE_HAS_DECLSPEC_IMPORT_EXPORT
template struct ICE_GRID_API StreamWriter< ::IceGrid::PropertyDescriptor, ::IceInternal::BasicStream>;
template struct ICE_GRID_API StreamReader< ::IceGrid::PropertyDescriptor, ::IceInternal::BasicStream>;
#endif
#ifdef ICE_HAS_DECLSPEC_IMPORT_EXPORT
template struct ICE_GRID_API StreamWriter< ::IceGrid::PropertySetDescriptor, ::IceInternal::BasicStream>;
template struct ICE_GRID_API StreamReader< ::IceGrid::PropertySetDescriptor, ::IceInternal::BasicStream>;
#endif
#ifdef ICE_HAS_DECLSPEC_IMPORT_EXPORT
template struct ICE_GRID_API StreamWriter< ::IceGrid::ObjectDescriptor, ::IceInternal::BasicStream>;
template struct ICE_GRID_API StreamReader< ::IceGrid::ObjectDescriptor, ::IceInternal::BasicStream>;
#endif
#ifdef ICE_HAS_DECLSPEC_IMPORT_EXPORT
template struct ICE_GRID_API StreamWriter< ::IceGrid::AdapterDescriptor, ::IceInternal::BasicStream>;
template struct ICE_GRID_API StreamReader< ::IceGrid::AdapterDescriptor, ::IceInternal::BasicStream>;
#endif
#ifdef ICE_HAS_DECLSPEC_IMPORT_EXPORT
template struct ICE_GRID_API StreamWriter< ::IceGrid::DbEnvDescriptor, ::IceInternal::BasicStream>;
template struct ICE_GRID_API StreamReader< ::IceGrid::DbEnvDescriptor, ::IceInternal::BasicStream>;
#endif
#ifdef ICE_HAS_DECLSPEC_IMPORT_EXPORT
template struct ICE_GRID_API StreamWriter< ::IceGrid::DistributionDescriptor, ::IceInternal::BasicStream>;
template struct ICE_GRID_API StreamReader< ::IceGrid::DistributionDescriptor, ::IceInternal::BasicStream>;
#endif
#ifdef ICE_HAS_DECLSPEC_IMPORT_EXPORT
template struct ICE_GRID_API StreamWriter< ::IceGrid::ServerInstanceDescriptor, ::IceInternal::BasicStream>;
template struct ICE_GRID_API StreamReader< ::IceGrid::ServerInstanceDescriptor, ::IceInternal::BasicStream>;
#endif
#ifdef ICE_HAS_DECLSPEC_IMPORT_EXPORT
template struct ICE_GRID_API StreamWriter< ::IceGrid::TemplateDescriptor, ::IceInternal::BasicStream>;
template struct ICE_GRID_API StreamReader< ::IceGrid::TemplateDescriptor, ::IceInternal::BasicStream>;
#endif
#ifdef ICE_HAS_DECLSPEC_IMPORT_EXPORT
template struct ICE_GRID_API StreamWriter< ::IceGrid::ServiceInstanceDescriptor, ::IceInternal::BasicStream>;
template struct ICE_GRID_API StreamReader< ::IceGrid::ServiceInstanceDescriptor, ::IceInternal::BasicStream>;
#endif
#ifdef ICE_HAS_DECLSPEC_IMPORT_EXPORT
template struct ICE_GRID_API StreamWriter< ::IceGrid::NodeDescriptor, ::IceInternal::BasicStream>;
template struct ICE_GRID_API StreamReader< ::IceGrid::NodeDescriptor, ::IceInternal::BasicStream>;
#endif
#ifdef ICE_HAS_DECLSPEC_IMPORT_EXPORT
template struct ICE_GRID_API StreamWriter< ::IceGrid::ReplicaGroupDescriptor, ::IceInternal::BasicStream>;
template struct ICE_GRID_API StreamReader< ::IceGrid::ReplicaGroupDescriptor, ::IceInternal::BasicStream>;
#endif
#ifdef ICE_HAS_DECLSPEC_IMPORT_EXPORT
template struct ICE_GRID_API StreamWriter< ::IceGrid::ApplicationDescriptor, ::IceInternal::BasicStream>;
template struct ICE_GRID_API StreamReader< ::IceGrid::ApplicationDescriptor, ::IceInternal::BasicStream>;
#endif
#ifdef ICE_HAS_DECLSPEC_IMPORT_EXPORT
template struct ICE_GRID_API StreamWriter< ::IceGrid::NodeUpdateDescriptor, ::IceInternal::BasicStream>;
template struct ICE_GRID_API StreamReader< ::IceGrid::NodeUpdateDescriptor, ::IceInternal::BasicStream>;
#endif
#ifdef ICE_HAS_DECLSPEC_IMPORT_EXPORT
template struct ICE_GRID_API StreamWriter< ::IceGrid::ApplicationUpdateDescriptor, ::IceInternal::BasicStream>;
template struct ICE_GRID_API StreamReader< ::IceGrid::ApplicationUpdateDescriptor, ::IceInternal::BasicStream>;
#endif
}
#ifdef __SUNPRO_CC
class ICE_DECLSPEC_EXPORT IceProxy::IceGrid::CommunicatorDescriptor;
#endif
ICE_DECLSPEC_EXPORT ::IceProxy::Ice::Object* ::IceProxy::IceGrid::upCast(::IceProxy::IceGrid::CommunicatorDescriptor* p) { return p; }

void
::IceProxy::IceGrid::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::CommunicatorDescriptor>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceGrid::CommunicatorDescriptor;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::IceGrid::CommunicatorDescriptor::ice_staticId()
{
    return ::IceGrid::CommunicatorDescriptor::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceGrid::CommunicatorDescriptor::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceGrid::CommunicatorDescriptor);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceGrid::CommunicatorDescriptor::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceGrid::CommunicatorDescriptor);
}

::IceProxy::Ice::Object*
IceProxy::IceGrid::CommunicatorDescriptor::__newInstance() const
{
    return new CommunicatorDescriptor;
}
#ifdef __SUNPRO_CC
class ICE_DECLSPEC_EXPORT IceProxy::IceGrid::ServerDescriptor;
#endif
ICE_DECLSPEC_EXPORT ::IceProxy::Ice::Object* ::IceProxy::IceGrid::upCast(::IceProxy::IceGrid::ServerDescriptor* p) { return p; }

void
::IceProxy::IceGrid::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::ServerDescriptor>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceGrid::ServerDescriptor;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::IceGrid::ServerDescriptor::ice_staticId()
{
    return ::IceGrid::ServerDescriptor::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceGrid::ServerDescriptor::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceGrid::ServerDescriptor);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceGrid::ServerDescriptor::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceGrid::ServerDescriptor);
}

::IceProxy::Ice::Object*
IceProxy::IceGrid::ServerDescriptor::__newInstance() const
{
    return new ServerDescriptor;
}
#ifdef __SUNPRO_CC
class ICE_DECLSPEC_EXPORT IceProxy::IceGrid::ServiceDescriptor;
#endif
ICE_DECLSPEC_EXPORT ::IceProxy::Ice::Object* ::IceProxy::IceGrid::upCast(::IceProxy::IceGrid::ServiceDescriptor* p) { return p; }

void
::IceProxy::IceGrid::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::ServiceDescriptor>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceGrid::ServiceDescriptor;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::IceGrid::ServiceDescriptor::ice_staticId()
{
    return ::IceGrid::ServiceDescriptor::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceGrid::ServiceDescriptor::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceGrid::ServiceDescriptor);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceGrid::ServiceDescriptor::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceGrid::ServiceDescriptor);
}

::IceProxy::Ice::Object*
IceProxy::IceGrid::ServiceDescriptor::__newInstance() const
{
    return new ServiceDescriptor;
}
#ifdef __SUNPRO_CC
class ICE_DECLSPEC_EXPORT IceProxy::IceGrid::IceBoxDescriptor;
#endif
ICE_DECLSPEC_EXPORT ::IceProxy::Ice::Object* ::IceProxy::IceGrid::upCast(::IceProxy::IceGrid::IceBoxDescriptor* p) { return p; }

void
::IceProxy::IceGrid::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::IceBoxDescriptor>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceGrid::IceBoxDescriptor;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::IceGrid::IceBoxDescriptor::ice_staticId()
{
    return ::IceGrid::IceBoxDescriptor::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceGrid::IceBoxDescriptor::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceGrid::IceBoxDescriptor);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceGrid::IceBoxDescriptor::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceGrid::IceBoxDescriptor);
}

::IceProxy::Ice::Object*
IceProxy::IceGrid::IceBoxDescriptor::__newInstance() const
{
    return new IceBoxDescriptor;
}
#ifdef __SUNPRO_CC
class ICE_DECLSPEC_EXPORT IceProxy::IceGrid::LoadBalancingPolicy;
#endif
ICE_DECLSPEC_EXPORT ::IceProxy::Ice::Object* ::IceProxy::IceGrid::upCast(::IceProxy::IceGrid::LoadBalancingPolicy* p) { return p; }

void
::IceProxy::IceGrid::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::LoadBalancingPolicy>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceGrid::LoadBalancingPolicy;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::IceGrid::LoadBalancingPolicy::ice_staticId()
{
    return ::IceGrid::LoadBalancingPolicy::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceGrid::LoadBalancingPolicy::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceGrid::LoadBalancingPolicy);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceGrid::LoadBalancingPolicy::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceGrid::LoadBalancingPolicy);
}

::IceProxy::Ice::Object*
IceProxy::IceGrid::LoadBalancingPolicy::__newInstance() const
{
    return new LoadBalancingPolicy;
}
#ifdef __SUNPRO_CC
class ICE_DECLSPEC_EXPORT IceProxy::IceGrid::RandomLoadBalancingPolicy;
#endif
ICE_DECLSPEC_EXPORT ::IceProxy::Ice::Object* ::IceProxy::IceGrid::upCast(::IceProxy::IceGrid::RandomLoadBalancingPolicy* p) { return p; }

void
::IceProxy::IceGrid::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::RandomLoadBalancingPolicy>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceGrid::RandomLoadBalancingPolicy;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::IceGrid::RandomLoadBalancingPolicy::ice_staticId()
{
    return ::IceGrid::RandomLoadBalancingPolicy::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceGrid::RandomLoadBalancingPolicy::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceGrid::RandomLoadBalancingPolicy);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceGrid::RandomLoadBalancingPolicy::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceGrid::RandomLoadBalancingPolicy);
}

::IceProxy::Ice::Object*
IceProxy::IceGrid::RandomLoadBalancingPolicy::__newInstance() const
{
    return new RandomLoadBalancingPolicy;
}
#ifdef __SUNPRO_CC
class ICE_DECLSPEC_EXPORT IceProxy::IceGrid::OrderedLoadBalancingPolicy;
#endif
ICE_DECLSPEC_EXPORT ::IceProxy::Ice::Object* ::IceProxy::IceGrid::upCast(::IceProxy::IceGrid::OrderedLoadBalancingPolicy* p) { return p; }

void
::IceProxy::IceGrid::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::OrderedLoadBalancingPolicy>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceGrid::OrderedLoadBalancingPolicy;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::IceGrid::OrderedLoadBalancingPolicy::ice_staticId()
{
    return ::IceGrid::OrderedLoadBalancingPolicy::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceGrid::OrderedLoadBalancingPolicy::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceGrid::OrderedLoadBalancingPolicy);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceGrid::OrderedLoadBalancingPolicy::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceGrid::OrderedLoadBalancingPolicy);
}

::IceProxy::Ice::Object*
IceProxy::IceGrid::OrderedLoadBalancingPolicy::__newInstance() const
{
    return new OrderedLoadBalancingPolicy;
}
#ifdef __SUNPRO_CC
class ICE_DECLSPEC_EXPORT IceProxy::IceGrid::RoundRobinLoadBalancingPolicy;
#endif
ICE_DECLSPEC_EXPORT ::IceProxy::Ice::Object* ::IceProxy::IceGrid::upCast(::IceProxy::IceGrid::RoundRobinLoadBalancingPolicy* p) { return p; }

void
::IceProxy::IceGrid::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::RoundRobinLoadBalancingPolicy>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceGrid::RoundRobinLoadBalancingPolicy;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::IceGrid::RoundRobinLoadBalancingPolicy::ice_staticId()
{
    return ::IceGrid::RoundRobinLoadBalancingPolicy::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceGrid::RoundRobinLoadBalancingPolicy::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceGrid::RoundRobinLoadBalancingPolicy);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceGrid::RoundRobinLoadBalancingPolicy::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceGrid::RoundRobinLoadBalancingPolicy);
}

::IceProxy::Ice::Object*
IceProxy::IceGrid::RoundRobinLoadBalancingPolicy::__newInstance() const
{
    return new RoundRobinLoadBalancingPolicy;
}
#ifdef __SUNPRO_CC
class ICE_DECLSPEC_EXPORT IceProxy::IceGrid::AdaptiveLoadBalancingPolicy;
#endif
ICE_DECLSPEC_EXPORT ::IceProxy::Ice::Object* ::IceProxy::IceGrid::upCast(::IceProxy::IceGrid::AdaptiveLoadBalancingPolicy* p) { return p; }

void
::IceProxy::IceGrid::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::AdaptiveLoadBalancingPolicy>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceGrid::AdaptiveLoadBalancingPolicy;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::IceGrid::AdaptiveLoadBalancingPolicy::ice_staticId()
{
    return ::IceGrid::AdaptiveLoadBalancingPolicy::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceGrid::AdaptiveLoadBalancingPolicy::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceGrid::AdaptiveLoadBalancingPolicy);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceGrid::AdaptiveLoadBalancingPolicy::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceGrid::AdaptiveLoadBalancingPolicy);
}

::IceProxy::Ice::Object*
IceProxy::IceGrid::AdaptiveLoadBalancingPolicy::__newInstance() const
{
    return new AdaptiveLoadBalancingPolicy;
}
#ifdef __SUNPRO_CC
class ICE_DECLSPEC_EXPORT IceProxy::IceGrid::BoxedString;
#endif
ICE_DECLSPEC_EXPORT ::IceProxy::Ice::Object* ::IceProxy::IceGrid::upCast(::IceProxy::IceGrid::BoxedString* p) { return p; }

void
::IceProxy::IceGrid::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::BoxedString>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceGrid::BoxedString;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::IceGrid::BoxedString::ice_staticId()
{
    return ::IceGrid::BoxedString::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceGrid::BoxedString::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceGrid::BoxedString);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceGrid::BoxedString::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceGrid::BoxedString);
}

::IceProxy::Ice::Object*
IceProxy::IceGrid::BoxedString::__newInstance() const
{
    return new BoxedString;
}
#ifdef __SUNPRO_CC
class ICE_DECLSPEC_EXPORT IceProxy::IceGrid::BoxedDistributionDescriptor;
#endif
ICE_DECLSPEC_EXPORT ::IceProxy::Ice::Object* ::IceProxy::IceGrid::upCast(::IceProxy::IceGrid::BoxedDistributionDescriptor* p) { return p; }

void
::IceProxy::IceGrid::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::BoxedDistributionDescriptor>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceGrid::BoxedDistributionDescriptor;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::IceGrid::BoxedDistributionDescriptor::ice_staticId()
{
    return ::IceGrid::BoxedDistributionDescriptor::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceGrid::BoxedDistributionDescriptor::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceGrid::BoxedDistributionDescriptor);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceGrid::BoxedDistributionDescriptor::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceGrid::BoxedDistributionDescriptor);
}

::IceProxy::Ice::Object*
IceProxy::IceGrid::BoxedDistributionDescriptor::__newInstance() const
{
    return new BoxedDistributionDescriptor;
}

ICE_DECLSPEC_EXPORT ::Ice::Object* IceGrid::upCast(::IceGrid::CommunicatorDescriptor* p) { return p; }
::Ice::ObjectPtr
IceGrid::CommunicatorDescriptor::ice_clone() const
{
    ::Ice::Object* __p = new CommunicatorDescriptor(*this);
    return __p;
}

namespace
{
const ::std::string __IceGrid__CommunicatorDescriptor_ids[2] =
{
    "::Ice::Object",
    "::IceGrid::CommunicatorDescriptor"
};

}

bool
IceGrid::CommunicatorDescriptor::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceGrid__CommunicatorDescriptor_ids, __IceGrid__CommunicatorDescriptor_ids + 2, _s);
}

::std::vector< ::std::string>
IceGrid::CommunicatorDescriptor::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceGrid__CommunicatorDescriptor_ids[0], &__IceGrid__CommunicatorDescriptor_ids[2]);
}

const ::std::string&
IceGrid::CommunicatorDescriptor::ice_id(const ::Ice::Current&) const
{
    return __IceGrid__CommunicatorDescriptor_ids[1];
}

const ::std::string&
IceGrid::CommunicatorDescriptor::ice_staticId()
{
    return __IceGrid__CommunicatorDescriptor_ids[1];
}

void
IceGrid::CommunicatorDescriptor::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(adapters);
    __os->write(propertySet);
    __os->write(dbEnvs);
    __os->write(logs);
    __os->write(description);
    __os->endWriteSlice();
}

void
IceGrid::CommunicatorDescriptor::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(adapters);
    __is->read(propertySet);
    __is->read(dbEnvs);
    __is->read(logs);
    __is->read(description);
    __is->endReadSlice();
}

namespace
{

class __F__IceGrid__CommunicatorDescriptor : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::IceGrid::CommunicatorDescriptor::ice_staticId());
        return new ::IceGrid::CommunicatorDescriptor;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__IceGrid__CommunicatorDescriptor_Ptr = new __F__IceGrid__CommunicatorDescriptor;

class __F__IceGrid__CommunicatorDescriptor__Init
{
public:

    __F__IceGrid__CommunicatorDescriptor__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::IceGrid::CommunicatorDescriptor::ice_staticId(), __F__IceGrid__CommunicatorDescriptor_Ptr);
    }

    ~__F__IceGrid__CommunicatorDescriptor__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::IceGrid::CommunicatorDescriptor::ice_staticId());
    }
};

const __F__IceGrid__CommunicatorDescriptor__Init __F__IceGrid__CommunicatorDescriptor__i;

}

const ::Ice::ObjectFactoryPtr&
IceGrid::CommunicatorDescriptor::ice_factory()
{
    return __F__IceGrid__CommunicatorDescriptor_Ptr;
}

void ICE_DECLSPEC_EXPORT 
IceGrid::__patch(CommunicatorDescriptorPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceGrid::CommunicatorDescriptorPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceGrid::CommunicatorDescriptor::ice_staticId(), v);
    }
}

ICE_DECLSPEC_EXPORT ::Ice::Object* IceGrid::upCast(::IceGrid::ServerDescriptor* p) { return p; }
::Ice::ObjectPtr
IceGrid::ServerDescriptor::ice_clone() const
{
    ::Ice::Object* __p = new ServerDescriptor(*this);
    return __p;
}

namespace
{
const ::std::string __IceGrid__ServerDescriptor_ids[3] =
{
    "::Ice::Object",
    "::IceGrid::CommunicatorDescriptor",
    "::IceGrid::ServerDescriptor"
};

}

bool
IceGrid::ServerDescriptor::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceGrid__ServerDescriptor_ids, __IceGrid__ServerDescriptor_ids + 3, _s);
}

::std::vector< ::std::string>
IceGrid::ServerDescriptor::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceGrid__ServerDescriptor_ids[0], &__IceGrid__ServerDescriptor_ids[3]);
}

const ::std::string&
IceGrid::ServerDescriptor::ice_id(const ::Ice::Current&) const
{
    return __IceGrid__ServerDescriptor_ids[2];
}

const ::std::string&
IceGrid::ServerDescriptor::ice_staticId()
{
    return __IceGrid__ServerDescriptor_ids[2];
}

void
IceGrid::ServerDescriptor::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, false);
    __os->write(id);
    __os->write(exe);
    __os->write(iceVersion);
    __os->write(pwd);
    __os->write(options);
    __os->write(envs);
    __os->write(activation);
    __os->write(activationTimeout);
    __os->write(deactivationTimeout);
    __os->write(applicationDistrib);
    __os->write(distrib);
    __os->write(allocatable);
    __os->write(user);
    __os->endWriteSlice();
    ::IceGrid::CommunicatorDescriptor::__writeImpl(__os);
}

void
IceGrid::ServerDescriptor::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(id);
    __is->read(exe);
    __is->read(iceVersion);
    __is->read(pwd);
    __is->read(options);
    __is->read(envs);
    __is->read(activation);
    __is->read(activationTimeout);
    __is->read(deactivationTimeout);
    __is->read(applicationDistrib);
    __is->read(distrib);
    __is->read(allocatable);
    __is->read(user);
    __is->endReadSlice();
    ::IceGrid::CommunicatorDescriptor::__readImpl(__is);
}

namespace
{

class __F__IceGrid__ServerDescriptor : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::IceGrid::ServerDescriptor::ice_staticId());
        return new ::IceGrid::ServerDescriptor;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__IceGrid__ServerDescriptor_Ptr = new __F__IceGrid__ServerDescriptor;

class __F__IceGrid__ServerDescriptor__Init
{
public:

    __F__IceGrid__ServerDescriptor__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::IceGrid::ServerDescriptor::ice_staticId(), __F__IceGrid__ServerDescriptor_Ptr);
    }

    ~__F__IceGrid__ServerDescriptor__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::IceGrid::ServerDescriptor::ice_staticId());
    }
};

const __F__IceGrid__ServerDescriptor__Init __F__IceGrid__ServerDescriptor__i;

}

const ::Ice::ObjectFactoryPtr&
IceGrid::ServerDescriptor::ice_factory()
{
    return __F__IceGrid__ServerDescriptor_Ptr;
}

void ICE_DECLSPEC_EXPORT 
IceGrid::__patch(ServerDescriptorPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceGrid::ServerDescriptorPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceGrid::ServerDescriptor::ice_staticId(), v);
    }
}

ICE_DECLSPEC_EXPORT ::Ice::Object* IceGrid::upCast(::IceGrid::ServiceDescriptor* p) { return p; }
::Ice::ObjectPtr
IceGrid::ServiceDescriptor::ice_clone() const
{
    ::Ice::Object* __p = new ServiceDescriptor(*this);
    return __p;
}

namespace
{
const ::std::string __IceGrid__ServiceDescriptor_ids[3] =
{
    "::Ice::Object",
    "::IceGrid::CommunicatorDescriptor",
    "::IceGrid::ServiceDescriptor"
};

}

bool
IceGrid::ServiceDescriptor::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceGrid__ServiceDescriptor_ids, __IceGrid__ServiceDescriptor_ids + 3, _s);
}

::std::vector< ::std::string>
IceGrid::ServiceDescriptor::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceGrid__ServiceDescriptor_ids[0], &__IceGrid__ServiceDescriptor_ids[3]);
}

const ::std::string&
IceGrid::ServiceDescriptor::ice_id(const ::Ice::Current&) const
{
    return __IceGrid__ServiceDescriptor_ids[2];
}

const ::std::string&
IceGrid::ServiceDescriptor::ice_staticId()
{
    return __IceGrid__ServiceDescriptor_ids[2];
}

void
IceGrid::ServiceDescriptor::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, false);
    __os->write(name);
    __os->write(entry);
    __os->endWriteSlice();
    ::IceGrid::CommunicatorDescriptor::__writeImpl(__os);
}

void
IceGrid::ServiceDescriptor::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(name);
    __is->read(entry);
    __is->endReadSlice();
    ::IceGrid::CommunicatorDescriptor::__readImpl(__is);
}

namespace
{

class __F__IceGrid__ServiceDescriptor : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::IceGrid::ServiceDescriptor::ice_staticId());
        return new ::IceGrid::ServiceDescriptor;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__IceGrid__ServiceDescriptor_Ptr = new __F__IceGrid__ServiceDescriptor;

class __F__IceGrid__ServiceDescriptor__Init
{
public:

    __F__IceGrid__ServiceDescriptor__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::IceGrid::ServiceDescriptor::ice_staticId(), __F__IceGrid__ServiceDescriptor_Ptr);
    }

    ~__F__IceGrid__ServiceDescriptor__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::IceGrid::ServiceDescriptor::ice_staticId());
    }
};

const __F__IceGrid__ServiceDescriptor__Init __F__IceGrid__ServiceDescriptor__i;

}

const ::Ice::ObjectFactoryPtr&
IceGrid::ServiceDescriptor::ice_factory()
{
    return __F__IceGrid__ServiceDescriptor_Ptr;
}

void ICE_DECLSPEC_EXPORT 
IceGrid::__patch(ServiceDescriptorPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceGrid::ServiceDescriptorPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceGrid::ServiceDescriptor::ice_staticId(), v);
    }
}

ICE_DECLSPEC_EXPORT ::Ice::Object* IceGrid::upCast(::IceGrid::IceBoxDescriptor* p) { return p; }
::Ice::ObjectPtr
IceGrid::IceBoxDescriptor::ice_clone() const
{
    ::Ice::Object* __p = new IceBoxDescriptor(*this);
    return __p;
}

namespace
{
const ::std::string __IceGrid__IceBoxDescriptor_ids[4] =
{
    "::Ice::Object",
    "::IceGrid::CommunicatorDescriptor",
    "::IceGrid::IceBoxDescriptor",
    "::IceGrid::ServerDescriptor"
};

}

bool
IceGrid::IceBoxDescriptor::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceGrid__IceBoxDescriptor_ids, __IceGrid__IceBoxDescriptor_ids + 4, _s);
}

::std::vector< ::std::string>
IceGrid::IceBoxDescriptor::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceGrid__IceBoxDescriptor_ids[0], &__IceGrid__IceBoxDescriptor_ids[4]);
}

const ::std::string&
IceGrid::IceBoxDescriptor::ice_id(const ::Ice::Current&) const
{
    return __IceGrid__IceBoxDescriptor_ids[2];
}

const ::std::string&
IceGrid::IceBoxDescriptor::ice_staticId()
{
    return __IceGrid__IceBoxDescriptor_ids[2];
}

void
IceGrid::IceBoxDescriptor::__addObject(::IceInternal::GCCountMap& _c)
{
    ::IceInternal::GCCountMap::iterator pos = _c.find(this);
    if(pos == _c.end())
    {
        _c[this] = 1;
    }
    else
    {
        ++pos->second;
    }
}

bool
IceGrid::IceBoxDescriptor::__usesGC()
{
    return true;
}

void
IceGrid::IceBoxDescriptor::__gcReachable(::IceInternal::GCCountMap& _c) const
{
    {
        for(::IceGrid::ServiceInstanceDescriptorSeq::const_iterator _i0 = services.begin(); _i0 != services.end(); ++_i0)
        {
            if((*_i0).descriptor)
            {
                ::IceGrid::upCast((*_i0).descriptor.get())->__addObject(_c);
            }
        }
    }
}

void
IceGrid::IceBoxDescriptor::__gcClear()
{
    {
        for(::IceGrid::ServiceInstanceDescriptorSeq::iterator _i0 = services.begin(); _i0 != services.end(); ++_i0)
        {
            if((*_i0).descriptor)
            {
                if(::IceGrid::upCast((*_i0).descriptor.get())->__usesGC())
                {
                    ::IceGrid::upCast((*_i0).descriptor.get())->__decRefUnsafe();
                    (*_i0).descriptor.__clearHandleUnsafe();
                }
                else
                {
                    (*_i0).descriptor = 0;
                }
            }
        }
    }
}

void
IceGrid::IceBoxDescriptor::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, false);
    __os->write(services);
    __os->endWriteSlice();
    ::IceGrid::ServerDescriptor::__writeImpl(__os);
}

void
IceGrid::IceBoxDescriptor::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(services);
    __is->endReadSlice();
    ::IceGrid::ServerDescriptor::__readImpl(__is);
}

namespace
{

class __F__IceGrid__IceBoxDescriptor : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::IceGrid::IceBoxDescriptor::ice_staticId());
        return new ::IceGrid::IceBoxDescriptor;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__IceGrid__IceBoxDescriptor_Ptr = new __F__IceGrid__IceBoxDescriptor;

class __F__IceGrid__IceBoxDescriptor__Init
{
public:

    __F__IceGrid__IceBoxDescriptor__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::IceGrid::IceBoxDescriptor::ice_staticId(), __F__IceGrid__IceBoxDescriptor_Ptr);
    }

    ~__F__IceGrid__IceBoxDescriptor__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::IceGrid::IceBoxDescriptor::ice_staticId());
    }
};

const __F__IceGrid__IceBoxDescriptor__Init __F__IceGrid__IceBoxDescriptor__i;

}

const ::Ice::ObjectFactoryPtr&
IceGrid::IceBoxDescriptor::ice_factory()
{
    return __F__IceGrid__IceBoxDescriptor_Ptr;
}

void ICE_DECLSPEC_EXPORT 
IceGrid::__patch(IceBoxDescriptorPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceGrid::IceBoxDescriptorPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceGrid::IceBoxDescriptor::ice_staticId(), v);
    }
}

ICE_DECLSPEC_EXPORT ::Ice::Object* IceGrid::upCast(::IceGrid::LoadBalancingPolicy* p) { return p; }
::Ice::ObjectPtr
IceGrid::LoadBalancingPolicy::ice_clone() const
{
    ::Ice::Object* __p = new LoadBalancingPolicy(*this);
    return __p;
}

namespace
{
const ::std::string __IceGrid__LoadBalancingPolicy_ids[2] =
{
    "::Ice::Object",
    "::IceGrid::LoadBalancingPolicy"
};

}

bool
IceGrid::LoadBalancingPolicy::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceGrid__LoadBalancingPolicy_ids, __IceGrid__LoadBalancingPolicy_ids + 2, _s);
}

::std::vector< ::std::string>
IceGrid::LoadBalancingPolicy::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceGrid__LoadBalancingPolicy_ids[0], &__IceGrid__LoadBalancingPolicy_ids[2]);
}

const ::std::string&
IceGrid::LoadBalancingPolicy::ice_id(const ::Ice::Current&) const
{
    return __IceGrid__LoadBalancingPolicy_ids[1];
}

const ::std::string&
IceGrid::LoadBalancingPolicy::ice_staticId()
{
    return __IceGrid__LoadBalancingPolicy_ids[1];
}

void
IceGrid::LoadBalancingPolicy::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(nReplicas);
    __os->endWriteSlice();
}

void
IceGrid::LoadBalancingPolicy::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(nReplicas);
    __is->endReadSlice();
}

namespace
{

class __F__IceGrid__LoadBalancingPolicy : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::IceGrid::LoadBalancingPolicy::ice_staticId());
        return new ::IceGrid::LoadBalancingPolicy;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__IceGrid__LoadBalancingPolicy_Ptr = new __F__IceGrid__LoadBalancingPolicy;

class __F__IceGrid__LoadBalancingPolicy__Init
{
public:

    __F__IceGrid__LoadBalancingPolicy__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::IceGrid::LoadBalancingPolicy::ice_staticId(), __F__IceGrid__LoadBalancingPolicy_Ptr);
    }

    ~__F__IceGrid__LoadBalancingPolicy__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::IceGrid::LoadBalancingPolicy::ice_staticId());
    }
};

const __F__IceGrid__LoadBalancingPolicy__Init __F__IceGrid__LoadBalancingPolicy__i;

}

const ::Ice::ObjectFactoryPtr&
IceGrid::LoadBalancingPolicy::ice_factory()
{
    return __F__IceGrid__LoadBalancingPolicy_Ptr;
}

void ICE_DECLSPEC_EXPORT 
IceGrid::__patch(LoadBalancingPolicyPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceGrid::LoadBalancingPolicyPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceGrid::LoadBalancingPolicy::ice_staticId(), v);
    }
}

ICE_DECLSPEC_EXPORT ::Ice::Object* IceGrid::upCast(::IceGrid::RandomLoadBalancingPolicy* p) { return p; }
::Ice::ObjectPtr
IceGrid::RandomLoadBalancingPolicy::ice_clone() const
{
    ::Ice::Object* __p = new RandomLoadBalancingPolicy(*this);
    return __p;
}

namespace
{
const ::std::string __IceGrid__RandomLoadBalancingPolicy_ids[3] =
{
    "::Ice::Object",
    "::IceGrid::LoadBalancingPolicy",
    "::IceGrid::RandomLoadBalancingPolicy"
};

}

bool
IceGrid::RandomLoadBalancingPolicy::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceGrid__RandomLoadBalancingPolicy_ids, __IceGrid__RandomLoadBalancingPolicy_ids + 3, _s);
}

::std::vector< ::std::string>
IceGrid::RandomLoadBalancingPolicy::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceGrid__RandomLoadBalancingPolicy_ids[0], &__IceGrid__RandomLoadBalancingPolicy_ids[3]);
}

const ::std::string&
IceGrid::RandomLoadBalancingPolicy::ice_id(const ::Ice::Current&) const
{
    return __IceGrid__RandomLoadBalancingPolicy_ids[2];
}

const ::std::string&
IceGrid::RandomLoadBalancingPolicy::ice_staticId()
{
    return __IceGrid__RandomLoadBalancingPolicy_ids[2];
}

void
IceGrid::RandomLoadBalancingPolicy::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, false);
    __os->endWriteSlice();
    ::IceGrid::LoadBalancingPolicy::__writeImpl(__os);
}

void
IceGrid::RandomLoadBalancingPolicy::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
    ::IceGrid::LoadBalancingPolicy::__readImpl(__is);
}

namespace
{

class __F__IceGrid__RandomLoadBalancingPolicy : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::IceGrid::RandomLoadBalancingPolicy::ice_staticId());
        return new ::IceGrid::RandomLoadBalancingPolicy;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__IceGrid__RandomLoadBalancingPolicy_Ptr = new __F__IceGrid__RandomLoadBalancingPolicy;

class __F__IceGrid__RandomLoadBalancingPolicy__Init
{
public:

    __F__IceGrid__RandomLoadBalancingPolicy__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::IceGrid::RandomLoadBalancingPolicy::ice_staticId(), __F__IceGrid__RandomLoadBalancingPolicy_Ptr);
    }

    ~__F__IceGrid__RandomLoadBalancingPolicy__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::IceGrid::RandomLoadBalancingPolicy::ice_staticId());
    }
};

const __F__IceGrid__RandomLoadBalancingPolicy__Init __F__IceGrid__RandomLoadBalancingPolicy__i;

}

const ::Ice::ObjectFactoryPtr&
IceGrid::RandomLoadBalancingPolicy::ice_factory()
{
    return __F__IceGrid__RandomLoadBalancingPolicy_Ptr;
}

void ICE_DECLSPEC_EXPORT 
IceGrid::__patch(RandomLoadBalancingPolicyPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceGrid::RandomLoadBalancingPolicyPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceGrid::RandomLoadBalancingPolicy::ice_staticId(), v);
    }
}

ICE_DECLSPEC_EXPORT ::Ice::Object* IceGrid::upCast(::IceGrid::OrderedLoadBalancingPolicy* p) { return p; }
::Ice::ObjectPtr
IceGrid::OrderedLoadBalancingPolicy::ice_clone() const
{
    ::Ice::Object* __p = new OrderedLoadBalancingPolicy(*this);
    return __p;
}

namespace
{
const ::std::string __IceGrid__OrderedLoadBalancingPolicy_ids[3] =
{
    "::Ice::Object",
    "::IceGrid::LoadBalancingPolicy",
    "::IceGrid::OrderedLoadBalancingPolicy"
};

}

bool
IceGrid::OrderedLoadBalancingPolicy::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceGrid__OrderedLoadBalancingPolicy_ids, __IceGrid__OrderedLoadBalancingPolicy_ids + 3, _s);
}

::std::vector< ::std::string>
IceGrid::OrderedLoadBalancingPolicy::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceGrid__OrderedLoadBalancingPolicy_ids[0], &__IceGrid__OrderedLoadBalancingPolicy_ids[3]);
}

const ::std::string&
IceGrid::OrderedLoadBalancingPolicy::ice_id(const ::Ice::Current&) const
{
    return __IceGrid__OrderedLoadBalancingPolicy_ids[2];
}

const ::std::string&
IceGrid::OrderedLoadBalancingPolicy::ice_staticId()
{
    return __IceGrid__OrderedLoadBalancingPolicy_ids[2];
}

void
IceGrid::OrderedLoadBalancingPolicy::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, false);
    __os->endWriteSlice();
    ::IceGrid::LoadBalancingPolicy::__writeImpl(__os);
}

void
IceGrid::OrderedLoadBalancingPolicy::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
    ::IceGrid::LoadBalancingPolicy::__readImpl(__is);
}

namespace
{

class __F__IceGrid__OrderedLoadBalancingPolicy : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::IceGrid::OrderedLoadBalancingPolicy::ice_staticId());
        return new ::IceGrid::OrderedLoadBalancingPolicy;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__IceGrid__OrderedLoadBalancingPolicy_Ptr = new __F__IceGrid__OrderedLoadBalancingPolicy;

class __F__IceGrid__OrderedLoadBalancingPolicy__Init
{
public:

    __F__IceGrid__OrderedLoadBalancingPolicy__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::IceGrid::OrderedLoadBalancingPolicy::ice_staticId(), __F__IceGrid__OrderedLoadBalancingPolicy_Ptr);
    }

    ~__F__IceGrid__OrderedLoadBalancingPolicy__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::IceGrid::OrderedLoadBalancingPolicy::ice_staticId());
    }
};

const __F__IceGrid__OrderedLoadBalancingPolicy__Init __F__IceGrid__OrderedLoadBalancingPolicy__i;

}

const ::Ice::ObjectFactoryPtr&
IceGrid::OrderedLoadBalancingPolicy::ice_factory()
{
    return __F__IceGrid__OrderedLoadBalancingPolicy_Ptr;
}

void ICE_DECLSPEC_EXPORT 
IceGrid::__patch(OrderedLoadBalancingPolicyPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceGrid::OrderedLoadBalancingPolicyPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceGrid::OrderedLoadBalancingPolicy::ice_staticId(), v);
    }
}

ICE_DECLSPEC_EXPORT ::Ice::Object* IceGrid::upCast(::IceGrid::RoundRobinLoadBalancingPolicy* p) { return p; }
::Ice::ObjectPtr
IceGrid::RoundRobinLoadBalancingPolicy::ice_clone() const
{
    ::Ice::Object* __p = new RoundRobinLoadBalancingPolicy(*this);
    return __p;
}

namespace
{
const ::std::string __IceGrid__RoundRobinLoadBalancingPolicy_ids[3] =
{
    "::Ice::Object",
    "::IceGrid::LoadBalancingPolicy",
    "::IceGrid::RoundRobinLoadBalancingPolicy"
};

}

bool
IceGrid::RoundRobinLoadBalancingPolicy::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceGrid__RoundRobinLoadBalancingPolicy_ids, __IceGrid__RoundRobinLoadBalancingPolicy_ids + 3, _s);
}

::std::vector< ::std::string>
IceGrid::RoundRobinLoadBalancingPolicy::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceGrid__RoundRobinLoadBalancingPolicy_ids[0], &__IceGrid__RoundRobinLoadBalancingPolicy_ids[3]);
}

const ::std::string&
IceGrid::RoundRobinLoadBalancingPolicy::ice_id(const ::Ice::Current&) const
{
    return __IceGrid__RoundRobinLoadBalancingPolicy_ids[2];
}

const ::std::string&
IceGrid::RoundRobinLoadBalancingPolicy::ice_staticId()
{
    return __IceGrid__RoundRobinLoadBalancingPolicy_ids[2];
}

void
IceGrid::RoundRobinLoadBalancingPolicy::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, false);
    __os->endWriteSlice();
    ::IceGrid::LoadBalancingPolicy::__writeImpl(__os);
}

void
IceGrid::RoundRobinLoadBalancingPolicy::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
    ::IceGrid::LoadBalancingPolicy::__readImpl(__is);
}

namespace
{

class __F__IceGrid__RoundRobinLoadBalancingPolicy : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::IceGrid::RoundRobinLoadBalancingPolicy::ice_staticId());
        return new ::IceGrid::RoundRobinLoadBalancingPolicy;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__IceGrid__RoundRobinLoadBalancingPolicy_Ptr = new __F__IceGrid__RoundRobinLoadBalancingPolicy;

class __F__IceGrid__RoundRobinLoadBalancingPolicy__Init
{
public:

    __F__IceGrid__RoundRobinLoadBalancingPolicy__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::IceGrid::RoundRobinLoadBalancingPolicy::ice_staticId(), __F__IceGrid__RoundRobinLoadBalancingPolicy_Ptr);
    }

    ~__F__IceGrid__RoundRobinLoadBalancingPolicy__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::IceGrid::RoundRobinLoadBalancingPolicy::ice_staticId());
    }
};

const __F__IceGrid__RoundRobinLoadBalancingPolicy__Init __F__IceGrid__RoundRobinLoadBalancingPolicy__i;

}

const ::Ice::ObjectFactoryPtr&
IceGrid::RoundRobinLoadBalancingPolicy::ice_factory()
{
    return __F__IceGrid__RoundRobinLoadBalancingPolicy_Ptr;
}

void ICE_DECLSPEC_EXPORT 
IceGrid::__patch(RoundRobinLoadBalancingPolicyPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceGrid::RoundRobinLoadBalancingPolicyPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceGrid::RoundRobinLoadBalancingPolicy::ice_staticId(), v);
    }
}

ICE_DECLSPEC_EXPORT ::Ice::Object* IceGrid::upCast(::IceGrid::AdaptiveLoadBalancingPolicy* p) { return p; }
::Ice::ObjectPtr
IceGrid::AdaptiveLoadBalancingPolicy::ice_clone() const
{
    ::Ice::Object* __p = new AdaptiveLoadBalancingPolicy(*this);
    return __p;
}

namespace
{
const ::std::string __IceGrid__AdaptiveLoadBalancingPolicy_ids[3] =
{
    "::Ice::Object",
    "::IceGrid::AdaptiveLoadBalancingPolicy",
    "::IceGrid::LoadBalancingPolicy"
};

}

bool
IceGrid::AdaptiveLoadBalancingPolicy::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceGrid__AdaptiveLoadBalancingPolicy_ids, __IceGrid__AdaptiveLoadBalancingPolicy_ids + 3, _s);
}

::std::vector< ::std::string>
IceGrid::AdaptiveLoadBalancingPolicy::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceGrid__AdaptiveLoadBalancingPolicy_ids[0], &__IceGrid__AdaptiveLoadBalancingPolicy_ids[3]);
}

const ::std::string&
IceGrid::AdaptiveLoadBalancingPolicy::ice_id(const ::Ice::Current&) const
{
    return __IceGrid__AdaptiveLoadBalancingPolicy_ids[1];
}

const ::std::string&
IceGrid::AdaptiveLoadBalancingPolicy::ice_staticId()
{
    return __IceGrid__AdaptiveLoadBalancingPolicy_ids[1];
}

void
IceGrid::AdaptiveLoadBalancingPolicy::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, false);
    __os->write(loadSample);
    __os->endWriteSlice();
    ::IceGrid::LoadBalancingPolicy::__writeImpl(__os);
}

void
IceGrid::AdaptiveLoadBalancingPolicy::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(loadSample);
    __is->endReadSlice();
    ::IceGrid::LoadBalancingPolicy::__readImpl(__is);
}

namespace
{

class __F__IceGrid__AdaptiveLoadBalancingPolicy : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::IceGrid::AdaptiveLoadBalancingPolicy::ice_staticId());
        return new ::IceGrid::AdaptiveLoadBalancingPolicy;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__IceGrid__AdaptiveLoadBalancingPolicy_Ptr = new __F__IceGrid__AdaptiveLoadBalancingPolicy;

class __F__IceGrid__AdaptiveLoadBalancingPolicy__Init
{
public:

    __F__IceGrid__AdaptiveLoadBalancingPolicy__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::IceGrid::AdaptiveLoadBalancingPolicy::ice_staticId(), __F__IceGrid__AdaptiveLoadBalancingPolicy_Ptr);
    }

    ~__F__IceGrid__AdaptiveLoadBalancingPolicy__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::IceGrid::AdaptiveLoadBalancingPolicy::ice_staticId());
    }
};

const __F__IceGrid__AdaptiveLoadBalancingPolicy__Init __F__IceGrid__AdaptiveLoadBalancingPolicy__i;

}

const ::Ice::ObjectFactoryPtr&
IceGrid::AdaptiveLoadBalancingPolicy::ice_factory()
{
    return __F__IceGrid__AdaptiveLoadBalancingPolicy_Ptr;
}

void ICE_DECLSPEC_EXPORT 
IceGrid::__patch(AdaptiveLoadBalancingPolicyPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceGrid::AdaptiveLoadBalancingPolicyPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceGrid::AdaptiveLoadBalancingPolicy::ice_staticId(), v);
    }
}

ICE_DECLSPEC_EXPORT ::Ice::Object* IceGrid::upCast(::IceGrid::BoxedString* p) { return p; }
::Ice::ObjectPtr
IceGrid::BoxedString::ice_clone() const
{
    ::Ice::Object* __p = new BoxedString(*this);
    return __p;
}

namespace
{
const ::std::string __IceGrid__BoxedString_ids[2] =
{
    "::Ice::Object",
    "::IceGrid::BoxedString"
};

}

bool
IceGrid::BoxedString::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceGrid__BoxedString_ids, __IceGrid__BoxedString_ids + 2, _s);
}

::std::vector< ::std::string>
IceGrid::BoxedString::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceGrid__BoxedString_ids[0], &__IceGrid__BoxedString_ids[2]);
}

const ::std::string&
IceGrid::BoxedString::ice_id(const ::Ice::Current&) const
{
    return __IceGrid__BoxedString_ids[1];
}

const ::std::string&
IceGrid::BoxedString::ice_staticId()
{
    return __IceGrid__BoxedString_ids[1];
}

void
IceGrid::BoxedString::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(value);
    __os->endWriteSlice();
}

void
IceGrid::BoxedString::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(value);
    __is->endReadSlice();
}

namespace
{

class __F__IceGrid__BoxedString : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::IceGrid::BoxedString::ice_staticId());
        return new ::IceGrid::BoxedString;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__IceGrid__BoxedString_Ptr = new __F__IceGrid__BoxedString;

class __F__IceGrid__BoxedString__Init
{
public:

    __F__IceGrid__BoxedString__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::IceGrid::BoxedString::ice_staticId(), __F__IceGrid__BoxedString_Ptr);
    }

    ~__F__IceGrid__BoxedString__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::IceGrid::BoxedString::ice_staticId());
    }
};

const __F__IceGrid__BoxedString__Init __F__IceGrid__BoxedString__i;

}

const ::Ice::ObjectFactoryPtr&
IceGrid::BoxedString::ice_factory()
{
    return __F__IceGrid__BoxedString_Ptr;
}

void ICE_DECLSPEC_EXPORT 
IceGrid::__patch(BoxedStringPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceGrid::BoxedStringPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceGrid::BoxedString::ice_staticId(), v);
    }
}

ICE_DECLSPEC_EXPORT ::Ice::Object* IceGrid::upCast(::IceGrid::BoxedDistributionDescriptor* p) { return p; }
::Ice::ObjectPtr
IceGrid::BoxedDistributionDescriptor::ice_clone() const
{
    ::Ice::Object* __p = new BoxedDistributionDescriptor(*this);
    return __p;
}

namespace
{
const ::std::string __IceGrid__BoxedDistributionDescriptor_ids[2] =
{
    "::Ice::Object",
    "::IceGrid::BoxedDistributionDescriptor"
};

}

bool
IceGrid::BoxedDistributionDescriptor::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceGrid__BoxedDistributionDescriptor_ids, __IceGrid__BoxedDistributionDescriptor_ids + 2, _s);
}

::std::vector< ::std::string>
IceGrid::BoxedDistributionDescriptor::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceGrid__BoxedDistributionDescriptor_ids[0], &__IceGrid__BoxedDistributionDescriptor_ids[2]);
}

const ::std::string&
IceGrid::BoxedDistributionDescriptor::ice_id(const ::Ice::Current&) const
{
    return __IceGrid__BoxedDistributionDescriptor_ids[1];
}

const ::std::string&
IceGrid::BoxedDistributionDescriptor::ice_staticId()
{
    return __IceGrid__BoxedDistributionDescriptor_ids[1];
}

void
IceGrid::BoxedDistributionDescriptor::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(value);
    __os->endWriteSlice();
}

void
IceGrid::BoxedDistributionDescriptor::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(value);
    __is->endReadSlice();
}

namespace
{

class __F__IceGrid__BoxedDistributionDescriptor : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::IceGrid::BoxedDistributionDescriptor::ice_staticId());
        return new ::IceGrid::BoxedDistributionDescriptor;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__IceGrid__BoxedDistributionDescriptor_Ptr = new __F__IceGrid__BoxedDistributionDescriptor;

class __F__IceGrid__BoxedDistributionDescriptor__Init
{
public:

    __F__IceGrid__BoxedDistributionDescriptor__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::IceGrid::BoxedDistributionDescriptor::ice_staticId(), __F__IceGrid__BoxedDistributionDescriptor_Ptr);
    }

    ~__F__IceGrid__BoxedDistributionDescriptor__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::IceGrid::BoxedDistributionDescriptor::ice_staticId());
    }
};

const __F__IceGrid__BoxedDistributionDescriptor__Init __F__IceGrid__BoxedDistributionDescriptor__i;

}

const ::Ice::ObjectFactoryPtr&
IceGrid::BoxedDistributionDescriptor::ice_factory()
{
    return __F__IceGrid__BoxedDistributionDescriptor_Ptr;
}

void ICE_DECLSPEC_EXPORT 
IceGrid::__patch(BoxedDistributionDescriptorPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceGrid::BoxedDistributionDescriptorPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceGrid::BoxedDistributionDescriptor::ice_staticId(), v);
    }
}

namespace
{

const char* __sliceChecksums[] =
{
    "::IceGrid::AdapterDescriptor", "4ae12581eab9d8ecba56534d28960f0",
    "::IceGrid::AdapterDescriptorSeq", "61bb9118038552b5e80bf14cf41719c",
    "::IceGrid::AdaptiveLoadBalancingPolicy", "eae551a45bf88ecdfdcbd169e3502816",
    "::IceGrid::ApplicationDescriptor", "fc17fb9c4c7fc8f17ad10bc5da634a0",
    "::IceGrid::ApplicationDescriptorSeq", "b56d6d3091e8c0199e924bbdc074",
    "::IceGrid::ApplicationUpdateDescriptor", "9aef62072a0ecc3ee4be33bc46e0da",
    "::IceGrid::BoxedDistributionDescriptor", "bab8796f5dc33ebe6955d4bb3219c5e9",
    "::IceGrid::BoxedString", "f6bfc069c5150c34e14331c921218d7",
    "::IceGrid::CommunicatorDescriptor", "b7cdae49f8df0d1d93afb857875ec15",
    "::IceGrid::DbEnvDescriptor", "19c130dac4bf7fa2f82375a85e5f421",
    "::IceGrid::DbEnvDescriptorSeq", "d0e45f67b942541727ae69d6cda2fdd8",
    "::IceGrid::DistributionDescriptor", "109eee8e2dc57e518243806796d756",
    "::IceGrid::IceBoxDescriptor", "814eec3d42ab727f75f7b183e1b02c38",
    "::IceGrid::LoadBalancingPolicy", "dfbd5166bbdcac620f2d7f5de185afe",
    "::IceGrid::NodeDescriptor", "be38d2d0b946fea6266f7a97d493d4",
    "::IceGrid::NodeDescriptorDict", "600e78031867992f2fbd18719cb494",
    "::IceGrid::NodeUpdateDescriptor", "d1c0a29ce34753b44e54285c49c9780",
    "::IceGrid::NodeUpdateDescriptorSeq", "3416e1746e2acedfb8192d9d83d9dc3",
    "::IceGrid::ObjectDescriptor", "913039a22b7b5fc0fd156ce764a4237d",
    "::IceGrid::ObjectDescriptorSeq", "57236a6ef224f825849907a344412bb",
    "::IceGrid::OrderedLoadBalancingPolicy", "bef5dacddeeae0e0b58945adaea2121",
    "::IceGrid::PropertyDescriptor", "8b2145a8b1c5c8ffc9eac6a13e731798",
    "::IceGrid::PropertyDescriptorSeq", "5f4143ef7e2c87b63136a3177b7a2830",
    "::IceGrid::PropertySetDescriptor", "d07a6de61ed833b349d869bacb7d857",
    "::IceGrid::PropertySetDescriptorDict", "30fc60d722ab4ba7affa70387730322f",
    "::IceGrid::RandomLoadBalancingPolicy", "b52a26591c76fe2d6d134d954568c1a",
    "::IceGrid::ReplicaGroupDescriptor", "87acc1bd322ee928e2d23d5d179c9afc",
    "::IceGrid::ReplicaGroupDescriptorSeq", "5a3d3e7b4dc5f21b74f7adb5a6b24ccc",
    "::IceGrid::RoundRobinLoadBalancingPolicy", "d9c7e987c732d89b7aa79621a788fcb4",
    "::IceGrid::ServerDescriptor", "45903227dd1968cedd1811b9d71bc374",
    "::IceGrid::ServerDescriptorSeq", "1bf128cadf1974b22258f66617a1ed",
    "::IceGrid::ServerInstanceDescriptor", "56938d38e0189cdbd57d16e5a6bbc0fb",
    "::IceGrid::ServerInstanceDescriptorSeq", "2a8ae55ccef7917d96691c0a84778dd",
    "::IceGrid::ServiceDescriptor", "7c2496565248aa7d9732565ee5fe7c",
    "::IceGrid::ServiceDescriptorSeq", "cc519ed2b7f626b896cdc062823166",
    "::IceGrid::ServiceInstanceDescriptor", "8581f0afc39ae7daab937244b28c1394",
    "::IceGrid::ServiceInstanceDescriptorSeq", "eb22cd2a50e79f648d803c4b54755",
    "::IceGrid::StringStringDict", "87cdc9524ba3964efc9091e5b3346f29",
    "::IceGrid::TemplateDescriptor", "d1229192d114f32db747493becd5765",
    "::IceGrid::TemplateDescriptorDict", "7b9427f03e8ce3b67decd2cc35baa1",
    0
};
const IceInternal::SliceChecksumInit __sliceChecksumInit(__sliceChecksums);

}
