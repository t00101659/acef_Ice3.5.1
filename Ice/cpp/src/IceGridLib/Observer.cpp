// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `Observer.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef ICE_GRID_API_EXPORTS
#   define ICE_GRID_API_EXPORTS
#endif
#include <IceGrid/Observer.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/BasicStream.h>
#include <Ice/Object.h>
#include <Ice/SlicedData.h>
#include <Ice/SliceChecksums.h>
#include <IceUtil/Iterator.h>
#include <IceUtil/DisableWarnings.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace
{

const ::std::string __IceGrid__NodeObserver__nodeInit_name = "nodeInit";

const ::std::string __IceGrid__NodeObserver__nodeUp_name = "nodeUp";

const ::std::string __IceGrid__NodeObserver__nodeDown_name = "nodeDown";

const ::std::string __IceGrid__NodeObserver__updateServer_name = "updateServer";

const ::std::string __IceGrid__NodeObserver__updateAdapter_name = "updateAdapter";

const ::std::string __IceGrid__ApplicationObserver__applicationInit_name = "applicationInit";

const ::std::string __IceGrid__ApplicationObserver__applicationAdded_name = "applicationAdded";

const ::std::string __IceGrid__ApplicationObserver__applicationRemoved_name = "applicationRemoved";

const ::std::string __IceGrid__ApplicationObserver__applicationUpdated_name = "applicationUpdated";

const ::std::string __IceGrid__AdapterObserver__adapterInit_name = "adapterInit";

const ::std::string __IceGrid__AdapterObserver__adapterAdded_name = "adapterAdded";

const ::std::string __IceGrid__AdapterObserver__adapterUpdated_name = "adapterUpdated";

const ::std::string __IceGrid__AdapterObserver__adapterRemoved_name = "adapterRemoved";

const ::std::string __IceGrid__ObjectObserver__objectInit_name = "objectInit";

const ::std::string __IceGrid__ObjectObserver__objectAdded_name = "objectAdded";

const ::std::string __IceGrid__ObjectObserver__objectUpdated_name = "objectUpdated";

const ::std::string __IceGrid__ObjectObserver__objectRemoved_name = "objectRemoved";

const ::std::string __IceGrid__RegistryObserver__registryInit_name = "registryInit";

const ::std::string __IceGrid__RegistryObserver__registryUp_name = "registryUp";

const ::std::string __IceGrid__RegistryObserver__registryDown_name = "registryDown";

}

namespace Ice
{
#ifdef ICE_HAS_DECLSPEC_IMPORT_EXPORT
template struct ICE_GRID_API StreamWriter< ::IceGrid::ServerDynamicInfo, ::IceInternal::BasicStream>;
template struct ICE_GRID_API StreamReader< ::IceGrid::ServerDynamicInfo, ::IceInternal::BasicStream>;
#endif
#ifdef ICE_HAS_DECLSPEC_IMPORT_EXPORT
template struct ICE_GRID_API StreamWriter< ::IceGrid::AdapterDynamicInfo, ::IceInternal::BasicStream>;
template struct ICE_GRID_API StreamReader< ::IceGrid::AdapterDynamicInfo, ::IceInternal::BasicStream>;
#endif
#ifdef ICE_HAS_DECLSPEC_IMPORT_EXPORT
template struct ICE_GRID_API StreamWriter< ::IceGrid::NodeDynamicInfo, ::IceInternal::BasicStream>;
template struct ICE_GRID_API StreamReader< ::IceGrid::NodeDynamicInfo, ::IceInternal::BasicStream>;
#endif
}
#ifdef __SUNPRO_CC
class ICE_DECLSPEC_EXPORT IceProxy::IceGrid::NodeObserver;
#endif
ICE_DECLSPEC_EXPORT ::IceProxy::Ice::Object* ::IceProxy::IceGrid::upCast(::IceProxy::IceGrid::NodeObserver* p) { return p; }

void
::IceProxy::IceGrid::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::NodeObserver>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceGrid::NodeObserver;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::IceGrid::NodeObserver::nodeInit(const ::IceGrid::NodeDynamicInfoSeq& nodes, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__NodeObserver__nodeInit_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::NodeObserver* __del = dynamic_cast< ::IceDelegate::IceGrid::NodeObserver*>(__delBase.get());
            __del->nodeInit(nodes, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::NodeObserver::begin_nodeInit(const ::IceGrid::NodeDynamicInfoSeq& nodes, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__NodeObserver__nodeInit_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__NodeObserver__nodeInit_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(nodes);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::NodeObserver::end_nodeInit(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__NodeObserver__nodeInit_name);
}

void
IceProxy::IceGrid::NodeObserver::nodeUp(const ::IceGrid::NodeDynamicInfo& node, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__NodeObserver__nodeUp_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::NodeObserver* __del = dynamic_cast< ::IceDelegate::IceGrid::NodeObserver*>(__delBase.get());
            __del->nodeUp(node, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::NodeObserver::begin_nodeUp(const ::IceGrid::NodeDynamicInfo& node, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__NodeObserver__nodeUp_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__NodeObserver__nodeUp_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(node);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::NodeObserver::end_nodeUp(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__NodeObserver__nodeUp_name);
}

void
IceProxy::IceGrid::NodeObserver::nodeDown(const ::std::string& name, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__NodeObserver__nodeDown_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::NodeObserver* __del = dynamic_cast< ::IceDelegate::IceGrid::NodeObserver*>(__delBase.get());
            __del->nodeDown(name, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::NodeObserver::begin_nodeDown(const ::std::string& name, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__NodeObserver__nodeDown_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__NodeObserver__nodeDown_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(name);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::NodeObserver::end_nodeDown(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__NodeObserver__nodeDown_name);
}

void
IceProxy::IceGrid::NodeObserver::updateServer(const ::std::string& node, const ::IceGrid::ServerDynamicInfo& updatedInfo, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__NodeObserver__updateServer_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::NodeObserver* __del = dynamic_cast< ::IceDelegate::IceGrid::NodeObserver*>(__delBase.get());
            __del->updateServer(node, updatedInfo, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::NodeObserver::begin_updateServer(const ::std::string& node, const ::IceGrid::ServerDynamicInfo& updatedInfo, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__NodeObserver__updateServer_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__NodeObserver__updateServer_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(node);
        __os->write(updatedInfo);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::NodeObserver::end_updateServer(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__NodeObserver__updateServer_name);
}

void
IceProxy::IceGrid::NodeObserver::updateAdapter(const ::std::string& node, const ::IceGrid::AdapterDynamicInfo& updatedInfo, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__NodeObserver__updateAdapter_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::NodeObserver* __del = dynamic_cast< ::IceDelegate::IceGrid::NodeObserver*>(__delBase.get());
            __del->updateAdapter(node, updatedInfo, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::NodeObserver::begin_updateAdapter(const ::std::string& node, const ::IceGrid::AdapterDynamicInfo& updatedInfo, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__NodeObserver__updateAdapter_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__NodeObserver__updateAdapter_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(node);
        __os->write(updatedInfo);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::NodeObserver::end_updateAdapter(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__NodeObserver__updateAdapter_name);
}

const ::std::string&
IceProxy::IceGrid::NodeObserver::ice_staticId()
{
    return ::IceGrid::NodeObserver::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceGrid::NodeObserver::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceGrid::NodeObserver);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceGrid::NodeObserver::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceGrid::NodeObserver);
}

::IceProxy::Ice::Object*
IceProxy::IceGrid::NodeObserver::__newInstance() const
{
    return new NodeObserver;
}
#ifdef __SUNPRO_CC
class ICE_DECLSPEC_EXPORT IceProxy::IceGrid::ApplicationObserver;
#endif
ICE_DECLSPEC_EXPORT ::IceProxy::Ice::Object* ::IceProxy::IceGrid::upCast(::IceProxy::IceGrid::ApplicationObserver* p) { return p; }

void
::IceProxy::IceGrid::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::ApplicationObserver>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceGrid::ApplicationObserver;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::IceGrid::ApplicationObserver::applicationInit(::Ice::Int serial, const ::IceGrid::ApplicationInfoSeq& applications, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__ApplicationObserver__applicationInit_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::ApplicationObserver* __del = dynamic_cast< ::IceDelegate::IceGrid::ApplicationObserver*>(__delBase.get());
            __del->applicationInit(serial, applications, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::ApplicationObserver::begin_applicationInit(::Ice::Int serial, const ::IceGrid::ApplicationInfoSeq& applications, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__ApplicationObserver__applicationInit_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__ApplicationObserver__applicationInit_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(serial);
        __os->write(applications);
        __os->writePendingObjects();
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::ApplicationObserver::end_applicationInit(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__ApplicationObserver__applicationInit_name);
}

void
IceProxy::IceGrid::ApplicationObserver::applicationAdded(::Ice::Int serial, const ::IceGrid::ApplicationInfo& desc, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__ApplicationObserver__applicationAdded_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::ApplicationObserver* __del = dynamic_cast< ::IceDelegate::IceGrid::ApplicationObserver*>(__delBase.get());
            __del->applicationAdded(serial, desc, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::ApplicationObserver::begin_applicationAdded(::Ice::Int serial, const ::IceGrid::ApplicationInfo& desc, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__ApplicationObserver__applicationAdded_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__ApplicationObserver__applicationAdded_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(serial);
        __os->write(desc);
        __os->writePendingObjects();
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::ApplicationObserver::end_applicationAdded(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__ApplicationObserver__applicationAdded_name);
}

void
IceProxy::IceGrid::ApplicationObserver::applicationRemoved(::Ice::Int serial, const ::std::string& name, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__ApplicationObserver__applicationRemoved_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::ApplicationObserver* __del = dynamic_cast< ::IceDelegate::IceGrid::ApplicationObserver*>(__delBase.get());
            __del->applicationRemoved(serial, name, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::ApplicationObserver::begin_applicationRemoved(::Ice::Int serial, const ::std::string& name, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__ApplicationObserver__applicationRemoved_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__ApplicationObserver__applicationRemoved_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(serial);
        __os->write(name);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::ApplicationObserver::end_applicationRemoved(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__ApplicationObserver__applicationRemoved_name);
}

void
IceProxy::IceGrid::ApplicationObserver::applicationUpdated(::Ice::Int serial, const ::IceGrid::ApplicationUpdateInfo& desc, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__ApplicationObserver__applicationUpdated_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::ApplicationObserver* __del = dynamic_cast< ::IceDelegate::IceGrid::ApplicationObserver*>(__delBase.get());
            __del->applicationUpdated(serial, desc, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::ApplicationObserver::begin_applicationUpdated(::Ice::Int serial, const ::IceGrid::ApplicationUpdateInfo& desc, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__ApplicationObserver__applicationUpdated_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__ApplicationObserver__applicationUpdated_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(serial);
        __os->write(desc);
        __os->writePendingObjects();
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::ApplicationObserver::end_applicationUpdated(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__ApplicationObserver__applicationUpdated_name);
}

const ::std::string&
IceProxy::IceGrid::ApplicationObserver::ice_staticId()
{
    return ::IceGrid::ApplicationObserver::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceGrid::ApplicationObserver::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceGrid::ApplicationObserver);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceGrid::ApplicationObserver::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceGrid::ApplicationObserver);
}

::IceProxy::Ice::Object*
IceProxy::IceGrid::ApplicationObserver::__newInstance() const
{
    return new ApplicationObserver;
}
#ifdef __SUNPRO_CC
class ICE_DECLSPEC_EXPORT IceProxy::IceGrid::AdapterObserver;
#endif
ICE_DECLSPEC_EXPORT ::IceProxy::Ice::Object* ::IceProxy::IceGrid::upCast(::IceProxy::IceGrid::AdapterObserver* p) { return p; }

void
::IceProxy::IceGrid::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::AdapterObserver>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceGrid::AdapterObserver;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::IceGrid::AdapterObserver::adapterInit(const ::IceGrid::AdapterInfoSeq& adpts, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__AdapterObserver__adapterInit_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::AdapterObserver* __del = dynamic_cast< ::IceDelegate::IceGrid::AdapterObserver*>(__delBase.get());
            __del->adapterInit(adpts, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::AdapterObserver::begin_adapterInit(const ::IceGrid::AdapterInfoSeq& adpts, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__AdapterObserver__adapterInit_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__AdapterObserver__adapterInit_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(adpts);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::AdapterObserver::end_adapterInit(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__AdapterObserver__adapterInit_name);
}

void
IceProxy::IceGrid::AdapterObserver::adapterAdded(const ::IceGrid::AdapterInfo& info, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__AdapterObserver__adapterAdded_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::AdapterObserver* __del = dynamic_cast< ::IceDelegate::IceGrid::AdapterObserver*>(__delBase.get());
            __del->adapterAdded(info, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::AdapterObserver::begin_adapterAdded(const ::IceGrid::AdapterInfo& info, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__AdapterObserver__adapterAdded_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__AdapterObserver__adapterAdded_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(info);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::AdapterObserver::end_adapterAdded(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__AdapterObserver__adapterAdded_name);
}

void
IceProxy::IceGrid::AdapterObserver::adapterUpdated(const ::IceGrid::AdapterInfo& info, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__AdapterObserver__adapterUpdated_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::AdapterObserver* __del = dynamic_cast< ::IceDelegate::IceGrid::AdapterObserver*>(__delBase.get());
            __del->adapterUpdated(info, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::AdapterObserver::begin_adapterUpdated(const ::IceGrid::AdapterInfo& info, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__AdapterObserver__adapterUpdated_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__AdapterObserver__adapterUpdated_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(info);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::AdapterObserver::end_adapterUpdated(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__AdapterObserver__adapterUpdated_name);
}

void
IceProxy::IceGrid::AdapterObserver::adapterRemoved(const ::std::string& id, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__AdapterObserver__adapterRemoved_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::AdapterObserver* __del = dynamic_cast< ::IceDelegate::IceGrid::AdapterObserver*>(__delBase.get());
            __del->adapterRemoved(id, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::AdapterObserver::begin_adapterRemoved(const ::std::string& id, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__AdapterObserver__adapterRemoved_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__AdapterObserver__adapterRemoved_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(id);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::AdapterObserver::end_adapterRemoved(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__AdapterObserver__adapterRemoved_name);
}

const ::std::string&
IceProxy::IceGrid::AdapterObserver::ice_staticId()
{
    return ::IceGrid::AdapterObserver::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceGrid::AdapterObserver::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceGrid::AdapterObserver);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceGrid::AdapterObserver::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceGrid::AdapterObserver);
}

::IceProxy::Ice::Object*
IceProxy::IceGrid::AdapterObserver::__newInstance() const
{
    return new AdapterObserver;
}
#ifdef __SUNPRO_CC
class ICE_DECLSPEC_EXPORT IceProxy::IceGrid::ObjectObserver;
#endif
ICE_DECLSPEC_EXPORT ::IceProxy::Ice::Object* ::IceProxy::IceGrid::upCast(::IceProxy::IceGrid::ObjectObserver* p) { return p; }

void
::IceProxy::IceGrid::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::ObjectObserver>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceGrid::ObjectObserver;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::IceGrid::ObjectObserver::objectInit(const ::IceGrid::ObjectInfoSeq& objects, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__ObjectObserver__objectInit_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::ObjectObserver* __del = dynamic_cast< ::IceDelegate::IceGrid::ObjectObserver*>(__delBase.get());
            __del->objectInit(objects, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::ObjectObserver::begin_objectInit(const ::IceGrid::ObjectInfoSeq& objects, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__ObjectObserver__objectInit_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__ObjectObserver__objectInit_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(objects);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::ObjectObserver::end_objectInit(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__ObjectObserver__objectInit_name);
}

void
IceProxy::IceGrid::ObjectObserver::objectAdded(const ::IceGrid::ObjectInfo& info, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__ObjectObserver__objectAdded_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::ObjectObserver* __del = dynamic_cast< ::IceDelegate::IceGrid::ObjectObserver*>(__delBase.get());
            __del->objectAdded(info, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::ObjectObserver::begin_objectAdded(const ::IceGrid::ObjectInfo& info, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__ObjectObserver__objectAdded_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__ObjectObserver__objectAdded_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(info);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::ObjectObserver::end_objectAdded(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__ObjectObserver__objectAdded_name);
}

void
IceProxy::IceGrid::ObjectObserver::objectUpdated(const ::IceGrid::ObjectInfo& info, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__ObjectObserver__objectUpdated_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::ObjectObserver* __del = dynamic_cast< ::IceDelegate::IceGrid::ObjectObserver*>(__delBase.get());
            __del->objectUpdated(info, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::ObjectObserver::begin_objectUpdated(const ::IceGrid::ObjectInfo& info, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__ObjectObserver__objectUpdated_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__ObjectObserver__objectUpdated_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(info);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::ObjectObserver::end_objectUpdated(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__ObjectObserver__objectUpdated_name);
}

void
IceProxy::IceGrid::ObjectObserver::objectRemoved(const ::Ice::Identity& id, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__ObjectObserver__objectRemoved_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::ObjectObserver* __del = dynamic_cast< ::IceDelegate::IceGrid::ObjectObserver*>(__delBase.get());
            __del->objectRemoved(id, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::ObjectObserver::begin_objectRemoved(const ::Ice::Identity& id, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__ObjectObserver__objectRemoved_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__ObjectObserver__objectRemoved_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(id);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::ObjectObserver::end_objectRemoved(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__ObjectObserver__objectRemoved_name);
}

const ::std::string&
IceProxy::IceGrid::ObjectObserver::ice_staticId()
{
    return ::IceGrid::ObjectObserver::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceGrid::ObjectObserver::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceGrid::ObjectObserver);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceGrid::ObjectObserver::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceGrid::ObjectObserver);
}

::IceProxy::Ice::Object*
IceProxy::IceGrid::ObjectObserver::__newInstance() const
{
    return new ObjectObserver;
}
#ifdef __SUNPRO_CC
class ICE_DECLSPEC_EXPORT IceProxy::IceGrid::RegistryObserver;
#endif
ICE_DECLSPEC_EXPORT ::IceProxy::Ice::Object* ::IceProxy::IceGrid::upCast(::IceProxy::IceGrid::RegistryObserver* p) { return p; }

void
::IceProxy::IceGrid::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::RegistryObserver>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceGrid::RegistryObserver;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::IceGrid::RegistryObserver::registryInit(const ::IceGrid::RegistryInfoSeq& registries, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__RegistryObserver__registryInit_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::RegistryObserver* __del = dynamic_cast< ::IceDelegate::IceGrid::RegistryObserver*>(__delBase.get());
            __del->registryInit(registries, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::RegistryObserver::begin_registryInit(const ::IceGrid::RegistryInfoSeq& registries, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__RegistryObserver__registryInit_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__RegistryObserver__registryInit_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(registries);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::RegistryObserver::end_registryInit(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__RegistryObserver__registryInit_name);
}

void
IceProxy::IceGrid::RegistryObserver::registryUp(const ::IceGrid::RegistryInfo& node, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__RegistryObserver__registryUp_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::RegistryObserver* __del = dynamic_cast< ::IceDelegate::IceGrid::RegistryObserver*>(__delBase.get());
            __del->registryUp(node, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::RegistryObserver::begin_registryUp(const ::IceGrid::RegistryInfo& node, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__RegistryObserver__registryUp_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__RegistryObserver__registryUp_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(node);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::RegistryObserver::end_registryUp(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__RegistryObserver__registryUp_name);
}

void
IceProxy::IceGrid::RegistryObserver::registryDown(const ::std::string& name, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__RegistryObserver__registryDown_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::RegistryObserver* __del = dynamic_cast< ::IceDelegate::IceGrid::RegistryObserver*>(__delBase.get());
            __del->registryDown(name, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::RegistryObserver::begin_registryDown(const ::std::string& name, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__RegistryObserver__registryDown_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__RegistryObserver__registryDown_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(name);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::RegistryObserver::end_registryDown(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__RegistryObserver__registryDown_name);
}

const ::std::string&
IceProxy::IceGrid::RegistryObserver::ice_staticId()
{
    return ::IceGrid::RegistryObserver::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceGrid::RegistryObserver::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceGrid::RegistryObserver);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceGrid::RegistryObserver::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceGrid::RegistryObserver);
}

::IceProxy::Ice::Object*
IceProxy::IceGrid::RegistryObserver::__newInstance() const
{
    return new RegistryObserver;
}

void
IceDelegateM::IceGrid::NodeObserver::nodeInit(const ::IceGrid::NodeDynamicInfoSeq& nodes, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__NodeObserver__nodeInit_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(nodes);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::IceGrid::NodeObserver::nodeUp(const ::IceGrid::NodeDynamicInfo& node, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__NodeObserver__nodeUp_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(node);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::IceGrid::NodeObserver::nodeDown(const ::std::string& name, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__NodeObserver__nodeDown_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(name);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::IceGrid::NodeObserver::updateServer(const ::std::string& node, const ::IceGrid::ServerDynamicInfo& updatedInfo, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__NodeObserver__updateServer_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(node);
        __os->write(updatedInfo);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::IceGrid::NodeObserver::updateAdapter(const ::std::string& node, const ::IceGrid::AdapterDynamicInfo& updatedInfo, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__NodeObserver__updateAdapter_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(node);
        __os->write(updatedInfo);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::IceGrid::ApplicationObserver::applicationInit(::Ice::Int serial, const ::IceGrid::ApplicationInfoSeq& applications, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__ApplicationObserver__applicationInit_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(serial);
        __os->write(applications);
        __os->writePendingObjects();
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::IceGrid::ApplicationObserver::applicationAdded(::Ice::Int serial, const ::IceGrid::ApplicationInfo& desc, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__ApplicationObserver__applicationAdded_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(serial);
        __os->write(desc);
        __os->writePendingObjects();
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::IceGrid::ApplicationObserver::applicationRemoved(::Ice::Int serial, const ::std::string& name, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__ApplicationObserver__applicationRemoved_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(serial);
        __os->write(name);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::IceGrid::ApplicationObserver::applicationUpdated(::Ice::Int serial, const ::IceGrid::ApplicationUpdateInfo& desc, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__ApplicationObserver__applicationUpdated_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(serial);
        __os->write(desc);
        __os->writePendingObjects();
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::IceGrid::AdapterObserver::adapterInit(const ::IceGrid::AdapterInfoSeq& adpts, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__AdapterObserver__adapterInit_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(adpts);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::IceGrid::AdapterObserver::adapterAdded(const ::IceGrid::AdapterInfo& info, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__AdapterObserver__adapterAdded_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(info);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::IceGrid::AdapterObserver::adapterUpdated(const ::IceGrid::AdapterInfo& info, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__AdapterObserver__adapterUpdated_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(info);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::IceGrid::AdapterObserver::adapterRemoved(const ::std::string& id, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__AdapterObserver__adapterRemoved_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(id);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::IceGrid::ObjectObserver::objectInit(const ::IceGrid::ObjectInfoSeq& objects, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__ObjectObserver__objectInit_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(objects);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::IceGrid::ObjectObserver::objectAdded(const ::IceGrid::ObjectInfo& info, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__ObjectObserver__objectAdded_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(info);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::IceGrid::ObjectObserver::objectUpdated(const ::IceGrid::ObjectInfo& info, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__ObjectObserver__objectUpdated_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(info);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::IceGrid::ObjectObserver::objectRemoved(const ::Ice::Identity& id, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__ObjectObserver__objectRemoved_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(id);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::IceGrid::RegistryObserver::registryInit(const ::IceGrid::RegistryInfoSeq& registries, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__RegistryObserver__registryInit_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(registries);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::IceGrid::RegistryObserver::registryUp(const ::IceGrid::RegistryInfo& node, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__RegistryObserver__registryUp_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(node);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::IceGrid::RegistryObserver::registryDown(const ::std::string& name, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__RegistryObserver__registryDown_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(name);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateD::IceGrid::NodeObserver::nodeInit(const ::IceGrid::NodeDynamicInfoSeq& nodes, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::IceGrid::NodeDynamicInfoSeq& __p_nodes, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_nodes(__p_nodes)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::NodeObserver* servant = dynamic_cast< ::IceGrid::NodeObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->nodeInit(_m_nodes, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::IceGrid::NodeDynamicInfoSeq& _m_nodes;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__NodeObserver__nodeInit_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(nodes, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceGrid::NodeObserver::nodeUp(const ::IceGrid::NodeDynamicInfo& node, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::IceGrid::NodeDynamicInfo& __p_node, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_node(__p_node)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::NodeObserver* servant = dynamic_cast< ::IceGrid::NodeObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->nodeUp(_m_node, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::IceGrid::NodeDynamicInfo& _m_node;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__NodeObserver__nodeUp_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(node, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceGrid::NodeObserver::nodeDown(const ::std::string& name, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_name, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_name(__p_name)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::NodeObserver* servant = dynamic_cast< ::IceGrid::NodeObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->nodeDown(_m_name, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_name;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__NodeObserver__nodeDown_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(name, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceGrid::NodeObserver::updateServer(const ::std::string& node, const ::IceGrid::ServerDynamicInfo& updatedInfo, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_node, const ::IceGrid::ServerDynamicInfo& __p_updatedInfo, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_node(__p_node),
            _m_updatedInfo(__p_updatedInfo)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::NodeObserver* servant = dynamic_cast< ::IceGrid::NodeObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->updateServer(_m_node, _m_updatedInfo, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_node;
        const ::IceGrid::ServerDynamicInfo& _m_updatedInfo;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__NodeObserver__updateServer_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(node, updatedInfo, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceGrid::NodeObserver::updateAdapter(const ::std::string& node, const ::IceGrid::AdapterDynamicInfo& updatedInfo, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_node, const ::IceGrid::AdapterDynamicInfo& __p_updatedInfo, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_node(__p_node),
            _m_updatedInfo(__p_updatedInfo)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::NodeObserver* servant = dynamic_cast< ::IceGrid::NodeObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->updateAdapter(_m_node, _m_updatedInfo, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_node;
        const ::IceGrid::AdapterDynamicInfo& _m_updatedInfo;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__NodeObserver__updateAdapter_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(node, updatedInfo, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceGrid::ApplicationObserver::applicationInit(::Ice::Int serial, const ::IceGrid::ApplicationInfoSeq& applications, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int __p_serial, const ::IceGrid::ApplicationInfoSeq& __p_applications, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_serial(__p_serial),
            _m_applications(__p_applications)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::ApplicationObserver* servant = dynamic_cast< ::IceGrid::ApplicationObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->applicationInit(_m_serial, _m_applications, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_serial;
        const ::IceGrid::ApplicationInfoSeq& _m_applications;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__ApplicationObserver__applicationInit_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(serial, applications, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceGrid::ApplicationObserver::applicationAdded(::Ice::Int serial, const ::IceGrid::ApplicationInfo& desc, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int __p_serial, const ::IceGrid::ApplicationInfo& __p_desc, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_serial(__p_serial),
            _m_desc(__p_desc)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::ApplicationObserver* servant = dynamic_cast< ::IceGrid::ApplicationObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->applicationAdded(_m_serial, _m_desc, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_serial;
        const ::IceGrid::ApplicationInfo& _m_desc;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__ApplicationObserver__applicationAdded_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(serial, desc, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceGrid::ApplicationObserver::applicationRemoved(::Ice::Int serial, const ::std::string& name, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int __p_serial, const ::std::string& __p_name, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_serial(__p_serial),
            _m_name(__p_name)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::ApplicationObserver* servant = dynamic_cast< ::IceGrid::ApplicationObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->applicationRemoved(_m_serial, _m_name, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_serial;
        const ::std::string& _m_name;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__ApplicationObserver__applicationRemoved_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(serial, name, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceGrid::ApplicationObserver::applicationUpdated(::Ice::Int serial, const ::IceGrid::ApplicationUpdateInfo& desc, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int __p_serial, const ::IceGrid::ApplicationUpdateInfo& __p_desc, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_serial(__p_serial),
            _m_desc(__p_desc)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::ApplicationObserver* servant = dynamic_cast< ::IceGrid::ApplicationObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->applicationUpdated(_m_serial, _m_desc, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_serial;
        const ::IceGrid::ApplicationUpdateInfo& _m_desc;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__ApplicationObserver__applicationUpdated_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(serial, desc, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceGrid::AdapterObserver::adapterInit(const ::IceGrid::AdapterInfoSeq& adpts, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::IceGrid::AdapterInfoSeq& __p_adpts, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_adpts(__p_adpts)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::AdapterObserver* servant = dynamic_cast< ::IceGrid::AdapterObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->adapterInit(_m_adpts, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::IceGrid::AdapterInfoSeq& _m_adpts;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__AdapterObserver__adapterInit_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(adpts, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceGrid::AdapterObserver::adapterAdded(const ::IceGrid::AdapterInfo& info, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::IceGrid::AdapterInfo& __p_info, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_info(__p_info)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::AdapterObserver* servant = dynamic_cast< ::IceGrid::AdapterObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->adapterAdded(_m_info, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::IceGrid::AdapterInfo& _m_info;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__AdapterObserver__adapterAdded_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(info, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceGrid::AdapterObserver::adapterUpdated(const ::IceGrid::AdapterInfo& info, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::IceGrid::AdapterInfo& __p_info, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_info(__p_info)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::AdapterObserver* servant = dynamic_cast< ::IceGrid::AdapterObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->adapterUpdated(_m_info, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::IceGrid::AdapterInfo& _m_info;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__AdapterObserver__adapterUpdated_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(info, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceGrid::AdapterObserver::adapterRemoved(const ::std::string& id, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_id, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_id(__p_id)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::AdapterObserver* servant = dynamic_cast< ::IceGrid::AdapterObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->adapterRemoved(_m_id, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_id;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__AdapterObserver__adapterRemoved_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(id, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceGrid::ObjectObserver::objectInit(const ::IceGrid::ObjectInfoSeq& objects, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::IceGrid::ObjectInfoSeq& __p_objects, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_objects(__p_objects)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::ObjectObserver* servant = dynamic_cast< ::IceGrid::ObjectObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->objectInit(_m_objects, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::IceGrid::ObjectInfoSeq& _m_objects;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__ObjectObserver__objectInit_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(objects, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceGrid::ObjectObserver::objectAdded(const ::IceGrid::ObjectInfo& info, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::IceGrid::ObjectInfo& __p_info, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_info(__p_info)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::ObjectObserver* servant = dynamic_cast< ::IceGrid::ObjectObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->objectAdded(_m_info, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::IceGrid::ObjectInfo& _m_info;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__ObjectObserver__objectAdded_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(info, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceGrid::ObjectObserver::objectUpdated(const ::IceGrid::ObjectInfo& info, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::IceGrid::ObjectInfo& __p_info, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_info(__p_info)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::ObjectObserver* servant = dynamic_cast< ::IceGrid::ObjectObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->objectUpdated(_m_info, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::IceGrid::ObjectInfo& _m_info;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__ObjectObserver__objectUpdated_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(info, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceGrid::ObjectObserver::objectRemoved(const ::Ice::Identity& id, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Identity& __p_id, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_id(__p_id)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::ObjectObserver* servant = dynamic_cast< ::IceGrid::ObjectObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->objectRemoved(_m_id, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::Ice::Identity& _m_id;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__ObjectObserver__objectRemoved_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(id, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceGrid::RegistryObserver::registryInit(const ::IceGrid::RegistryInfoSeq& registries, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::IceGrid::RegistryInfoSeq& __p_registries, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_registries(__p_registries)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::RegistryObserver* servant = dynamic_cast< ::IceGrid::RegistryObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->registryInit(_m_registries, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::IceGrid::RegistryInfoSeq& _m_registries;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__RegistryObserver__registryInit_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(registries, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceGrid::RegistryObserver::registryUp(const ::IceGrid::RegistryInfo& node, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::IceGrid::RegistryInfo& __p_node, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_node(__p_node)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::RegistryObserver* servant = dynamic_cast< ::IceGrid::RegistryObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->registryUp(_m_node, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::IceGrid::RegistryInfo& _m_node;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__RegistryObserver__registryUp_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(node, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceGrid::RegistryObserver::registryDown(const ::std::string& name, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_name, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_name(__p_name)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::RegistryObserver* servant = dynamic_cast< ::IceGrid::RegistryObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->registryDown(_m_name, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_name;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__RegistryObserver__registryDown_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(name, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

ICE_DECLSPEC_EXPORT ::Ice::Object* IceGrid::upCast(::IceGrid::NodeObserver* p) { return p; }

namespace
{
const ::std::string __IceGrid__NodeObserver_ids[2] =
{
    "::Ice::Object",
    "::IceGrid::NodeObserver"
};

}

bool
IceGrid::NodeObserver::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceGrid__NodeObserver_ids, __IceGrid__NodeObserver_ids + 2, _s);
}

::std::vector< ::std::string>
IceGrid::NodeObserver::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceGrid__NodeObserver_ids[0], &__IceGrid__NodeObserver_ids[2]);
}

const ::std::string&
IceGrid::NodeObserver::ice_id(const ::Ice::Current&) const
{
    return __IceGrid__NodeObserver_ids[1];
}

const ::std::string&
IceGrid::NodeObserver::ice_staticId()
{
    return __IceGrid__NodeObserver_ids[1];
}

::Ice::DispatchStatus
IceGrid::NodeObserver::___nodeInit(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::IceGrid::NodeDynamicInfoSeq nodes;
    __is->read(nodes);
    __inS.endReadParams();
    nodeInit(nodes, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::NodeObserver::___nodeUp(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::IceGrid::NodeDynamicInfo node;
    __is->read(node);
    __inS.endReadParams();
    nodeUp(node, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::NodeObserver::___nodeDown(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string name;
    __is->read(name);
    __inS.endReadParams();
    nodeDown(name, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::NodeObserver::___updateServer(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string node;
    ::IceGrid::ServerDynamicInfo updatedInfo;
    __is->read(node);
    __is->read(updatedInfo);
    __inS.endReadParams();
    updateServer(node, updatedInfo, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::NodeObserver::___updateAdapter(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string node;
    ::IceGrid::AdapterDynamicInfo updatedInfo;
    __is->read(node);
    __is->read(updatedInfo);
    __inS.endReadParams();
    updateAdapter(node, updatedInfo, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __IceGrid__NodeObserver_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "nodeDown",
    "nodeInit",
    "nodeUp",
    "updateAdapter",
    "updateServer"
};

}

::Ice::DispatchStatus
IceGrid::NodeObserver::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__IceGrid__NodeObserver_all, __IceGrid__NodeObserver_all + 9, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __IceGrid__NodeObserver_all)
    {
        case 0:
        {
            return ___ice_id(in, current);
        }
        case 1:
        {
            return ___ice_ids(in, current);
        }
        case 2:
        {
            return ___ice_isA(in, current);
        }
        case 3:
        {
            return ___ice_ping(in, current);
        }
        case 4:
        {
            return ___nodeDown(in, current);
        }
        case 5:
        {
            return ___nodeInit(in, current);
        }
        case 6:
        {
            return ___nodeUp(in, current);
        }
        case 7:
        {
            return ___updateAdapter(in, current);
        }
        case 8:
        {
            return ___updateServer(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
IceGrid::NodeObserver::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
IceGrid::NodeObserver::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void ICE_DECLSPEC_EXPORT 
IceGrid::__patch(NodeObserverPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceGrid::NodeObserverPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceGrid::NodeObserver::ice_staticId(), v);
    }
}

ICE_DECLSPEC_EXPORT ::Ice::Object* IceGrid::upCast(::IceGrid::ApplicationObserver* p) { return p; }

namespace
{
const ::std::string __IceGrid__ApplicationObserver_ids[2] =
{
    "::Ice::Object",
    "::IceGrid::ApplicationObserver"
};

}

bool
IceGrid::ApplicationObserver::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceGrid__ApplicationObserver_ids, __IceGrid__ApplicationObserver_ids + 2, _s);
}

::std::vector< ::std::string>
IceGrid::ApplicationObserver::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceGrid__ApplicationObserver_ids[0], &__IceGrid__ApplicationObserver_ids[2]);
}

const ::std::string&
IceGrid::ApplicationObserver::ice_id(const ::Ice::Current&) const
{
    return __IceGrid__ApplicationObserver_ids[1];
}

const ::std::string&
IceGrid::ApplicationObserver::ice_staticId()
{
    return __IceGrid__ApplicationObserver_ids[1];
}

::Ice::DispatchStatus
IceGrid::ApplicationObserver::___applicationInit(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int serial;
    ::IceGrid::ApplicationInfoSeq applications;
    __is->read(serial);
    __is->read(applications);
    __is->readPendingObjects();
    __inS.endReadParams();
    applicationInit(serial, applications, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::ApplicationObserver::___applicationAdded(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int serial;
    ::IceGrid::ApplicationInfo desc;
    __is->read(serial);
    __is->read(desc);
    __is->readPendingObjects();
    __inS.endReadParams();
    applicationAdded(serial, desc, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::ApplicationObserver::___applicationRemoved(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int serial;
    ::std::string name;
    __is->read(serial);
    __is->read(name);
    __inS.endReadParams();
    applicationRemoved(serial, name, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::ApplicationObserver::___applicationUpdated(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int serial;
    ::IceGrid::ApplicationUpdateInfo desc;
    __is->read(serial);
    __is->read(desc);
    __is->readPendingObjects();
    __inS.endReadParams();
    applicationUpdated(serial, desc, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __IceGrid__ApplicationObserver_all[] =
{
    "applicationAdded",
    "applicationInit",
    "applicationRemoved",
    "applicationUpdated",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
IceGrid::ApplicationObserver::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__IceGrid__ApplicationObserver_all, __IceGrid__ApplicationObserver_all + 8, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __IceGrid__ApplicationObserver_all)
    {
        case 0:
        {
            return ___applicationAdded(in, current);
        }
        case 1:
        {
            return ___applicationInit(in, current);
        }
        case 2:
        {
            return ___applicationRemoved(in, current);
        }
        case 3:
        {
            return ___applicationUpdated(in, current);
        }
        case 4:
        {
            return ___ice_id(in, current);
        }
        case 5:
        {
            return ___ice_ids(in, current);
        }
        case 6:
        {
            return ___ice_isA(in, current);
        }
        case 7:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
IceGrid::ApplicationObserver::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
IceGrid::ApplicationObserver::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void ICE_DECLSPEC_EXPORT 
IceGrid::__patch(ApplicationObserverPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceGrid::ApplicationObserverPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceGrid::ApplicationObserver::ice_staticId(), v);
    }
}

ICE_DECLSPEC_EXPORT ::Ice::Object* IceGrid::upCast(::IceGrid::AdapterObserver* p) { return p; }

namespace
{
const ::std::string __IceGrid__AdapterObserver_ids[2] =
{
    "::Ice::Object",
    "::IceGrid::AdapterObserver"
};

}

bool
IceGrid::AdapterObserver::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceGrid__AdapterObserver_ids, __IceGrid__AdapterObserver_ids + 2, _s);
}

::std::vector< ::std::string>
IceGrid::AdapterObserver::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceGrid__AdapterObserver_ids[0], &__IceGrid__AdapterObserver_ids[2]);
}

const ::std::string&
IceGrid::AdapterObserver::ice_id(const ::Ice::Current&) const
{
    return __IceGrid__AdapterObserver_ids[1];
}

const ::std::string&
IceGrid::AdapterObserver::ice_staticId()
{
    return __IceGrid__AdapterObserver_ids[1];
}

::Ice::DispatchStatus
IceGrid::AdapterObserver::___adapterInit(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::IceGrid::AdapterInfoSeq adpts;
    __is->read(adpts);
    __inS.endReadParams();
    adapterInit(adpts, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::AdapterObserver::___adapterAdded(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::IceGrid::AdapterInfo info;
    __is->read(info);
    __inS.endReadParams();
    adapterAdded(info, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::AdapterObserver::___adapterUpdated(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::IceGrid::AdapterInfo info;
    __is->read(info);
    __inS.endReadParams();
    adapterUpdated(info, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::AdapterObserver::___adapterRemoved(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string id;
    __is->read(id);
    __inS.endReadParams();
    adapterRemoved(id, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __IceGrid__AdapterObserver_all[] =
{
    "adapterAdded",
    "adapterInit",
    "adapterRemoved",
    "adapterUpdated",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
IceGrid::AdapterObserver::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__IceGrid__AdapterObserver_all, __IceGrid__AdapterObserver_all + 8, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __IceGrid__AdapterObserver_all)
    {
        case 0:
        {
            return ___adapterAdded(in, current);
        }
        case 1:
        {
            return ___adapterInit(in, current);
        }
        case 2:
        {
            return ___adapterRemoved(in, current);
        }
        case 3:
        {
            return ___adapterUpdated(in, current);
        }
        case 4:
        {
            return ___ice_id(in, current);
        }
        case 5:
        {
            return ___ice_ids(in, current);
        }
        case 6:
        {
            return ___ice_isA(in, current);
        }
        case 7:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
IceGrid::AdapterObserver::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
IceGrid::AdapterObserver::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void ICE_DECLSPEC_EXPORT 
IceGrid::__patch(AdapterObserverPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceGrid::AdapterObserverPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceGrid::AdapterObserver::ice_staticId(), v);
    }
}

ICE_DECLSPEC_EXPORT ::Ice::Object* IceGrid::upCast(::IceGrid::ObjectObserver* p) { return p; }

namespace
{
const ::std::string __IceGrid__ObjectObserver_ids[2] =
{
    "::Ice::Object",
    "::IceGrid::ObjectObserver"
};

}

bool
IceGrid::ObjectObserver::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceGrid__ObjectObserver_ids, __IceGrid__ObjectObserver_ids + 2, _s);
}

::std::vector< ::std::string>
IceGrid::ObjectObserver::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceGrid__ObjectObserver_ids[0], &__IceGrid__ObjectObserver_ids[2]);
}

const ::std::string&
IceGrid::ObjectObserver::ice_id(const ::Ice::Current&) const
{
    return __IceGrid__ObjectObserver_ids[1];
}

const ::std::string&
IceGrid::ObjectObserver::ice_staticId()
{
    return __IceGrid__ObjectObserver_ids[1];
}

::Ice::DispatchStatus
IceGrid::ObjectObserver::___objectInit(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::IceGrid::ObjectInfoSeq objects;
    __is->read(objects);
    __inS.endReadParams();
    objectInit(objects, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::ObjectObserver::___objectAdded(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::IceGrid::ObjectInfo info;
    __is->read(info);
    __inS.endReadParams();
    objectAdded(info, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::ObjectObserver::___objectUpdated(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::IceGrid::ObjectInfo info;
    __is->read(info);
    __inS.endReadParams();
    objectUpdated(info, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::ObjectObserver::___objectRemoved(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Identity id;
    __is->read(id);
    __inS.endReadParams();
    objectRemoved(id, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __IceGrid__ObjectObserver_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "objectAdded",
    "objectInit",
    "objectRemoved",
    "objectUpdated"
};

}

::Ice::DispatchStatus
IceGrid::ObjectObserver::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__IceGrid__ObjectObserver_all, __IceGrid__ObjectObserver_all + 8, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __IceGrid__ObjectObserver_all)
    {
        case 0:
        {
            return ___ice_id(in, current);
        }
        case 1:
        {
            return ___ice_ids(in, current);
        }
        case 2:
        {
            return ___ice_isA(in, current);
        }
        case 3:
        {
            return ___ice_ping(in, current);
        }
        case 4:
        {
            return ___objectAdded(in, current);
        }
        case 5:
        {
            return ___objectInit(in, current);
        }
        case 6:
        {
            return ___objectRemoved(in, current);
        }
        case 7:
        {
            return ___objectUpdated(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
IceGrid::ObjectObserver::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
IceGrid::ObjectObserver::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void ICE_DECLSPEC_EXPORT 
IceGrid::__patch(ObjectObserverPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceGrid::ObjectObserverPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceGrid::ObjectObserver::ice_staticId(), v);
    }
}

ICE_DECLSPEC_EXPORT ::Ice::Object* IceGrid::upCast(::IceGrid::RegistryObserver* p) { return p; }

namespace
{
const ::std::string __IceGrid__RegistryObserver_ids[2] =
{
    "::Ice::Object",
    "::IceGrid::RegistryObserver"
};

}

bool
IceGrid::RegistryObserver::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceGrid__RegistryObserver_ids, __IceGrid__RegistryObserver_ids + 2, _s);
}

::std::vector< ::std::string>
IceGrid::RegistryObserver::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceGrid__RegistryObserver_ids[0], &__IceGrid__RegistryObserver_ids[2]);
}

const ::std::string&
IceGrid::RegistryObserver::ice_id(const ::Ice::Current&) const
{
    return __IceGrid__RegistryObserver_ids[1];
}

const ::std::string&
IceGrid::RegistryObserver::ice_staticId()
{
    return __IceGrid__RegistryObserver_ids[1];
}

::Ice::DispatchStatus
IceGrid::RegistryObserver::___registryInit(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::IceGrid::RegistryInfoSeq registries;
    __is->read(registries);
    __inS.endReadParams();
    registryInit(registries, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::RegistryObserver::___registryUp(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::IceGrid::RegistryInfo node;
    __is->read(node);
    __inS.endReadParams();
    registryUp(node, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::RegistryObserver::___registryDown(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string name;
    __is->read(name);
    __inS.endReadParams();
    registryDown(name, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __IceGrid__RegistryObserver_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "registryDown",
    "registryInit",
    "registryUp"
};

}

::Ice::DispatchStatus
IceGrid::RegistryObserver::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__IceGrid__RegistryObserver_all, __IceGrid__RegistryObserver_all + 7, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __IceGrid__RegistryObserver_all)
    {
        case 0:
        {
            return ___ice_id(in, current);
        }
        case 1:
        {
            return ___ice_ids(in, current);
        }
        case 2:
        {
            return ___ice_isA(in, current);
        }
        case 3:
        {
            return ___ice_ping(in, current);
        }
        case 4:
        {
            return ___registryDown(in, current);
        }
        case 5:
        {
            return ___registryInit(in, current);
        }
        case 6:
        {
            return ___registryUp(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
IceGrid::RegistryObserver::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
IceGrid::RegistryObserver::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void ICE_DECLSPEC_EXPORT 
IceGrid::__patch(RegistryObserverPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceGrid::RegistryObserverPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceGrid::RegistryObserver::ice_staticId(), v);
    }
}

namespace
{

const char* __sliceChecksums[] =
{
    "::IceGrid::AdapterDynamicInfo", "b371e9a58f115e6ebfbcda735fee57f7",
    "::IceGrid::AdapterDynamicInfoSeq", "54465843167a2f93fa96d13b7f41ea32",
    "::IceGrid::AdapterObserver", "7f4ed59e236da9d6c35ad7e6ad9cb0",
    "::IceGrid::ApplicationObserver", "2862cdcba54714282f68b13a8fb4ae",
    "::IceGrid::NodeDynamicInfo", "3ad52341f32973212d26a9a6dda08b",
    "::IceGrid::NodeDynamicInfoSeq", "f61633c5e3992f718dba78b7f165c2",
    "::IceGrid::NodeObserver", "e06c1ad6807d2876de9e818855a65738",
    "::IceGrid::ObjectObserver", "5364683a872f127e46cc5e215d98c3c",
    "::IceGrid::RegistryObserver", "fd83b1558e7c77f2d322b25449518",
    "::IceGrid::ServerDynamicInfo", "fd4b9177ca54ae4688b51fa51d6870",
    "::IceGrid::ServerDynamicInfoSeq", "e3fda58997d5cd946e78cae739174cb",
    0
};
const IceInternal::SliceChecksumInit __sliceChecksumInit(__sliceChecksums);

}
