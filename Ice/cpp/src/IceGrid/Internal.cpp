// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `Internal.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <IceGrid/Internal.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/BasicStream.h>
#include <Ice/Object.h>
#include <Ice/SlicedData.h>
#include <Ice/SliceChecksums.h>
#include <IceUtil/Iterator.h>
#include <IceUtil/DisableWarnings.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace
{

const ::std::string __IceGrid__Adapter__activate_name = "activate";

const ::std::string __IceGrid__Adapter__getDirectProxy_name = "getDirectProxy";

const ::std::string __IceGrid__Adapter__setDirectProxy_name = "setDirectProxy";

const ::std::string __IceGrid__FileReader__getOffsetFromEnd_name = "getOffsetFromEnd";

const ::std::string __IceGrid__FileReader__read_name = "read";

const ::std::string __IceGrid__Server__start_name = "start";

const ::std::string __IceGrid__Server__stop_name = "stop";

const ::std::string __IceGrid__Server__checkUpdate_name = "checkUpdate";

const ::std::string __IceGrid__Server__setEnabled_name = "setEnabled";

const ::std::string __IceGrid__Server__isEnabled_name = "isEnabled";

const ::std::string __IceGrid__Server__sendSignal_name = "sendSignal";

const ::std::string __IceGrid__Server__writeMessage_name = "writeMessage";

const ::std::string __IceGrid__Server__getState_name = "getState";

const ::std::string __IceGrid__Server__getPid_name = "getPid";

const ::std::string __IceGrid__Server__setProcess_name = "setProcess";

const ::std::string __IceGrid__ReplicaObserver__replicaInit_name = "replicaInit";

const ::std::string __IceGrid__ReplicaObserver__replicaAdded_name = "replicaAdded";

const ::std::string __IceGrid__ReplicaObserver__replicaRemoved_name = "replicaRemoved";

const ::std::string __IceGrid__PatcherFeedback__finished_name = "finished";

const ::std::string __IceGrid__PatcherFeedback__failed_name = "failed";

const ::std::string __IceGrid__Node__loadServer_name = "loadServer";

const ::std::string __IceGrid__Node__loadServerWithoutRestart_name = "loadServerWithoutRestart";

const ::std::string __IceGrid__Node__destroyServer_name = "destroyServer";

const ::std::string __IceGrid__Node__patch_name = "patch";

const ::std::string __IceGrid__Node__registerWithReplica_name = "registerWithReplica";

const ::std::string __IceGrid__Node__getName_name = "getName";

const ::std::string __IceGrid__Node__getHostname_name = "getHostname";

const ::std::string __IceGrid__Node__getLoad_name = "getLoad";

const ::std::string __IceGrid__Node__getProcessorSocketCount_name = "getProcessorSocketCount";

const ::std::string __IceGrid__Node__shutdown_name = "shutdown";

const ::std::string __IceGrid__NodeSession__keepAlive_name = "keepAlive";

const ::std::string __IceGrid__NodeSession__setReplicaObserver_name = "setReplicaObserver";

const ::std::string __IceGrid__NodeSession__getTimeout_name = "getTimeout";

const ::std::string __IceGrid__NodeSession__getObserver_name = "getObserver";

const ::std::string __IceGrid__NodeSession__loadServers_name = "loadServers";

const ::std::string __IceGrid__NodeSession__getServers_name = "getServers";

const ::std::string __IceGrid__NodeSession__waitForApplicationUpdate_name = "waitForApplicationUpdate";

const ::std::string __IceGrid__NodeSession__destroy_name = "destroy";

const ::std::string __IceGrid__ReplicaSession__keepAlive_name = "keepAlive";

const ::std::string __IceGrid__ReplicaSession__getTimeout_name = "getTimeout";

const ::std::string __IceGrid__ReplicaSession__setDatabaseObserver_name = "setDatabaseObserver";

const ::std::string __IceGrid__ReplicaSession__setEndpoints_name = "setEndpoints";

const ::std::string __IceGrid__ReplicaSession__registerWellKnownObjects_name = "registerWellKnownObjects";

const ::std::string __IceGrid__ReplicaSession__setAdapterDirectProxy_name = "setAdapterDirectProxy";

const ::std::string __IceGrid__ReplicaSession__receivedUpdate_name = "receivedUpdate";

const ::std::string __IceGrid__ReplicaSession__destroy_name = "destroy";

const ::std::string __IceGrid__InternalRegistry__registerNode_name = "registerNode";

const ::std::string __IceGrid__InternalRegistry__registerReplica_name = "registerReplica";

const ::std::string __IceGrid__InternalRegistry__registerWithReplica_name = "registerWithReplica";

const ::std::string __IceGrid__InternalRegistry__getNodes_name = "getNodes";

const ::std::string __IceGrid__InternalRegistry__getReplicas_name = "getReplicas";

const ::std::string __IceGrid__InternalRegistry__getApplications_name = "getApplications";

const ::std::string __IceGrid__InternalRegistry__getAdapters_name = "getAdapters";

const ::std::string __IceGrid__InternalRegistry__getObjects_name = "getObjects";

const ::std::string __IceGrid__InternalRegistry__shutdown_name = "shutdown";

}

namespace
{

const char* __IceGrid__SynchronizationException_name = "IceGrid::SynchronizationException";

}

IceGrid::SynchronizationException::SynchronizationException(const char* __file, int __line) :
    ::Ice::LocalException(__file, __line)
{
}

IceGrid::SynchronizationException::~SynchronizationException() throw()
{
}

::std::string
IceGrid::SynchronizationException::ice_name() const
{
    return __IceGrid__SynchronizationException_name;
}

IceGrid::SynchronizationException*
IceGrid::SynchronizationException::ice_clone() const
{
    return new SynchronizationException(*this);
}

void
IceGrid::SynchronizationException::ice_throw() const
{
    throw *this;
}

namespace
{

const char* __IceGrid__AdapterActiveException_name = "IceGrid::AdapterActiveException";

struct __F__IceGrid__AdapterActiveException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::IceGrid::AdapterActiveException();
    }
};

class __F__IceGrid__AdapterActiveException__Init
{
public:

    __F__IceGrid__AdapterActiveException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::IceGrid::AdapterActiveException", new __F__IceGrid__AdapterActiveException);
    }

    ~__F__IceGrid__AdapterActiveException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::IceGrid::AdapterActiveException");
    }
};

const __F__IceGrid__AdapterActiveException__Init __F__IceGrid__AdapterActiveException__i;

}

IceGrid::AdapterActiveException::~AdapterActiveException() throw()
{
}

::std::string
IceGrid::AdapterActiveException::ice_name() const
{
    return __IceGrid__AdapterActiveException_name;
}

IceGrid::AdapterActiveException*
IceGrid::AdapterActiveException::ice_clone() const
{
    return new AdapterActiveException(*this);
}

void
IceGrid::AdapterActiveException::ice_throw() const
{
    throw *this;
}

void
IceGrid::AdapterActiveException::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::IceGrid::AdapterActiveException", -1, true);
    __os->endWriteSlice();
}

void
IceGrid::AdapterActiveException::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

namespace
{

const char* __IceGrid__AdapterNotActiveException_name = "IceGrid::AdapterNotActiveException";

struct __F__IceGrid__AdapterNotActiveException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::IceGrid::AdapterNotActiveException();
    }
};

class __F__IceGrid__AdapterNotActiveException__Init
{
public:

    __F__IceGrid__AdapterNotActiveException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::IceGrid::AdapterNotActiveException", new __F__IceGrid__AdapterNotActiveException);
    }

    ~__F__IceGrid__AdapterNotActiveException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::IceGrid::AdapterNotActiveException");
    }
};

const __F__IceGrid__AdapterNotActiveException__Init __F__IceGrid__AdapterNotActiveException__i;

}

IceGrid::AdapterNotActiveException::AdapterNotActiveException(bool __ice_activatable) :
    ::Ice::UserException(),
    activatable(__ice_activatable)
{
}

IceGrid::AdapterNotActiveException::~AdapterNotActiveException() throw()
{
}

::std::string
IceGrid::AdapterNotActiveException::ice_name() const
{
    return __IceGrid__AdapterNotActiveException_name;
}

IceGrid::AdapterNotActiveException*
IceGrid::AdapterNotActiveException::ice_clone() const
{
    return new AdapterNotActiveException(*this);
}

void
IceGrid::AdapterNotActiveException::ice_throw() const
{
    throw *this;
}

void
IceGrid::AdapterNotActiveException::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::IceGrid::AdapterNotActiveException", -1, true);
    __os->write(activatable);
    __os->endWriteSlice();
}

void
IceGrid::AdapterNotActiveException::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(activatable);
    __is->endReadSlice();
}

namespace
{

const char* __IceGrid__AdapterExistsException_name = "IceGrid::AdapterExistsException";

struct __F__IceGrid__AdapterExistsException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::IceGrid::AdapterExistsException();
    }
};

class __F__IceGrid__AdapterExistsException__Init
{
public:

    __F__IceGrid__AdapterExistsException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::IceGrid::AdapterExistsException", new __F__IceGrid__AdapterExistsException);
    }

    ~__F__IceGrid__AdapterExistsException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::IceGrid::AdapterExistsException");
    }
};

const __F__IceGrid__AdapterExistsException__Init __F__IceGrid__AdapterExistsException__i;

}

IceGrid::AdapterExistsException::AdapterExistsException(const ::std::string& __ice_id) :
    ::Ice::UserException(),
    id(__ice_id)
{
}

IceGrid::AdapterExistsException::~AdapterExistsException() throw()
{
}

::std::string
IceGrid::AdapterExistsException::ice_name() const
{
    return __IceGrid__AdapterExistsException_name;
}

IceGrid::AdapterExistsException*
IceGrid::AdapterExistsException::ice_clone() const
{
    return new AdapterExistsException(*this);
}

void
IceGrid::AdapterExistsException::ice_throw() const
{
    throw *this;
}

void
IceGrid::AdapterExistsException::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::IceGrid::AdapterExistsException", -1, true);
    __os->write(id);
    __os->endWriteSlice();
}

void
IceGrid::AdapterExistsException::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(id);
    __is->endReadSlice();
}

namespace
{

const char* __IceGrid__NodeActiveException_name = "IceGrid::NodeActiveException";

struct __F__IceGrid__NodeActiveException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::IceGrid::NodeActiveException();
    }
};

class __F__IceGrid__NodeActiveException__Init
{
public:

    __F__IceGrid__NodeActiveException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::IceGrid::NodeActiveException", new __F__IceGrid__NodeActiveException);
    }

    ~__F__IceGrid__NodeActiveException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::IceGrid::NodeActiveException");
    }
};

const __F__IceGrid__NodeActiveException__Init __F__IceGrid__NodeActiveException__i;

}

IceGrid::NodeActiveException::~NodeActiveException() throw()
{
}

::std::string
IceGrid::NodeActiveException::ice_name() const
{
    return __IceGrid__NodeActiveException_name;
}

IceGrid::NodeActiveException*
IceGrid::NodeActiveException::ice_clone() const
{
    return new NodeActiveException(*this);
}

void
IceGrid::NodeActiveException::ice_throw() const
{
    throw *this;
}

void
IceGrid::NodeActiveException::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::IceGrid::NodeActiveException", -1, true);
    __os->endWriteSlice();
}

void
IceGrid::NodeActiveException::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

namespace
{

const char* __IceGrid__ReplicaActiveException_name = "IceGrid::ReplicaActiveException";

struct __F__IceGrid__ReplicaActiveException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::IceGrid::ReplicaActiveException();
    }
};

class __F__IceGrid__ReplicaActiveException__Init
{
public:

    __F__IceGrid__ReplicaActiveException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::IceGrid::ReplicaActiveException", new __F__IceGrid__ReplicaActiveException);
    }

    ~__F__IceGrid__ReplicaActiveException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::IceGrid::ReplicaActiveException");
    }
};

const __F__IceGrid__ReplicaActiveException__Init __F__IceGrid__ReplicaActiveException__i;

}

IceGrid::ReplicaActiveException::~ReplicaActiveException() throw()
{
}

::std::string
IceGrid::ReplicaActiveException::ice_name() const
{
    return __IceGrid__ReplicaActiveException_name;
}

IceGrid::ReplicaActiveException*
IceGrid::ReplicaActiveException::ice_clone() const
{
    return new ReplicaActiveException(*this);
}

void
IceGrid::ReplicaActiveException::ice_throw() const
{
    throw *this;
}

void
IceGrid::ReplicaActiveException::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::IceGrid::ReplicaActiveException", -1, true);
    __os->endWriteSlice();
}

void
IceGrid::ReplicaActiveException::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

namespace Ice
{
}

IceAsync::IceGrid::AMD_Adapter_activate::AMD_Adapter_activate(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::IceGrid::AMD_Adapter_activate::ice_response(const ::Ice::ObjectPrx& __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

IceAsync::IceGrid::AMD_Server_start::AMD_Server_start(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::IceGrid::AMD_Server_start::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::IceGrid::AMD_Server_start::ice_exception(const ::std::exception& ex)
{
    if(const ::IceGrid::ServerStartException* __ex = dynamic_cast<const ::IceGrid::ServerStartException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::IceGrid::AMD_Server_stop::AMD_Server_stop(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::IceGrid::AMD_Server_stop::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::IceGrid::AMD_Server_stop::ice_exception(const ::std::exception& ex)
{
    if(const ::IceGrid::ServerStopException* __ex = dynamic_cast<const ::IceGrid::ServerStopException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::IceGrid::AMD_Server_setProcess::AMD_Server_setProcess(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::IceGrid::AMD_Server_setProcess::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

IceAsync::IceGrid::AMD_Node_loadServer::AMD_Node_loadServer(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::IceGrid::AMD_Node_loadServer::ice_response(const ::IceGrid::ServerPrx& __ret, const ::IceGrid::AdapterPrxDict& adapters, ::Ice::Int actTimeout, ::Ice::Int deactTimeout)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(adapters);
            __os->write(actTimeout);
            __os->write(deactTimeout);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::IceGrid::AMD_Node_loadServer::ice_exception(const ::std::exception& ex)
{
    if(const ::IceGrid::DeploymentException* __ex = dynamic_cast<const ::IceGrid::DeploymentException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::IceGrid::AMD_Node_loadServerWithoutRestart::AMD_Node_loadServerWithoutRestart(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::IceGrid::AMD_Node_loadServerWithoutRestart::ice_response(const ::IceGrid::ServerPrx& __ret, const ::IceGrid::AdapterPrxDict& adapters, ::Ice::Int actTimeout, ::Ice::Int deactTimeout)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(adapters);
            __os->write(actTimeout);
            __os->write(deactTimeout);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::IceGrid::AMD_Node_loadServerWithoutRestart::ice_exception(const ::std::exception& ex)
{
    if(const ::IceGrid::DeploymentException* __ex = dynamic_cast<const ::IceGrid::DeploymentException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::IceGrid::AMD_Node_destroyServer::AMD_Node_destroyServer(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::IceGrid::AMD_Node_destroyServer::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

void
IceAsync::IceGrid::AMD_Node_destroyServer::ice_exception(const ::std::exception& ex)
{
    if(const ::IceGrid::DeploymentException* __ex = dynamic_cast<const ::IceGrid::DeploymentException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::IceGrid::AMD_Node_patch::AMD_Node_patch(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::IceGrid::AMD_Node_patch::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

IceAsync::IceGrid::AMD_NodeSession_loadServers::AMD_NodeSession_loadServers(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::IceGrid::AMD_NodeSession_loadServers::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}

IceAsync::IceGrid::AMD_NodeSession_waitForApplicationUpdate::AMD_NodeSession_waitForApplicationUpdate(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::IceGrid::AMD_NodeSession_waitForApplicationUpdate::ice_response()
{
    if(__validateResponse(true))
    {
        __writeEmptyParams();
        __response();
    }
}
::IceProxy::Ice::Object* ::IceProxy::IceGrid::upCast(::IceProxy::IceGrid::InternalDbEnvDescriptor* p) { return p; }

void
::IceProxy::IceGrid::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::InternalDbEnvDescriptor>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceGrid::InternalDbEnvDescriptor;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::IceGrid::InternalDbEnvDescriptor::ice_staticId()
{
    return ::IceGrid::InternalDbEnvDescriptor::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceGrid::InternalDbEnvDescriptor::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceGrid::InternalDbEnvDescriptor);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceGrid::InternalDbEnvDescriptor::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceGrid::InternalDbEnvDescriptor);
}

::IceProxy::Ice::Object*
IceProxy::IceGrid::InternalDbEnvDescriptor::__newInstance() const
{
    return new InternalDbEnvDescriptor;
}
::IceProxy::Ice::Object* ::IceProxy::IceGrid::upCast(::IceProxy::IceGrid::InternalAdapterDescriptor* p) { return p; }

void
::IceProxy::IceGrid::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::InternalAdapterDescriptor>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceGrid::InternalAdapterDescriptor;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::IceGrid::InternalAdapterDescriptor::ice_staticId()
{
    return ::IceGrid::InternalAdapterDescriptor::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceGrid::InternalAdapterDescriptor::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceGrid::InternalAdapterDescriptor);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceGrid::InternalAdapterDescriptor::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceGrid::InternalAdapterDescriptor);
}

::IceProxy::Ice::Object*
IceProxy::IceGrid::InternalAdapterDescriptor::__newInstance() const
{
    return new InternalAdapterDescriptor;
}
::IceProxy::Ice::Object* ::IceProxy::IceGrid::upCast(::IceProxy::IceGrid::InternalDistributionDescriptor* p) { return p; }

void
::IceProxy::IceGrid::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::InternalDistributionDescriptor>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceGrid::InternalDistributionDescriptor;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::IceGrid::InternalDistributionDescriptor::ice_staticId()
{
    return ::IceGrid::InternalDistributionDescriptor::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceGrid::InternalDistributionDescriptor::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceGrid::InternalDistributionDescriptor);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceGrid::InternalDistributionDescriptor::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceGrid::InternalDistributionDescriptor);
}

::IceProxy::Ice::Object*
IceProxy::IceGrid::InternalDistributionDescriptor::__newInstance() const
{
    return new InternalDistributionDescriptor;
}
::IceProxy::Ice::Object* ::IceProxy::IceGrid::upCast(::IceProxy::IceGrid::InternalServerDescriptor* p) { return p; }

void
::IceProxy::IceGrid::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::InternalServerDescriptor>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceGrid::InternalServerDescriptor;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::IceGrid::InternalServerDescriptor::ice_staticId()
{
    return ::IceGrid::InternalServerDescriptor::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceGrid::InternalServerDescriptor::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceGrid::InternalServerDescriptor);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceGrid::InternalServerDescriptor::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceGrid::InternalServerDescriptor);
}

::IceProxy::Ice::Object*
IceProxy::IceGrid::InternalServerDescriptor::__newInstance() const
{
    return new InternalServerDescriptor;
}
::IceProxy::Ice::Object* ::IceProxy::IceGrid::upCast(::IceProxy::IceGrid::Adapter* p) { return p; }

void
::IceProxy::IceGrid::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::Adapter>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceGrid::Adapter;
        v->__copyFrom(proxy);
    }
}

::Ice::ObjectPrx
IceProxy::IceGrid::Adapter::activate(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__Adapter__activate_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceGrid__Adapter__activate_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::Adapter* __del = dynamic_cast< ::IceDelegate::IceGrid::Adapter*>(__delBase.get());
            return __del->activate(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::Adapter::begin_activate(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceGrid__Adapter__activate_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__Adapter__activate_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__Adapter__activate_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::ObjectPrx
IceProxy::IceGrid::Adapter::end_activate(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceGrid__Adapter__activate_name);
    ::Ice::ObjectPrx __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::ObjectPrx
IceProxy::IceGrid::Adapter::getDirectProxy(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__Adapter__getDirectProxy_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceGrid__Adapter__getDirectProxy_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::Adapter* __del = dynamic_cast< ::IceDelegate::IceGrid::Adapter*>(__delBase.get());
            return __del->getDirectProxy(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::Adapter::begin_getDirectProxy(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceGrid__Adapter__getDirectProxy_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__Adapter__getDirectProxy_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__Adapter__getDirectProxy_name, ::Ice::Nonmutating, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::ObjectPrx
IceProxy::IceGrid::Adapter::end_getDirectProxy(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceGrid__Adapter__getDirectProxy_name);
    ::Ice::ObjectPrx __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::IceGrid::AdapterNotActiveException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::IceGrid::Adapter::setDirectProxy(const ::Ice::ObjectPrx& proxy, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__Adapter__setDirectProxy_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceGrid__Adapter__setDirectProxy_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::Adapter* __del = dynamic_cast< ::IceDelegate::IceGrid::Adapter*>(__delBase.get());
            __del->setDirectProxy(proxy, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::Adapter::begin_setDirectProxy(const ::Ice::ObjectPrx& proxy, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceGrid__Adapter__setDirectProxy_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__Adapter__setDirectProxy_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__Adapter__setDirectProxy_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(proxy);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::Adapter::end_setDirectProxy(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceGrid__Adapter__setDirectProxy_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::IceGrid::AdapterActiveException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::IceGrid::Adapter::ice_staticId()
{
    return ::IceGrid::Adapter::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceGrid::Adapter::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceGrid::Adapter);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceGrid::Adapter::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceGrid::Adapter);
}

::IceProxy::Ice::Object*
IceProxy::IceGrid::Adapter::__newInstance() const
{
    return new Adapter;
}
::IceProxy::Ice::Object* ::IceProxy::IceGrid::upCast(::IceProxy::IceGrid::FileReader* p) { return p; }

void
::IceProxy::IceGrid::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::FileReader>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceGrid::FileReader;
        v->__copyFrom(proxy);
    }
}

::Ice::Long
IceProxy::IceGrid::FileReader::getOffsetFromEnd(const ::std::string& filename, ::Ice::Int lines, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__FileReader__getOffsetFromEnd_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceGrid__FileReader__getOffsetFromEnd_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::FileReader* __del = dynamic_cast< ::IceDelegate::IceGrid::FileReader*>(__delBase.get());
            return __del->getOffsetFromEnd(filename, lines, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::FileReader::begin_getOffsetFromEnd(const ::std::string& filename, ::Ice::Int lines, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceGrid__FileReader__getOffsetFromEnd_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__FileReader__getOffsetFromEnd_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__FileReader__getOffsetFromEnd_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(filename);
        __os->write(lines);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Long
IceProxy::IceGrid::FileReader::end_getOffsetFromEnd(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceGrid__FileReader__getOffsetFromEnd_name);
    ::Ice::Long __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::IceGrid::FileNotAvailableException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::IceGrid::FileReader::read(const ::std::string& filename, ::Ice::Long pos, ::Ice::Int size, ::Ice::Long& newPos, ::Ice::StringSeq& lines, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__FileReader__read_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceGrid__FileReader__read_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::FileReader* __del = dynamic_cast< ::IceDelegate::IceGrid::FileReader*>(__delBase.get());
            return __del->read(filename, pos, size, newPos, lines, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::FileReader::begin_read(const ::std::string& filename, ::Ice::Long pos, ::Ice::Int size, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceGrid__FileReader__read_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__FileReader__read_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__FileReader__read_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(filename);
        __os->write(pos);
        __os->write(size);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::IceGrid::FileReader::end_read(::Ice::Long& newPos, ::Ice::StringSeq& lines, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceGrid__FileReader__read_name);
    bool __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::IceGrid::FileNotAvailableException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(newPos);
        __is->read(lines);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::IceGrid::FileReader::ice_staticId()
{
    return ::IceGrid::FileReader::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceGrid::FileReader::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceGrid::FileReader);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceGrid::FileReader::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceGrid::FileReader);
}

::IceProxy::Ice::Object*
IceProxy::IceGrid::FileReader::__newInstance() const
{
    return new FileReader;
}
::IceProxy::Ice::Object* ::IceProxy::IceGrid::upCast(::IceProxy::IceGrid::Server* p) { return p; }

void
::IceProxy::IceGrid::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::Server>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceGrid::Server;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::IceGrid::Server::start(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__Server__start_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceGrid__Server__start_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::Server* __del = dynamic_cast< ::IceDelegate::IceGrid::Server*>(__delBase.get());
            __del->start(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::Server::begin_start(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceGrid__Server__start_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__Server__start_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__Server__start_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::Server::end_start(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceGrid__Server__start_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::IceGrid::ServerStartException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::IceGrid::Server::stop(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__Server__stop_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceGrid__Server__stop_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::Server* __del = dynamic_cast< ::IceDelegate::IceGrid::Server*>(__delBase.get());
            __del->stop(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::Server::begin_stop(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceGrid__Server__stop_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__Server__stop_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__Server__stop_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::Server::end_stop(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceGrid__Server__stop_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::IceGrid::ServerStopException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::IceGrid::Server::checkUpdate(const ::IceGrid::InternalServerDescriptorPtr& svr, bool noRestart, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__Server__checkUpdate_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceGrid__Server__checkUpdate_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::Server* __del = dynamic_cast< ::IceDelegate::IceGrid::Server*>(__delBase.get());
            return __del->checkUpdate(svr, noRestart, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::Server::begin_checkUpdate(const ::IceGrid::InternalServerDescriptorPtr& svr, bool noRestart, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceGrid__Server__checkUpdate_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__Server__checkUpdate_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__Server__checkUpdate_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(svr);
        __os->write(noRestart);
        __os->writePendingObjects();
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::IceGrid::Server::end_checkUpdate(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceGrid__Server__checkUpdate_name);
    bool __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::IceGrid::DeploymentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::IceGrid::Server::checkUpdate_async(const ::IceGrid::AMI_Server_checkUpdatePtr& __cb, const ::IceGrid::InternalServerDescriptorPtr& svr, bool noRestart)
{
    ::IceGrid::Callback_Server_checkUpdatePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::IceGrid::newCallback_Server_checkUpdate(__cb, &::IceGrid::AMI_Server_checkUpdate::__response, &::IceGrid::AMI_Server_checkUpdate::__exception, &::IceGrid::AMI_Server_checkUpdate::__sent);
    }
    else
    {
         __del = ::IceGrid::newCallback_Server_checkUpdate(__cb, &::IceGrid::AMI_Server_checkUpdate::__response, &::IceGrid::AMI_Server_checkUpdate::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__IceGrid__Server__checkUpdate_name);
        __ar = begin_checkUpdate(svr, noRestart, 0, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __IceGrid__Server__checkUpdate_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

bool
IceProxy::IceGrid::Server::checkUpdate_async(const ::IceGrid::AMI_Server_checkUpdatePtr& __cb, const ::IceGrid::InternalServerDescriptorPtr& svr, bool noRestart, const ::Ice::Context& __ctx)
{
    ::IceGrid::Callback_Server_checkUpdatePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::IceGrid::newCallback_Server_checkUpdate(__cb, &::IceGrid::AMI_Server_checkUpdate::__response, &::IceGrid::AMI_Server_checkUpdate::__exception, &::IceGrid::AMI_Server_checkUpdate::__sent);
    }
    else
    {
         __del = ::IceGrid::newCallback_Server_checkUpdate(__cb, &::IceGrid::AMI_Server_checkUpdate::__response, &::IceGrid::AMI_Server_checkUpdate::__exception);
    }
    ::Ice::AsyncResultPtr __ar;
    try
    {
        __checkTwowayOnly(__IceGrid__Server__checkUpdate_name);
        __ar = begin_checkUpdate(svr, noRestart, &__ctx, __del);
    }
    catch(const ::Ice::TwowayOnlyException& ex)
    {
        __ar = new ::IceInternal::OutgoingAsync(this, __IceGrid__Server__checkUpdate_name, __del, 0);
        __ar->__exceptionAsync(ex);
    }
    return __ar->sentSynchronously();
}

void
IceProxy::IceGrid::Server::setEnabled(bool enable, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__Server__setEnabled_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::Server* __del = dynamic_cast< ::IceDelegate::IceGrid::Server*>(__delBase.get());
            __del->setEnabled(enable, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::Server::begin_setEnabled(bool enable, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__Server__setEnabled_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__Server__setEnabled_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(enable);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::Server::end_setEnabled(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__Server__setEnabled_name);
}

bool
IceProxy::IceGrid::Server::isEnabled(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__Server__isEnabled_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceGrid__Server__isEnabled_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::Server* __del = dynamic_cast< ::IceDelegate::IceGrid::Server*>(__delBase.get());
            return __del->isEnabled(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::Server::begin_isEnabled(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceGrid__Server__isEnabled_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__Server__isEnabled_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__Server__isEnabled_name, ::Ice::Nonmutating, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::IceGrid::Server::end_isEnabled(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceGrid__Server__isEnabled_name);
    bool __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::IceGrid::Server::sendSignal(const ::std::string& signal, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__Server__sendSignal_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceGrid__Server__sendSignal_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::Server* __del = dynamic_cast< ::IceDelegate::IceGrid::Server*>(__delBase.get());
            __del->sendSignal(signal, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::Server::begin_sendSignal(const ::std::string& signal, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceGrid__Server__sendSignal_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__Server__sendSignal_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__Server__sendSignal_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(signal);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::Server::end_sendSignal(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceGrid__Server__sendSignal_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::IceGrid::BadSignalException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::IceGrid::Server::writeMessage(const ::std::string& message, ::Ice::Int fd, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__Server__writeMessage_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::Server* __del = dynamic_cast< ::IceDelegate::IceGrid::Server*>(__delBase.get());
            __del->writeMessage(message, fd, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::Server::begin_writeMessage(const ::std::string& message, ::Ice::Int fd, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__Server__writeMessage_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__Server__writeMessage_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(message);
        __os->write(fd);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::Server::end_writeMessage(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__Server__writeMessage_name);
}

::IceGrid::ServerState
IceProxy::IceGrid::Server::getState(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__Server__getState_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceGrid__Server__getState_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::Server* __del = dynamic_cast< ::IceDelegate::IceGrid::Server*>(__delBase.get());
            return __del->getState(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::Server::begin_getState(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceGrid__Server__getState_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__Server__getState_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__Server__getState_name, ::Ice::Nonmutating, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::IceGrid::ServerState
IceProxy::IceGrid::Server::end_getState(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceGrid__Server__getState_name);
    ::IceGrid::ServerState __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::IceGrid::Server::getPid(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__Server__getPid_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceGrid__Server__getPid_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::Server* __del = dynamic_cast< ::IceDelegate::IceGrid::Server*>(__delBase.get());
            return __del->getPid(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::Server::begin_getPid(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceGrid__Server__getPid_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__Server__getPid_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__Server__getPid_name, ::Ice::Nonmutating, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::IceGrid::Server::end_getPid(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceGrid__Server__getPid_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::IceGrid::Server::setProcess(const ::Ice::ProcessPrx& proc, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__Server__setProcess_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::Server* __del = dynamic_cast< ::IceDelegate::IceGrid::Server*>(__delBase.get());
            __del->setProcess(proc, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::Server::begin_setProcess(const ::Ice::ProcessPrx& proc, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__Server__setProcess_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__Server__setProcess_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(proc);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::Server::end_setProcess(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__Server__setProcess_name);
}

const ::std::string&
IceProxy::IceGrid::Server::ice_staticId()
{
    return ::IceGrid::Server::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceGrid::Server::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceGrid::Server);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceGrid::Server::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceGrid::Server);
}

::IceProxy::Ice::Object*
IceProxy::IceGrid::Server::__newInstance() const
{
    return new Server;
}
::IceProxy::Ice::Object* ::IceProxy::IceGrid::upCast(::IceProxy::IceGrid::ReplicaObserver* p) { return p; }

void
::IceProxy::IceGrid::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::ReplicaObserver>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceGrid::ReplicaObserver;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::IceGrid::ReplicaObserver::replicaInit(const ::IceGrid::InternalRegistryPrxSeq& replicas, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__ReplicaObserver__replicaInit_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::ReplicaObserver* __del = dynamic_cast< ::IceDelegate::IceGrid::ReplicaObserver*>(__delBase.get());
            __del->replicaInit(replicas, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::ReplicaObserver::begin_replicaInit(const ::IceGrid::InternalRegistryPrxSeq& replicas, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__ReplicaObserver__replicaInit_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__ReplicaObserver__replicaInit_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(replicas);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::ReplicaObserver::end_replicaInit(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__ReplicaObserver__replicaInit_name);
}

void
IceProxy::IceGrid::ReplicaObserver::replicaAdded(const ::IceGrid::InternalRegistryPrx& replica, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__ReplicaObserver__replicaAdded_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::ReplicaObserver* __del = dynamic_cast< ::IceDelegate::IceGrid::ReplicaObserver*>(__delBase.get());
            __del->replicaAdded(replica, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::ReplicaObserver::begin_replicaAdded(const ::IceGrid::InternalRegistryPrx& replica, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__ReplicaObserver__replicaAdded_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__ReplicaObserver__replicaAdded_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(replica);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::ReplicaObserver::end_replicaAdded(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__ReplicaObserver__replicaAdded_name);
}

void
IceProxy::IceGrid::ReplicaObserver::replicaRemoved(const ::IceGrid::InternalRegistryPrx& replica, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__ReplicaObserver__replicaRemoved_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::ReplicaObserver* __del = dynamic_cast< ::IceDelegate::IceGrid::ReplicaObserver*>(__delBase.get());
            __del->replicaRemoved(replica, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::ReplicaObserver::begin_replicaRemoved(const ::IceGrid::InternalRegistryPrx& replica, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__ReplicaObserver__replicaRemoved_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__ReplicaObserver__replicaRemoved_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(replica);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::ReplicaObserver::end_replicaRemoved(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__ReplicaObserver__replicaRemoved_name);
}

const ::std::string&
IceProxy::IceGrid::ReplicaObserver::ice_staticId()
{
    return ::IceGrid::ReplicaObserver::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceGrid::ReplicaObserver::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceGrid::ReplicaObserver);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceGrid::ReplicaObserver::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceGrid::ReplicaObserver);
}

::IceProxy::Ice::Object*
IceProxy::IceGrid::ReplicaObserver::__newInstance() const
{
    return new ReplicaObserver;
}
::IceProxy::Ice::Object* ::IceProxy::IceGrid::upCast(::IceProxy::IceGrid::PatcherFeedback* p) { return p; }

void
::IceProxy::IceGrid::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::PatcherFeedback>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceGrid::PatcherFeedback;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::IceGrid::PatcherFeedback::finished(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__PatcherFeedback__finished_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::PatcherFeedback* __del = dynamic_cast< ::IceDelegate::IceGrid::PatcherFeedback*>(__delBase.get());
            __del->finished(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::PatcherFeedback::begin_finished(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__PatcherFeedback__finished_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__PatcherFeedback__finished_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::PatcherFeedback::end_finished(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__PatcherFeedback__finished_name);
}

void
IceProxy::IceGrid::PatcherFeedback::failed(const ::std::string& reason, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__PatcherFeedback__failed_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::PatcherFeedback* __del = dynamic_cast< ::IceDelegate::IceGrid::PatcherFeedback*>(__delBase.get());
            __del->failed(reason, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::PatcherFeedback::begin_failed(const ::std::string& reason, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__PatcherFeedback__failed_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__PatcherFeedback__failed_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(reason);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::PatcherFeedback::end_failed(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__PatcherFeedback__failed_name);
}

const ::std::string&
IceProxy::IceGrid::PatcherFeedback::ice_staticId()
{
    return ::IceGrid::PatcherFeedback::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceGrid::PatcherFeedback::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceGrid::PatcherFeedback);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceGrid::PatcherFeedback::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceGrid::PatcherFeedback);
}

::IceProxy::Ice::Object*
IceProxy::IceGrid::PatcherFeedback::__newInstance() const
{
    return new PatcherFeedback;
}
::IceProxy::Ice::Object* ::IceProxy::IceGrid::upCast(::IceProxy::IceGrid::Node* p) { return p; }

void
::IceProxy::IceGrid::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::Node>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceGrid::Node;
        v->__copyFrom(proxy);
    }
}

::IceGrid::ServerPrx
IceProxy::IceGrid::Node::loadServer(const ::IceGrid::InternalServerDescriptorPtr& svr, const ::std::string& replicaName, ::IceGrid::AdapterPrxDict& adapters, ::Ice::Int& actTimeout, ::Ice::Int& deactTimeout, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__Node__loadServer_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceGrid__Node__loadServer_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::Node* __del = dynamic_cast< ::IceDelegate::IceGrid::Node*>(__delBase.get());
            return __del->loadServer(svr, replicaName, adapters, actTimeout, deactTimeout, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::Node::begin_loadServer(const ::IceGrid::InternalServerDescriptorPtr& svr, const ::std::string& replicaName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceGrid__Node__loadServer_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__Node__loadServer_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__Node__loadServer_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(svr);
        __os->write(replicaName);
        __os->writePendingObjects();
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::IceGrid::ServerPrx
IceProxy::IceGrid::Node::end_loadServer(::IceGrid::AdapterPrxDict& adapters, ::Ice::Int& actTimeout, ::Ice::Int& deactTimeout, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceGrid__Node__loadServer_name);
    ::IceGrid::ServerPrx __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::IceGrid::DeploymentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(adapters);
        __is->read(actTimeout);
        __is->read(deactTimeout);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::IceGrid::ServerPrx
IceProxy::IceGrid::Node::loadServerWithoutRestart(const ::IceGrid::InternalServerDescriptorPtr& svr, const ::std::string& replicaName, ::IceGrid::AdapterPrxDict& adapters, ::Ice::Int& actTimeout, ::Ice::Int& deactTimeout, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__Node__loadServerWithoutRestart_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceGrid__Node__loadServerWithoutRestart_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::Node* __del = dynamic_cast< ::IceDelegate::IceGrid::Node*>(__delBase.get());
            return __del->loadServerWithoutRestart(svr, replicaName, adapters, actTimeout, deactTimeout, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::Node::begin_loadServerWithoutRestart(const ::IceGrid::InternalServerDescriptorPtr& svr, const ::std::string& replicaName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceGrid__Node__loadServerWithoutRestart_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__Node__loadServerWithoutRestart_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__Node__loadServerWithoutRestart_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(svr);
        __os->write(replicaName);
        __os->writePendingObjects();
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::IceGrid::ServerPrx
IceProxy::IceGrid::Node::end_loadServerWithoutRestart(::IceGrid::AdapterPrxDict& adapters, ::Ice::Int& actTimeout, ::Ice::Int& deactTimeout, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceGrid__Node__loadServerWithoutRestart_name);
    ::IceGrid::ServerPrx __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::IceGrid::DeploymentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(adapters);
        __is->read(actTimeout);
        __is->read(deactTimeout);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::IceGrid::Node::destroyServer(const ::std::string& name, const ::std::string& uuid, ::Ice::Int revision, const ::std::string& replicaName, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__Node__destroyServer_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceGrid__Node__destroyServer_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::Node* __del = dynamic_cast< ::IceDelegate::IceGrid::Node*>(__delBase.get());
            __del->destroyServer(name, uuid, revision, replicaName, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::Node::begin_destroyServer(const ::std::string& name, const ::std::string& uuid, ::Ice::Int revision, const ::std::string& replicaName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceGrid__Node__destroyServer_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__Node__destroyServer_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__Node__destroyServer_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(name);
        __os->write(uuid);
        __os->write(revision);
        __os->write(replicaName);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::Node::end_destroyServer(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceGrid__Node__destroyServer_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::IceGrid::DeploymentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::IceGrid::Node::patch(const ::IceGrid::PatcherFeedbackPrx& feedback, const ::std::string& application, const ::std::string& server, const ::IceGrid::InternalDistributionDescriptorPtr& appDistrib, bool shutdown, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__Node__patch_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::Node* __del = dynamic_cast< ::IceDelegate::IceGrid::Node*>(__delBase.get());
            __del->patch(feedback, application, server, appDistrib, shutdown, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::Node::begin_patch(const ::IceGrid::PatcherFeedbackPrx& feedback, const ::std::string& application, const ::std::string& server, const ::IceGrid::InternalDistributionDescriptorPtr& appDistrib, bool shutdown, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__Node__patch_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__Node__patch_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(feedback);
        __os->write(application);
        __os->write(server);
        __os->write(appDistrib);
        __os->write(shutdown);
        __os->writePendingObjects();
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::Node::end_patch(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__Node__patch_name);
}

void
IceProxy::IceGrid::Node::registerWithReplica(const ::IceGrid::InternalRegistryPrx& replica, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__Node__registerWithReplica_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::Node* __del = dynamic_cast< ::IceDelegate::IceGrid::Node*>(__delBase.get());
            __del->registerWithReplica(replica, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::Node::begin_registerWithReplica(const ::IceGrid::InternalRegistryPrx& replica, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__Node__registerWithReplica_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__Node__registerWithReplica_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(replica);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::Node::end_registerWithReplica(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__Node__registerWithReplica_name);
}

::std::string
IceProxy::IceGrid::Node::getName(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__Node__getName_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceGrid__Node__getName_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::Node* __del = dynamic_cast< ::IceDelegate::IceGrid::Node*>(__delBase.get());
            return __del->getName(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::Node::begin_getName(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceGrid__Node__getName_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__Node__getName_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__Node__getName_name, ::Ice::Nonmutating, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::std::string
IceProxy::IceGrid::Node::end_getName(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceGrid__Node__getName_name);
    ::std::string __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::std::string
IceProxy::IceGrid::Node::getHostname(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__Node__getHostname_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceGrid__Node__getHostname_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::Node* __del = dynamic_cast< ::IceDelegate::IceGrid::Node*>(__delBase.get());
            return __del->getHostname(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::Node::begin_getHostname(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceGrid__Node__getHostname_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__Node__getHostname_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__Node__getHostname_name, ::Ice::Nonmutating, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::std::string
IceProxy::IceGrid::Node::end_getHostname(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceGrid__Node__getHostname_name);
    ::std::string __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::IceGrid::LoadInfo
IceProxy::IceGrid::Node::getLoad(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__Node__getLoad_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceGrid__Node__getLoad_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::Node* __del = dynamic_cast< ::IceDelegate::IceGrid::Node*>(__delBase.get());
            return __del->getLoad(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::Node::begin_getLoad(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceGrid__Node__getLoad_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__Node__getLoad_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__Node__getLoad_name, ::Ice::Nonmutating, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::IceGrid::LoadInfo
IceProxy::IceGrid::Node::end_getLoad(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceGrid__Node__getLoad_name);
    ::IceGrid::LoadInfo __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::IceGrid::Node::getProcessorSocketCount(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__Node__getProcessorSocketCount_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceGrid__Node__getProcessorSocketCount_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::Node* __del = dynamic_cast< ::IceDelegate::IceGrid::Node*>(__delBase.get());
            return __del->getProcessorSocketCount(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::Node::begin_getProcessorSocketCount(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceGrid__Node__getProcessorSocketCount_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__Node__getProcessorSocketCount_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__Node__getProcessorSocketCount_name, ::Ice::Nonmutating, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::IceGrid::Node::end_getProcessorSocketCount(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceGrid__Node__getProcessorSocketCount_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::IceGrid::Node::shutdown(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__Node__shutdown_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::Node* __del = dynamic_cast< ::IceDelegate::IceGrid::Node*>(__delBase.get());
            __del->shutdown(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::Node::begin_shutdown(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__Node__shutdown_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__Node__shutdown_name, ::Ice::Nonmutating, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::Node::end_shutdown(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__Node__shutdown_name);
}

const ::std::string&
IceProxy::IceGrid::Node::ice_staticId()
{
    return ::IceGrid::Node::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceGrid::Node::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceGrid::Node);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceGrid::Node::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceGrid::Node);
}

::IceProxy::Ice::Object*
IceProxy::IceGrid::Node::__newInstance() const
{
    return new Node;
}
::IceProxy::Ice::Object* ::IceProxy::IceGrid::upCast(::IceProxy::IceGrid::NodeSession* p) { return p; }

void
::IceProxy::IceGrid::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::NodeSession>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceGrid::NodeSession;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::IceGrid::NodeSession::keepAlive(const ::IceGrid::LoadInfo& load, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__NodeSession__keepAlive_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::NodeSession* __del = dynamic_cast< ::IceDelegate::IceGrid::NodeSession*>(__delBase.get());
            __del->keepAlive(load, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::NodeSession::begin_keepAlive(const ::IceGrid::LoadInfo& load, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__NodeSession__keepAlive_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__NodeSession__keepAlive_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(load);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::NodeSession::end_keepAlive(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__NodeSession__keepAlive_name);
}

void
IceProxy::IceGrid::NodeSession::setReplicaObserver(const ::IceGrid::ReplicaObserverPrx& observer, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__NodeSession__setReplicaObserver_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::NodeSession* __del = dynamic_cast< ::IceDelegate::IceGrid::NodeSession*>(__delBase.get());
            __del->setReplicaObserver(observer, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::NodeSession::begin_setReplicaObserver(const ::IceGrid::ReplicaObserverPrx& observer, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__NodeSession__setReplicaObserver_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__NodeSession__setReplicaObserver_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(observer);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::NodeSession::end_setReplicaObserver(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__NodeSession__setReplicaObserver_name);
}

::Ice::Int
IceProxy::IceGrid::NodeSession::getTimeout(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__NodeSession__getTimeout_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceGrid__NodeSession__getTimeout_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::NodeSession* __del = dynamic_cast< ::IceDelegate::IceGrid::NodeSession*>(__delBase.get());
            return __del->getTimeout(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::NodeSession::begin_getTimeout(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceGrid__NodeSession__getTimeout_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__NodeSession__getTimeout_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__NodeSession__getTimeout_name, ::Ice::Nonmutating, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::IceGrid::NodeSession::end_getTimeout(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceGrid__NodeSession__getTimeout_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::IceGrid::NodeObserverPrx
IceProxy::IceGrid::NodeSession::getObserver(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__NodeSession__getObserver_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceGrid__NodeSession__getObserver_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::NodeSession* __del = dynamic_cast< ::IceDelegate::IceGrid::NodeSession*>(__delBase.get());
            return __del->getObserver(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::NodeSession::begin_getObserver(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceGrid__NodeSession__getObserver_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__NodeSession__getObserver_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__NodeSession__getObserver_name, ::Ice::Nonmutating, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::IceGrid::NodeObserverPrx
IceProxy::IceGrid::NodeSession::end_getObserver(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceGrid__NodeSession__getObserver_name);
    ::IceGrid::NodeObserverPrx __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::IceGrid::NodeSession::loadServers(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__NodeSession__loadServers_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::NodeSession* __del = dynamic_cast< ::IceDelegate::IceGrid::NodeSession*>(__delBase.get());
            __del->loadServers(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::NodeSession::begin_loadServers(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__NodeSession__loadServers_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__NodeSession__loadServers_name, ::Ice::Nonmutating, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::NodeSession::end_loadServers(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__NodeSession__loadServers_name);
}

::Ice::StringSeq
IceProxy::IceGrid::NodeSession::getServers(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__NodeSession__getServers_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceGrid__NodeSession__getServers_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::NodeSession* __del = dynamic_cast< ::IceDelegate::IceGrid::NodeSession*>(__delBase.get());
            return __del->getServers(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::NodeSession::begin_getServers(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceGrid__NodeSession__getServers_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__NodeSession__getServers_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__NodeSession__getServers_name, ::Ice::Nonmutating, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::StringSeq
IceProxy::IceGrid::NodeSession::end_getServers(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceGrid__NodeSession__getServers_name);
    ::Ice::StringSeq __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::IceGrid::NodeSession::waitForApplicationUpdate(const ::std::string& application, ::Ice::Int revision, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__NodeSession__waitForApplicationUpdate_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::NodeSession* __del = dynamic_cast< ::IceDelegate::IceGrid::NodeSession*>(__delBase.get());
            __del->waitForApplicationUpdate(application, revision, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::NodeSession::begin_waitForApplicationUpdate(const ::std::string& application, ::Ice::Int revision, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__NodeSession__waitForApplicationUpdate_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__NodeSession__waitForApplicationUpdate_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(application);
        __os->write(revision);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::NodeSession::end_waitForApplicationUpdate(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__NodeSession__waitForApplicationUpdate_name);
}

void
IceProxy::IceGrid::NodeSession::destroy(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__NodeSession__destroy_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::NodeSession* __del = dynamic_cast< ::IceDelegate::IceGrid::NodeSession*>(__delBase.get());
            __del->destroy(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::NodeSession::begin_destroy(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__NodeSession__destroy_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__NodeSession__destroy_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::NodeSession::end_destroy(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__NodeSession__destroy_name);
}

const ::std::string&
IceProxy::IceGrid::NodeSession::ice_staticId()
{
    return ::IceGrid::NodeSession::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceGrid::NodeSession::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceGrid::NodeSession);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceGrid::NodeSession::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceGrid::NodeSession);
}

::IceProxy::Ice::Object*
IceProxy::IceGrid::NodeSession::__newInstance() const
{
    return new NodeSession;
}
::IceProxy::Ice::Object* ::IceProxy::IceGrid::upCast(::IceProxy::IceGrid::DatabaseObserver* p) { return p; }

void
::IceProxy::IceGrid::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::DatabaseObserver>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceGrid::DatabaseObserver;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::IceGrid::DatabaseObserver::ice_staticId()
{
    return ::IceGrid::DatabaseObserver::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceGrid::DatabaseObserver::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceGrid::DatabaseObserver);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceGrid::DatabaseObserver::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceGrid::DatabaseObserver);
}

::IceProxy::Ice::Object*
IceProxy::IceGrid::DatabaseObserver::__newInstance() const
{
    return new DatabaseObserver;
}
::IceProxy::Ice::Object* ::IceProxy::IceGrid::upCast(::IceProxy::IceGrid::ReplicaSession* p) { return p; }

void
::IceProxy::IceGrid::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::ReplicaSession>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceGrid::ReplicaSession;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::IceGrid::ReplicaSession::keepAlive(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__ReplicaSession__keepAlive_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::ReplicaSession* __del = dynamic_cast< ::IceDelegate::IceGrid::ReplicaSession*>(__delBase.get());
            __del->keepAlive(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::ReplicaSession::begin_keepAlive(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__ReplicaSession__keepAlive_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__ReplicaSession__keepAlive_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::ReplicaSession::end_keepAlive(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__ReplicaSession__keepAlive_name);
}

::Ice::Int
IceProxy::IceGrid::ReplicaSession::getTimeout(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__ReplicaSession__getTimeout_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceGrid__ReplicaSession__getTimeout_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::ReplicaSession* __del = dynamic_cast< ::IceDelegate::IceGrid::ReplicaSession*>(__delBase.get());
            return __del->getTimeout(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::ReplicaSession::begin_getTimeout(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceGrid__ReplicaSession__getTimeout_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__ReplicaSession__getTimeout_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__ReplicaSession__getTimeout_name, ::Ice::Idempotent, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::IceGrid::ReplicaSession::end_getTimeout(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceGrid__ReplicaSession__getTimeout_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::IceGrid::ReplicaSession::setDatabaseObserver(const ::IceGrid::DatabaseObserverPrx& dbObs, const IceUtil::Optional< ::IceGrid::StringLongDict>& serials, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__ReplicaSession__setDatabaseObserver_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceGrid__ReplicaSession__setDatabaseObserver_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::ReplicaSession* __del = dynamic_cast< ::IceDelegate::IceGrid::ReplicaSession*>(__delBase.get());
            __del->setDatabaseObserver(dbObs, serials, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::ReplicaSession::begin_setDatabaseObserver(const ::IceGrid::DatabaseObserverPrx& dbObs, const IceUtil::Optional< ::IceGrid::StringLongDict>& serials, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceGrid__ReplicaSession__setDatabaseObserver_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__ReplicaSession__setDatabaseObserver_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__ReplicaSession__setDatabaseObserver_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(dbObs);
        __os->write(1, serials);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::ReplicaSession::end_setDatabaseObserver(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceGrid__ReplicaSession__setDatabaseObserver_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::IceGrid::DeploymentException&)
            {
                throw;
            }
            catch(const ::IceGrid::ObserverAlreadyRegisteredException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::IceGrid::ReplicaSession::setEndpoints(const ::IceGrid::StringObjectProxyDict& endpoints, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__ReplicaSession__setEndpoints_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::ReplicaSession* __del = dynamic_cast< ::IceDelegate::IceGrid::ReplicaSession*>(__delBase.get());
            __del->setEndpoints(endpoints, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::ReplicaSession::begin_setEndpoints(const ::IceGrid::StringObjectProxyDict& endpoints, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__ReplicaSession__setEndpoints_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__ReplicaSession__setEndpoints_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(endpoints);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::ReplicaSession::end_setEndpoints(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__ReplicaSession__setEndpoints_name);
}

void
IceProxy::IceGrid::ReplicaSession::registerWellKnownObjects(const ::IceGrid::ObjectInfoSeq& objects, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__ReplicaSession__registerWellKnownObjects_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::ReplicaSession* __del = dynamic_cast< ::IceDelegate::IceGrid::ReplicaSession*>(__delBase.get());
            __del->registerWellKnownObjects(objects, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::ReplicaSession::begin_registerWellKnownObjects(const ::IceGrid::ObjectInfoSeq& objects, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__ReplicaSession__registerWellKnownObjects_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__ReplicaSession__registerWellKnownObjects_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(objects);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::ReplicaSession::end_registerWellKnownObjects(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__ReplicaSession__registerWellKnownObjects_name);
}

void
IceProxy::IceGrid::ReplicaSession::setAdapterDirectProxy(const ::std::string& adapterId, const ::std::string& replicaGroupId, const ::Ice::ObjectPrx& proxy, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__ReplicaSession__setAdapterDirectProxy_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceGrid__ReplicaSession__setAdapterDirectProxy_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::ReplicaSession* __del = dynamic_cast< ::IceDelegate::IceGrid::ReplicaSession*>(__delBase.get());
            __del->setAdapterDirectProxy(adapterId, replicaGroupId, proxy, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::ReplicaSession::begin_setAdapterDirectProxy(const ::std::string& adapterId, const ::std::string& replicaGroupId, const ::Ice::ObjectPrx& proxy, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceGrid__ReplicaSession__setAdapterDirectProxy_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__ReplicaSession__setAdapterDirectProxy_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__ReplicaSession__setAdapterDirectProxy_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(adapterId);
        __os->write(replicaGroupId);
        __os->write(proxy);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::ReplicaSession::end_setAdapterDirectProxy(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceGrid__ReplicaSession__setAdapterDirectProxy_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::IceGrid::AdapterExistsException&)
            {
                throw;
            }
            catch(const ::IceGrid::AdapterNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::IceGrid::ReplicaSession::receivedUpdate(::IceGrid::TopicName name, ::Ice::Int serial, const ::std::string& failure, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__ReplicaSession__receivedUpdate_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::ReplicaSession* __del = dynamic_cast< ::IceDelegate::IceGrid::ReplicaSession*>(__delBase.get());
            __del->receivedUpdate(name, serial, failure, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::ReplicaSession::begin_receivedUpdate(::IceGrid::TopicName name, ::Ice::Int serial, const ::std::string& failure, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__ReplicaSession__receivedUpdate_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__ReplicaSession__receivedUpdate_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(name);
        __os->write(serial);
        __os->write(failure);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::ReplicaSession::end_receivedUpdate(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__ReplicaSession__receivedUpdate_name);
}

void
IceProxy::IceGrid::ReplicaSession::destroy(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__ReplicaSession__destroy_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::ReplicaSession* __del = dynamic_cast< ::IceDelegate::IceGrid::ReplicaSession*>(__delBase.get());
            __del->destroy(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::ReplicaSession::begin_destroy(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__ReplicaSession__destroy_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__ReplicaSession__destroy_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::ReplicaSession::end_destroy(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__ReplicaSession__destroy_name);
}

const ::std::string&
IceProxy::IceGrid::ReplicaSession::ice_staticId()
{
    return ::IceGrid::ReplicaSession::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceGrid::ReplicaSession::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceGrid::ReplicaSession);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceGrid::ReplicaSession::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceGrid::ReplicaSession);
}

::IceProxy::Ice::Object*
IceProxy::IceGrid::ReplicaSession::__newInstance() const
{
    return new ReplicaSession;
}
::IceProxy::Ice::Object* ::IceProxy::IceGrid::upCast(::IceProxy::IceGrid::InternalNodeInfo* p) { return p; }

void
::IceProxy::IceGrid::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::InternalNodeInfo>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceGrid::InternalNodeInfo;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::IceGrid::InternalNodeInfo::ice_staticId()
{
    return ::IceGrid::InternalNodeInfo::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceGrid::InternalNodeInfo::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceGrid::InternalNodeInfo);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceGrid::InternalNodeInfo::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceGrid::InternalNodeInfo);
}

::IceProxy::Ice::Object*
IceProxy::IceGrid::InternalNodeInfo::__newInstance() const
{
    return new InternalNodeInfo;
}
::IceProxy::Ice::Object* ::IceProxy::IceGrid::upCast(::IceProxy::IceGrid::InternalReplicaInfo* p) { return p; }

void
::IceProxy::IceGrid::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::InternalReplicaInfo>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceGrid::InternalReplicaInfo;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::IceGrid::InternalReplicaInfo::ice_staticId()
{
    return ::IceGrid::InternalReplicaInfo::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceGrid::InternalReplicaInfo::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceGrid::InternalReplicaInfo);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceGrid::InternalReplicaInfo::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceGrid::InternalReplicaInfo);
}

::IceProxy::Ice::Object*
IceProxy::IceGrid::InternalReplicaInfo::__newInstance() const
{
    return new InternalReplicaInfo;
}
::IceProxy::Ice::Object* ::IceProxy::IceGrid::upCast(::IceProxy::IceGrid::InternalRegistry* p) { return p; }

void
::IceProxy::IceGrid::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::InternalRegistry>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceGrid::InternalRegistry;
        v->__copyFrom(proxy);
    }
}

::IceGrid::NodeSessionPrx
IceProxy::IceGrid::InternalRegistry::registerNode(const ::IceGrid::InternalNodeInfoPtr& info, const ::IceGrid::NodePrx& prx, const ::IceGrid::LoadInfo& loadInf, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__InternalRegistry__registerNode_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceGrid__InternalRegistry__registerNode_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::InternalRegistry* __del = dynamic_cast< ::IceDelegate::IceGrid::InternalRegistry*>(__delBase.get());
            return __del->registerNode(info, prx, loadInf, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::InternalRegistry::begin_registerNode(const ::IceGrid::InternalNodeInfoPtr& info, const ::IceGrid::NodePrx& prx, const ::IceGrid::LoadInfo& loadInf, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceGrid__InternalRegistry__registerNode_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__InternalRegistry__registerNode_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__InternalRegistry__registerNode_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(info);
        __os->write(prx);
        __os->write(loadInf);
        __os->writePendingObjects();
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::IceGrid::NodeSessionPrx
IceProxy::IceGrid::InternalRegistry::end_registerNode(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceGrid__InternalRegistry__registerNode_name);
    ::IceGrid::NodeSessionPrx __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::IceGrid::NodeActiveException&)
            {
                throw;
            }
            catch(const ::IceGrid::PermissionDeniedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::IceGrid::ReplicaSessionPrx
IceProxy::IceGrid::InternalRegistry::registerReplica(const ::IceGrid::InternalReplicaInfoPtr& info, const ::IceGrid::InternalRegistryPrx& prx, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__InternalRegistry__registerReplica_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceGrid__InternalRegistry__registerReplica_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::InternalRegistry* __del = dynamic_cast< ::IceDelegate::IceGrid::InternalRegistry*>(__delBase.get());
            return __del->registerReplica(info, prx, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::InternalRegistry::begin_registerReplica(const ::IceGrid::InternalReplicaInfoPtr& info, const ::IceGrid::InternalRegistryPrx& prx, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceGrid__InternalRegistry__registerReplica_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__InternalRegistry__registerReplica_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__InternalRegistry__registerReplica_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(info);
        __os->write(prx);
        __os->writePendingObjects();
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::IceGrid::ReplicaSessionPrx
IceProxy::IceGrid::InternalRegistry::end_registerReplica(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceGrid__InternalRegistry__registerReplica_name);
    ::IceGrid::ReplicaSessionPrx __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::IceGrid::PermissionDeniedException&)
            {
                throw;
            }
            catch(const ::IceGrid::ReplicaActiveException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::IceGrid::InternalRegistry::registerWithReplica(const ::IceGrid::InternalRegistryPrx& prx, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__InternalRegistry__registerWithReplica_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::InternalRegistry* __del = dynamic_cast< ::IceDelegate::IceGrid::InternalRegistry*>(__delBase.get());
            __del->registerWithReplica(prx, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::InternalRegistry::begin_registerWithReplica(const ::IceGrid::InternalRegistryPrx& prx, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__InternalRegistry__registerWithReplica_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__InternalRegistry__registerWithReplica_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(prx);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::InternalRegistry::end_registerWithReplica(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__InternalRegistry__registerWithReplica_name);
}

::IceGrid::NodePrxSeq
IceProxy::IceGrid::InternalRegistry::getNodes(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__InternalRegistry__getNodes_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceGrid__InternalRegistry__getNodes_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::InternalRegistry* __del = dynamic_cast< ::IceDelegate::IceGrid::InternalRegistry*>(__delBase.get());
            return __del->getNodes(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::InternalRegistry::begin_getNodes(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceGrid__InternalRegistry__getNodes_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__InternalRegistry__getNodes_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__InternalRegistry__getNodes_name, ::Ice::Idempotent, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::IceGrid::NodePrxSeq
IceProxy::IceGrid::InternalRegistry::end_getNodes(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceGrid__InternalRegistry__getNodes_name);
    ::IceGrid::NodePrxSeq __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::IceGrid::InternalRegistryPrxSeq
IceProxy::IceGrid::InternalRegistry::getReplicas(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__InternalRegistry__getReplicas_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceGrid__InternalRegistry__getReplicas_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::InternalRegistry* __del = dynamic_cast< ::IceDelegate::IceGrid::InternalRegistry*>(__delBase.get());
            return __del->getReplicas(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::InternalRegistry::begin_getReplicas(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceGrid__InternalRegistry__getReplicas_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__InternalRegistry__getReplicas_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__InternalRegistry__getReplicas_name, ::Ice::Idempotent, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::IceGrid::InternalRegistryPrxSeq
IceProxy::IceGrid::InternalRegistry::end_getReplicas(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceGrid__InternalRegistry__getReplicas_name);
    ::IceGrid::InternalRegistryPrxSeq __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::IceGrid::ApplicationInfoSeq
IceProxy::IceGrid::InternalRegistry::getApplications(::Ice::Long& serial, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__InternalRegistry__getApplications_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceGrid__InternalRegistry__getApplications_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::InternalRegistry* __del = dynamic_cast< ::IceDelegate::IceGrid::InternalRegistry*>(__delBase.get());
            return __del->getApplications(serial, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::InternalRegistry::begin_getApplications(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceGrid__InternalRegistry__getApplications_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__InternalRegistry__getApplications_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__InternalRegistry__getApplications_name, ::Ice::Idempotent, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::IceGrid::ApplicationInfoSeq
IceProxy::IceGrid::InternalRegistry::end_getApplications(::Ice::Long& serial, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceGrid__InternalRegistry__getApplications_name);
    ::IceGrid::ApplicationInfoSeq __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(serial);
        __is->read(__ret);
        __is->readPendingObjects();
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::IceGrid::AdapterInfoSeq
IceProxy::IceGrid::InternalRegistry::getAdapters(::Ice::Long& serial, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__InternalRegistry__getAdapters_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceGrid__InternalRegistry__getAdapters_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::InternalRegistry* __del = dynamic_cast< ::IceDelegate::IceGrid::InternalRegistry*>(__delBase.get());
            return __del->getAdapters(serial, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::InternalRegistry::begin_getAdapters(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceGrid__InternalRegistry__getAdapters_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__InternalRegistry__getAdapters_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__InternalRegistry__getAdapters_name, ::Ice::Idempotent, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::IceGrid::AdapterInfoSeq
IceProxy::IceGrid::InternalRegistry::end_getAdapters(::Ice::Long& serial, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceGrid__InternalRegistry__getAdapters_name);
    ::IceGrid::AdapterInfoSeq __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(serial);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::IceGrid::ObjectInfoSeq
IceProxy::IceGrid::InternalRegistry::getObjects(::Ice::Long& serial, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__InternalRegistry__getObjects_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceGrid__InternalRegistry__getObjects_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::InternalRegistry* __del = dynamic_cast< ::IceDelegate::IceGrid::InternalRegistry*>(__delBase.get());
            return __del->getObjects(serial, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::InternalRegistry::begin_getObjects(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceGrid__InternalRegistry__getObjects_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__InternalRegistry__getObjects_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__InternalRegistry__getObjects_name, ::Ice::Idempotent, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::IceGrid::ObjectInfoSeq
IceProxy::IceGrid::InternalRegistry::end_getObjects(::Ice::Long& serial, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceGrid__InternalRegistry__getObjects_name);
    ::IceGrid::ObjectInfoSeq __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(serial);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::IceGrid::InternalRegistry::shutdown(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceGrid__InternalRegistry__shutdown_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceGrid::InternalRegistry* __del = dynamic_cast< ::IceDelegate::IceGrid::InternalRegistry*>(__delBase.get());
            __del->shutdown(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceGrid::InternalRegistry::begin_shutdown(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceGrid__InternalRegistry__shutdown_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceGrid__InternalRegistry__shutdown_name, ::Ice::Idempotent, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceGrid::InternalRegistry::end_shutdown(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceGrid__InternalRegistry__shutdown_name);
}

const ::std::string&
IceProxy::IceGrid::InternalRegistry::ice_staticId()
{
    return ::IceGrid::InternalRegistry::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceGrid::InternalRegistry::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceGrid::InternalRegistry);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceGrid::InternalRegistry::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceGrid::InternalRegistry);
}

::IceProxy::Ice::Object*
IceProxy::IceGrid::InternalRegistry::__newInstance() const
{
    return new InternalRegistry;
}

::Ice::ObjectPrx
IceDelegateM::IceGrid::Adapter::activate(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__Adapter__activate_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Ice::ObjectPrx __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::ObjectPrx
IceDelegateM::IceGrid::Adapter::getDirectProxy(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__Adapter__getDirectProxy_name, ::Ice::Nonmutating, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Ice::ObjectPrx __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::IceGrid::AdapterNotActiveException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::IceGrid::Adapter::setDirectProxy(const ::Ice::ObjectPrx& proxy, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__Adapter__setDirectProxy_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(proxy);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::IceGrid::AdapterActiveException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Long
IceDelegateM::IceGrid::FileReader::getOffsetFromEnd(const ::std::string& filename, ::Ice::Int lines, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__FileReader__getOffsetFromEnd_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(filename);
        __os->write(lines);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Long __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::IceGrid::FileNotAvailableException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::IceGrid::FileReader::read(const ::std::string& filename, ::Ice::Long pos, ::Ice::Int size, ::Ice::Long& newPos, ::Ice::StringSeq& lines, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__FileReader__read_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(filename);
        __os->write(pos);
        __os->write(size);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::IceGrid::FileNotAvailableException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(newPos);
        __is->read(lines);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::IceGrid::Server::start(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__Server__start_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::IceGrid::ServerStartException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::IceGrid::Server::stop(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__Server__stop_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::IceGrid::ServerStopException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::IceGrid::Server::checkUpdate(const ::IceGrid::InternalServerDescriptorPtr& svr, bool noRestart, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__Server__checkUpdate_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(svr);
        __os->write(noRestart);
        __os->writePendingObjects();
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::IceGrid::DeploymentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::IceGrid::Server::setEnabled(bool enable, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__Server__setEnabled_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(enable);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

bool
IceDelegateM::IceGrid::Server::isEnabled(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__Server__isEnabled_name, ::Ice::Nonmutating, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::IceGrid::Server::sendSignal(const ::std::string& signal, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__Server__sendSignal_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(signal);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::IceGrid::BadSignalException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::IceGrid::Server::writeMessage(const ::std::string& message, ::Ice::Int fd, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__Server__writeMessage_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(message);
        __os->write(fd);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::IceGrid::ServerState
IceDelegateM::IceGrid::Server::getState(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__Server__getState_name, ::Ice::Nonmutating, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::IceGrid::ServerState __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::IceGrid::Server::getPid(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__Server__getPid_name, ::Ice::Nonmutating, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::IceGrid::Server::setProcess(const ::Ice::ProcessPrx& proc, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__Server__setProcess_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(proc);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::IceGrid::ReplicaObserver::replicaInit(const ::IceGrid::InternalRegistryPrxSeq& replicas, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__ReplicaObserver__replicaInit_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(replicas);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::IceGrid::ReplicaObserver::replicaAdded(const ::IceGrid::InternalRegistryPrx& replica, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__ReplicaObserver__replicaAdded_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(replica);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::IceGrid::ReplicaObserver::replicaRemoved(const ::IceGrid::InternalRegistryPrx& replica, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__ReplicaObserver__replicaRemoved_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(replica);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::IceGrid::PatcherFeedback::finished(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__PatcherFeedback__finished_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::IceGrid::PatcherFeedback::failed(const ::std::string& reason, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__PatcherFeedback__failed_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(reason);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::IceGrid::ServerPrx
IceDelegateM::IceGrid::Node::loadServer(const ::IceGrid::InternalServerDescriptorPtr& svr, const ::std::string& replicaName, ::IceGrid::AdapterPrxDict& adapters, ::Ice::Int& actTimeout, ::Ice::Int& deactTimeout, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__Node__loadServer_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(svr);
        __os->write(replicaName);
        __os->writePendingObjects();
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::IceGrid::ServerPrx __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::IceGrid::DeploymentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(adapters);
        __is->read(actTimeout);
        __is->read(deactTimeout);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::IceGrid::ServerPrx
IceDelegateM::IceGrid::Node::loadServerWithoutRestart(const ::IceGrid::InternalServerDescriptorPtr& svr, const ::std::string& replicaName, ::IceGrid::AdapterPrxDict& adapters, ::Ice::Int& actTimeout, ::Ice::Int& deactTimeout, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__Node__loadServerWithoutRestart_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(svr);
        __os->write(replicaName);
        __os->writePendingObjects();
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::IceGrid::ServerPrx __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::IceGrid::DeploymentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(adapters);
        __is->read(actTimeout);
        __is->read(deactTimeout);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::IceGrid::Node::destroyServer(const ::std::string& name, const ::std::string& uuid, ::Ice::Int revision, const ::std::string& replicaName, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__Node__destroyServer_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(name);
        __os->write(uuid);
        __os->write(revision);
        __os->write(replicaName);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::IceGrid::DeploymentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::IceGrid::Node::patch(const ::IceGrid::PatcherFeedbackPrx& feedback, const ::std::string& application, const ::std::string& server, const ::IceGrid::InternalDistributionDescriptorPtr& appDistrib, bool shutdown, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__Node__patch_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(feedback);
        __os->write(application);
        __os->write(server);
        __os->write(appDistrib);
        __os->write(shutdown);
        __os->writePendingObjects();
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::IceGrid::Node::registerWithReplica(const ::IceGrid::InternalRegistryPrx& replica, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__Node__registerWithReplica_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(replica);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::std::string
IceDelegateM::IceGrid::Node::getName(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__Node__getName_name, ::Ice::Nonmutating, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::std::string __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::IceGrid::Node::getHostname(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__Node__getHostname_name, ::Ice::Nonmutating, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::std::string __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::IceGrid::LoadInfo
IceDelegateM::IceGrid::Node::getLoad(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__Node__getLoad_name, ::Ice::Nonmutating, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::IceGrid::LoadInfo __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::IceGrid::Node::getProcessorSocketCount(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__Node__getProcessorSocketCount_name, ::Ice::Nonmutating, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::IceGrid::Node::shutdown(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__Node__shutdown_name, ::Ice::Nonmutating, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::IceGrid::NodeSession::keepAlive(const ::IceGrid::LoadInfo& load, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__NodeSession__keepAlive_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(load);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::IceGrid::NodeSession::setReplicaObserver(const ::IceGrid::ReplicaObserverPrx& observer, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__NodeSession__setReplicaObserver_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(observer);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Int
IceDelegateM::IceGrid::NodeSession::getTimeout(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__NodeSession__getTimeout_name, ::Ice::Nonmutating, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::IceGrid::NodeObserverPrx
IceDelegateM::IceGrid::NodeSession::getObserver(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__NodeSession__getObserver_name, ::Ice::Nonmutating, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::IceGrid::NodeObserverPrx __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::IceGrid::NodeSession::loadServers(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__NodeSession__loadServers_name, ::Ice::Nonmutating, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::StringSeq
IceDelegateM::IceGrid::NodeSession::getServers(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__NodeSession__getServers_name, ::Ice::Nonmutating, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Ice::StringSeq __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::IceGrid::NodeSession::waitForApplicationUpdate(const ::std::string& application, ::Ice::Int revision, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__NodeSession__waitForApplicationUpdate_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(application);
        __os->write(revision);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::IceGrid::NodeSession::destroy(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__NodeSession__destroy_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::IceGrid::ReplicaSession::keepAlive(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__ReplicaSession__keepAlive_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Int
IceDelegateM::IceGrid::ReplicaSession::getTimeout(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__ReplicaSession__getTimeout_name, ::Ice::Idempotent, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::IceGrid::ReplicaSession::setDatabaseObserver(const ::IceGrid::DatabaseObserverPrx& dbObs, const IceUtil::Optional< ::IceGrid::StringLongDict>& serials, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__ReplicaSession__setDatabaseObserver_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(dbObs);
        __os->write(1, serials);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::IceGrid::DeploymentException&)
            {
                throw;
            }
            catch(const ::IceGrid::ObserverAlreadyRegisteredException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::IceGrid::ReplicaSession::setEndpoints(const ::IceGrid::StringObjectProxyDict& endpoints, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__ReplicaSession__setEndpoints_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(endpoints);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::IceGrid::ReplicaSession::registerWellKnownObjects(const ::IceGrid::ObjectInfoSeq& objects, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__ReplicaSession__registerWellKnownObjects_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(objects);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::IceGrid::ReplicaSession::setAdapterDirectProxy(const ::std::string& adapterId, const ::std::string& replicaGroupId, const ::Ice::ObjectPrx& proxy, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__ReplicaSession__setAdapterDirectProxy_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(adapterId);
        __os->write(replicaGroupId);
        __os->write(proxy);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::IceGrid::AdapterExistsException&)
            {
                throw;
            }
            catch(const ::IceGrid::AdapterNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::IceGrid::ReplicaSession::receivedUpdate(::IceGrid::TopicName name, ::Ice::Int serial, const ::std::string& failure, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__ReplicaSession__receivedUpdate_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(name);
        __os->write(serial);
        __os->write(failure);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::IceGrid::ReplicaSession::destroy(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__ReplicaSession__destroy_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::IceGrid::NodeSessionPrx
IceDelegateM::IceGrid::InternalRegistry::registerNode(const ::IceGrid::InternalNodeInfoPtr& info, const ::IceGrid::NodePrx& prx, const ::IceGrid::LoadInfo& loadInf, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__InternalRegistry__registerNode_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(info);
        __os->write(prx);
        __os->write(loadInf);
        __os->writePendingObjects();
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::IceGrid::NodeSessionPrx __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::IceGrid::NodeActiveException&)
            {
                throw;
            }
            catch(const ::IceGrid::PermissionDeniedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::IceGrid::ReplicaSessionPrx
IceDelegateM::IceGrid::InternalRegistry::registerReplica(const ::IceGrid::InternalReplicaInfoPtr& info, const ::IceGrid::InternalRegistryPrx& prx, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__InternalRegistry__registerReplica_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(info);
        __os->write(prx);
        __os->writePendingObjects();
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::IceGrid::ReplicaSessionPrx __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::IceGrid::PermissionDeniedException&)
            {
                throw;
            }
            catch(const ::IceGrid::ReplicaActiveException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::IceGrid::InternalRegistry::registerWithReplica(const ::IceGrid::InternalRegistryPrx& prx, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__InternalRegistry__registerWithReplica_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(prx);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::IceGrid::NodePrxSeq
IceDelegateM::IceGrid::InternalRegistry::getNodes(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__InternalRegistry__getNodes_name, ::Ice::Idempotent, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::IceGrid::NodePrxSeq __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::IceGrid::InternalRegistryPrxSeq
IceDelegateM::IceGrid::InternalRegistry::getReplicas(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__InternalRegistry__getReplicas_name, ::Ice::Idempotent, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::IceGrid::InternalRegistryPrxSeq __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::IceGrid::ApplicationInfoSeq
IceDelegateM::IceGrid::InternalRegistry::getApplications(::Ice::Long& serial, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__InternalRegistry__getApplications_name, ::Ice::Idempotent, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::IceGrid::ApplicationInfoSeq __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(serial);
        __is->read(__ret);
        __is->readPendingObjects();
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::IceGrid::AdapterInfoSeq
IceDelegateM::IceGrid::InternalRegistry::getAdapters(::Ice::Long& serial, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__InternalRegistry__getAdapters_name, ::Ice::Idempotent, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::IceGrid::AdapterInfoSeq __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(serial);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::IceGrid::ObjectInfoSeq
IceDelegateM::IceGrid::InternalRegistry::getObjects(::Ice::Long& serial, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__InternalRegistry__getObjects_name, ::Ice::Idempotent, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::IceGrid::ObjectInfoSeq __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(serial);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::IceGrid::InternalRegistry::shutdown(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceGrid__InternalRegistry__shutdown_name, ::Ice::Idempotent, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::ObjectPrx
IceDelegateD::IceGrid::Adapter::activate(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Ice::ObjectPrx(); // to avoid a warning with some compilers;
}

::Ice::ObjectPrx
IceDelegateD::IceGrid::Adapter::getDirectProxy(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::ObjectPrx& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::Adapter* servant = dynamic_cast< ::IceGrid::Adapter*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->getDirectProxy(_current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::ObjectPrx& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__Adapter__getDirectProxy_name, ::Ice::Nonmutating, __context);
    ::Ice::ObjectPrx __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::IceGrid::AdapterNotActiveException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::IceGrid::Adapter::setDirectProxy(const ::Ice::ObjectPrx& proxy, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::ObjectPrx& __p_proxy, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_proxy(__p_proxy)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::Adapter* servant = dynamic_cast< ::IceGrid::Adapter*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->setDirectProxy(_m_proxy, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::Ice::ObjectPrx& _m_proxy;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__Adapter__setDirectProxy_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(proxy, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::IceGrid::AdapterActiveException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Long
IceDelegateD::IceGrid::FileReader::getOffsetFromEnd(const ::std::string& filename, ::Ice::Int lines, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Long& __result, const ::std::string& __p_filename, ::Ice::Int __p_lines, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_filename(__p_filename),
            _m_lines(__p_lines)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::FileReader* servant = dynamic_cast< ::IceGrid::FileReader*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->getOffsetFromEnd(_m_filename, _m_lines, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Long& _result;
        const ::std::string& _m_filename;
        ::Ice::Int _m_lines;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__FileReader__getOffsetFromEnd_name, ::Ice::Idempotent, __context);
    ::Ice::Long __result;
    try
    {
        _DirectI __direct(__result, filename, lines, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::IceGrid::FileNotAvailableException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

bool
IceDelegateD::IceGrid::FileReader::read(const ::std::string& filename, ::Ice::Long pos, ::Ice::Int size, ::Ice::Long& newPos, ::Ice::StringSeq& lines, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool& __result, const ::std::string& __p_filename, ::Ice::Long __p_pos, ::Ice::Int __p_size, ::Ice::Long& __p_newPos, ::Ice::StringSeq& __p_lines, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_filename(__p_filename),
            _m_pos(__p_pos),
            _m_size(__p_size),
            _m_newPos(__p_newPos),
            _m_lines(__p_lines)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::FileReader* servant = dynamic_cast< ::IceGrid::FileReader*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->read(_m_filename, _m_pos, _m_size, _m_newPos, _m_lines, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        bool& _result;
        const ::std::string& _m_filename;
        ::Ice::Long _m_pos;
        ::Ice::Int _m_size;
        ::Ice::Long& _m_newPos;
        ::Ice::StringSeq& _m_lines;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__FileReader__read_name, ::Ice::Idempotent, __context);
    bool __result;
    try
    {
        _DirectI __direct(__result, filename, pos, size, newPos, lines, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::IceGrid::FileNotAvailableException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::IceGrid::Server::start(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::IceGrid::Server::stop(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

bool
IceDelegateD::IceGrid::Server::checkUpdate(const ::IceGrid::InternalServerDescriptorPtr& svr, bool noRestart, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool& __result, const ::IceGrid::InternalServerDescriptorPtr& __p_svr, bool __p_noRestart, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_svr(__p_svr),
            _m_noRestart(__p_noRestart)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::Server* servant = dynamic_cast< ::IceGrid::Server*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->checkUpdate(_m_svr, _m_noRestart, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        bool& _result;
        const ::IceGrid::InternalServerDescriptorPtr& _m_svr;
        bool _m_noRestart;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__Server__checkUpdate_name, ::Ice::Normal, __context);
    bool __result;
    try
    {
        _DirectI __direct(__result, svr, noRestart, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::IceGrid::DeploymentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::IceGrid::Server::setEnabled(bool enable, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool __p_enable, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_enable(__p_enable)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::Server* servant = dynamic_cast< ::IceGrid::Server*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setEnabled(_m_enable, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool _m_enable;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__Server__setEnabled_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(enable, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

bool
IceDelegateD::IceGrid::Server::isEnabled(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::Server* servant = dynamic_cast< ::IceGrid::Server*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->isEnabled(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__Server__isEnabled_name, ::Ice::Nonmutating, __context);
    bool __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::IceGrid::Server::sendSignal(const ::std::string& signal, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_signal, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_signal(__p_signal)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::Server* servant = dynamic_cast< ::IceGrid::Server*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->sendSignal(_m_signal, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::std::string& _m_signal;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__Server__sendSignal_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(signal, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::IceGrid::BadSignalException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceGrid::Server::writeMessage(const ::std::string& message, ::Ice::Int fd, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_message, ::Ice::Int __p_fd, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_message(__p_message),
            _m_fd(__p_fd)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::Server* servant = dynamic_cast< ::IceGrid::Server*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->writeMessage(_m_message, _m_fd, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_message;
        ::Ice::Int _m_fd;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__Server__writeMessage_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(message, fd, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::IceGrid::ServerState
IceDelegateD::IceGrid::Server::getState(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::IceGrid::ServerState& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::Server* servant = dynamic_cast< ::IceGrid::Server*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getState(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::IceGrid::ServerState& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__Server__getState_name, ::Ice::Nonmutating, __context);
    ::IceGrid::ServerState __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::IceGrid::Server::getPid(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::Server* servant = dynamic_cast< ::IceGrid::Server*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getPid(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__Server__getPid_name, ::Ice::Nonmutating, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::IceGrid::Server::setProcess(const ::Ice::ProcessPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::IceGrid::ReplicaObserver::replicaInit(const ::IceGrid::InternalRegistryPrxSeq& replicas, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::IceGrid::InternalRegistryPrxSeq& __p_replicas, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_replicas(__p_replicas)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::ReplicaObserver* servant = dynamic_cast< ::IceGrid::ReplicaObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->replicaInit(_m_replicas, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::IceGrid::InternalRegistryPrxSeq& _m_replicas;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__ReplicaObserver__replicaInit_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(replicas, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceGrid::ReplicaObserver::replicaAdded(const ::IceGrid::InternalRegistryPrx& replica, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::IceGrid::InternalRegistryPrx& __p_replica, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_replica(__p_replica)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::ReplicaObserver* servant = dynamic_cast< ::IceGrid::ReplicaObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->replicaAdded(_m_replica, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::IceGrid::InternalRegistryPrx& _m_replica;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__ReplicaObserver__replicaAdded_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(replica, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceGrid::ReplicaObserver::replicaRemoved(const ::IceGrid::InternalRegistryPrx& replica, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::IceGrid::InternalRegistryPrx& __p_replica, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_replica(__p_replica)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::ReplicaObserver* servant = dynamic_cast< ::IceGrid::ReplicaObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->replicaRemoved(_m_replica, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::IceGrid::InternalRegistryPrx& _m_replica;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__ReplicaObserver__replicaRemoved_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(replica, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceGrid::PatcherFeedback::finished(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::PatcherFeedback* servant = dynamic_cast< ::IceGrid::PatcherFeedback*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->finished(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__PatcherFeedback__finished_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceGrid::PatcherFeedback::failed(const ::std::string& reason, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_reason, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_reason(__p_reason)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::PatcherFeedback* servant = dynamic_cast< ::IceGrid::PatcherFeedback*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->failed(_m_reason, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_reason;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__PatcherFeedback__failed_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(reason, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::IceGrid::ServerPrx
IceDelegateD::IceGrid::Node::loadServer(const ::IceGrid::InternalServerDescriptorPtr&, const ::std::string&, ::IceGrid::AdapterPrxDict&, ::Ice::Int&, ::Ice::Int&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::IceGrid::ServerPrx(); // to avoid a warning with some compilers;
}

::IceGrid::ServerPrx
IceDelegateD::IceGrid::Node::loadServerWithoutRestart(const ::IceGrid::InternalServerDescriptorPtr&, const ::std::string&, ::IceGrid::AdapterPrxDict&, ::Ice::Int&, ::Ice::Int&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::IceGrid::ServerPrx(); // to avoid a warning with some compilers;
}

void
IceDelegateD::IceGrid::Node::destroyServer(const ::std::string&, const ::std::string&, ::Ice::Int, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::IceGrid::Node::patch(const ::IceGrid::PatcherFeedbackPrx&, const ::std::string&, const ::std::string&, const ::IceGrid::InternalDistributionDescriptorPtr&, bool, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::IceGrid::Node::registerWithReplica(const ::IceGrid::InternalRegistryPrx& replica, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::IceGrid::InternalRegistryPrx& __p_replica, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_replica(__p_replica)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::Node* servant = dynamic_cast< ::IceGrid::Node*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->registerWithReplica(_m_replica, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::IceGrid::InternalRegistryPrx& _m_replica;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__Node__registerWithReplica_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(replica, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::std::string
IceDelegateD::IceGrid::Node::getName(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::std::string& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::Node* servant = dynamic_cast< ::IceGrid::Node*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getName(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::std::string& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__Node__getName_name, ::Ice::Nonmutating, __context);
    ::std::string __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::std::string
IceDelegateD::IceGrid::Node::getHostname(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::std::string& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::Node* servant = dynamic_cast< ::IceGrid::Node*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getHostname(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::std::string& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__Node__getHostname_name, ::Ice::Nonmutating, __context);
    ::std::string __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::IceGrid::LoadInfo
IceDelegateD::IceGrid::Node::getLoad(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::IceGrid::LoadInfo& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::Node* servant = dynamic_cast< ::IceGrid::Node*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getLoad(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::IceGrid::LoadInfo& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__Node__getLoad_name, ::Ice::Nonmutating, __context);
    ::IceGrid::LoadInfo __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::IceGrid::Node::getProcessorSocketCount(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::Node* servant = dynamic_cast< ::IceGrid::Node*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getProcessorSocketCount(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__Node__getProcessorSocketCount_name, ::Ice::Nonmutating, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::IceGrid::Node::shutdown(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::Node* servant = dynamic_cast< ::IceGrid::Node*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->shutdown(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__Node__shutdown_name, ::Ice::Nonmutating, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceGrid::NodeSession::keepAlive(const ::IceGrid::LoadInfo& load, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::IceGrid::LoadInfo& __p_load, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_load(__p_load)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::NodeSession* servant = dynamic_cast< ::IceGrid::NodeSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->keepAlive(_m_load, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::IceGrid::LoadInfo& _m_load;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__NodeSession__keepAlive_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(load, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceGrid::NodeSession::setReplicaObserver(const ::IceGrid::ReplicaObserverPrx& observer, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::IceGrid::ReplicaObserverPrx& __p_observer, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_observer(__p_observer)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::NodeSession* servant = dynamic_cast< ::IceGrid::NodeSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setReplicaObserver(_m_observer, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::IceGrid::ReplicaObserverPrx& _m_observer;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__NodeSession__setReplicaObserver_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(observer, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Int
IceDelegateD::IceGrid::NodeSession::getTimeout(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::NodeSession* servant = dynamic_cast< ::IceGrid::NodeSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getTimeout(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__NodeSession__getTimeout_name, ::Ice::Nonmutating, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::IceGrid::NodeObserverPrx
IceDelegateD::IceGrid::NodeSession::getObserver(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::IceGrid::NodeObserverPrx& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::NodeSession* servant = dynamic_cast< ::IceGrid::NodeSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getObserver(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::IceGrid::NodeObserverPrx& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__NodeSession__getObserver_name, ::Ice::Nonmutating, __context);
    ::IceGrid::NodeObserverPrx __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::IceGrid::NodeSession::loadServers(const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

::Ice::StringSeq
IceDelegateD::IceGrid::NodeSession::getServers(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::StringSeq& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::NodeSession* servant = dynamic_cast< ::IceGrid::NodeSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getServers(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::StringSeq& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__NodeSession__getServers_name, ::Ice::Nonmutating, __context);
    ::Ice::StringSeq __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::IceGrid::NodeSession::waitForApplicationUpdate(const ::std::string&, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

void
IceDelegateD::IceGrid::NodeSession::destroy(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::NodeSession* servant = dynamic_cast< ::IceGrid::NodeSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->destroy(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__NodeSession__destroy_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceGrid::ReplicaSession::keepAlive(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::ReplicaSession* servant = dynamic_cast< ::IceGrid::ReplicaSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->keepAlive(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__ReplicaSession__keepAlive_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Int
IceDelegateD::IceGrid::ReplicaSession::getTimeout(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::ReplicaSession* servant = dynamic_cast< ::IceGrid::ReplicaSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getTimeout(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__ReplicaSession__getTimeout_name, ::Ice::Idempotent, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::IceGrid::ReplicaSession::setDatabaseObserver(const ::IceGrid::DatabaseObserverPrx& dbObs, const IceUtil::Optional< ::IceGrid::StringLongDict>& serials, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::IceGrid::DatabaseObserverPrx& __p_dbObs, const IceUtil::Optional< ::IceGrid::StringLongDict>& __p_serials, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_dbObs(__p_dbObs),
            _m_serials(__p_serials)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::ReplicaSession* servant = dynamic_cast< ::IceGrid::ReplicaSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->setDatabaseObserver(_m_dbObs, _m_serials, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::IceGrid::DatabaseObserverPrx& _m_dbObs;
        const IceUtil::Optional< ::IceGrid::StringLongDict>& _m_serials;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__ReplicaSession__setDatabaseObserver_name, ::Ice::Idempotent, __context);
    try
    {
        _DirectI __direct(dbObs, serials, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::IceGrid::DeploymentException&)
    {
        throw;
    }
    catch(const ::IceGrid::ObserverAlreadyRegisteredException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceGrid::ReplicaSession::setEndpoints(const ::IceGrid::StringObjectProxyDict& endpoints, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::IceGrid::StringObjectProxyDict& __p_endpoints, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_endpoints(__p_endpoints)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::ReplicaSession* servant = dynamic_cast< ::IceGrid::ReplicaSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setEndpoints(_m_endpoints, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::IceGrid::StringObjectProxyDict& _m_endpoints;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__ReplicaSession__setEndpoints_name, ::Ice::Idempotent, __context);
    try
    {
        _DirectI __direct(endpoints, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceGrid::ReplicaSession::registerWellKnownObjects(const ::IceGrid::ObjectInfoSeq& objects, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::IceGrid::ObjectInfoSeq& __p_objects, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_objects(__p_objects)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::ReplicaSession* servant = dynamic_cast< ::IceGrid::ReplicaSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->registerWellKnownObjects(_m_objects, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::IceGrid::ObjectInfoSeq& _m_objects;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__ReplicaSession__registerWellKnownObjects_name, ::Ice::Idempotent, __context);
    try
    {
        _DirectI __direct(objects, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceGrid::ReplicaSession::setAdapterDirectProxy(const ::std::string& adapterId, const ::std::string& replicaGroupId, const ::Ice::ObjectPrx& proxy, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_adapterId, const ::std::string& __p_replicaGroupId, const ::Ice::ObjectPrx& __p_proxy, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_adapterId(__p_adapterId),
            _m_replicaGroupId(__p_replicaGroupId),
            _m_proxy(__p_proxy)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::ReplicaSession* servant = dynamic_cast< ::IceGrid::ReplicaSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->setAdapterDirectProxy(_m_adapterId, _m_replicaGroupId, _m_proxy, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::std::string& _m_adapterId;
        const ::std::string& _m_replicaGroupId;
        const ::Ice::ObjectPrx& _m_proxy;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__ReplicaSession__setAdapterDirectProxy_name, ::Ice::Idempotent, __context);
    try
    {
        _DirectI __direct(adapterId, replicaGroupId, proxy, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::IceGrid::AdapterExistsException&)
    {
        throw;
    }
    catch(const ::IceGrid::AdapterNotExistException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceGrid::ReplicaSession::receivedUpdate(::IceGrid::TopicName name, ::Ice::Int serial, const ::std::string& failure, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::IceGrid::TopicName __p_name, ::Ice::Int __p_serial, const ::std::string& __p_failure, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_name(__p_name),
            _m_serial(__p_serial),
            _m_failure(__p_failure)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::ReplicaSession* servant = dynamic_cast< ::IceGrid::ReplicaSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->receivedUpdate(_m_name, _m_serial, _m_failure, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::IceGrid::TopicName _m_name;
        ::Ice::Int _m_serial;
        const ::std::string& _m_failure;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__ReplicaSession__receivedUpdate_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(name, serial, failure, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceGrid::ReplicaSession::destroy(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::ReplicaSession* servant = dynamic_cast< ::IceGrid::ReplicaSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->destroy(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__ReplicaSession__destroy_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::IceGrid::NodeSessionPrx
IceDelegateD::IceGrid::InternalRegistry::registerNode(const ::IceGrid::InternalNodeInfoPtr& info, const ::IceGrid::NodePrx& prx, const ::IceGrid::LoadInfo& loadInf, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::IceGrid::NodeSessionPrx& __result, const ::IceGrid::InternalNodeInfoPtr& __p_info, const ::IceGrid::NodePrx& __p_prx, const ::IceGrid::LoadInfo& __p_loadInf, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_info(__p_info),
            _m_prx(__p_prx),
            _m_loadInf(__p_loadInf)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::InternalRegistry* servant = dynamic_cast< ::IceGrid::InternalRegistry*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->registerNode(_m_info, _m_prx, _m_loadInf, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::IceGrid::NodeSessionPrx& _result;
        const ::IceGrid::InternalNodeInfoPtr& _m_info;
        const ::IceGrid::NodePrx& _m_prx;
        const ::IceGrid::LoadInfo& _m_loadInf;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__InternalRegistry__registerNode_name, ::Ice::Normal, __context);
    ::IceGrid::NodeSessionPrx __result;
    try
    {
        _DirectI __direct(__result, info, prx, loadInf, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::IceGrid::NodeActiveException&)
    {
        throw;
    }
    catch(const ::IceGrid::PermissionDeniedException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::IceGrid::ReplicaSessionPrx
IceDelegateD::IceGrid::InternalRegistry::registerReplica(const ::IceGrid::InternalReplicaInfoPtr& info, const ::IceGrid::InternalRegistryPrx& prx, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::IceGrid::ReplicaSessionPrx& __result, const ::IceGrid::InternalReplicaInfoPtr& __p_info, const ::IceGrid::InternalRegistryPrx& __p_prx, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_info(__p_info),
            _m_prx(__p_prx)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::InternalRegistry* servant = dynamic_cast< ::IceGrid::InternalRegistry*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->registerReplica(_m_info, _m_prx, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::IceGrid::ReplicaSessionPrx& _result;
        const ::IceGrid::InternalReplicaInfoPtr& _m_info;
        const ::IceGrid::InternalRegistryPrx& _m_prx;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__InternalRegistry__registerReplica_name, ::Ice::Normal, __context);
    ::IceGrid::ReplicaSessionPrx __result;
    try
    {
        _DirectI __direct(__result, info, prx, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::IceGrid::PermissionDeniedException&)
    {
        throw;
    }
    catch(const ::IceGrid::ReplicaActiveException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::IceGrid::InternalRegistry::registerWithReplica(const ::IceGrid::InternalRegistryPrx& prx, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::IceGrid::InternalRegistryPrx& __p_prx, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_prx(__p_prx)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::InternalRegistry* servant = dynamic_cast< ::IceGrid::InternalRegistry*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->registerWithReplica(_m_prx, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::IceGrid::InternalRegistryPrx& _m_prx;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__InternalRegistry__registerWithReplica_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(prx, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::IceGrid::NodePrxSeq
IceDelegateD::IceGrid::InternalRegistry::getNodes(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::IceGrid::NodePrxSeq& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::InternalRegistry* servant = dynamic_cast< ::IceGrid::InternalRegistry*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getNodes(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::IceGrid::NodePrxSeq& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__InternalRegistry__getNodes_name, ::Ice::Idempotent, __context);
    ::IceGrid::NodePrxSeq __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::IceGrid::InternalRegistryPrxSeq
IceDelegateD::IceGrid::InternalRegistry::getReplicas(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::IceGrid::InternalRegistryPrxSeq& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::InternalRegistry* servant = dynamic_cast< ::IceGrid::InternalRegistry*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getReplicas(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::IceGrid::InternalRegistryPrxSeq& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__InternalRegistry__getReplicas_name, ::Ice::Idempotent, __context);
    ::IceGrid::InternalRegistryPrxSeq __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::IceGrid::ApplicationInfoSeq
IceDelegateD::IceGrid::InternalRegistry::getApplications(::Ice::Long& serial, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::IceGrid::ApplicationInfoSeq& __result, ::Ice::Long& __p_serial, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_serial(__p_serial)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::InternalRegistry* servant = dynamic_cast< ::IceGrid::InternalRegistry*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getApplications(_m_serial, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::IceGrid::ApplicationInfoSeq& _result;
        ::Ice::Long& _m_serial;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__InternalRegistry__getApplications_name, ::Ice::Idempotent, __context);
    ::IceGrid::ApplicationInfoSeq __result;
    try
    {
        _DirectI __direct(__result, serial, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::IceGrid::AdapterInfoSeq
IceDelegateD::IceGrid::InternalRegistry::getAdapters(::Ice::Long& serial, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::IceGrid::AdapterInfoSeq& __result, ::Ice::Long& __p_serial, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_serial(__p_serial)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::InternalRegistry* servant = dynamic_cast< ::IceGrid::InternalRegistry*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getAdapters(_m_serial, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::IceGrid::AdapterInfoSeq& _result;
        ::Ice::Long& _m_serial;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__InternalRegistry__getAdapters_name, ::Ice::Idempotent, __context);
    ::IceGrid::AdapterInfoSeq __result;
    try
    {
        _DirectI __direct(__result, serial, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::IceGrid::ObjectInfoSeq
IceDelegateD::IceGrid::InternalRegistry::getObjects(::Ice::Long& serial, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::IceGrid::ObjectInfoSeq& __result, ::Ice::Long& __p_serial, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_serial(__p_serial)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::InternalRegistry* servant = dynamic_cast< ::IceGrid::InternalRegistry*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getObjects(_m_serial, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::IceGrid::ObjectInfoSeq& _result;
        ::Ice::Long& _m_serial;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__InternalRegistry__getObjects_name, ::Ice::Idempotent, __context);
    ::IceGrid::ObjectInfoSeq __result;
    try
    {
        _DirectI __direct(__result, serial, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::IceGrid::InternalRegistry::shutdown(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceGrid::InternalRegistry* servant = dynamic_cast< ::IceGrid::InternalRegistry*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->shutdown(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceGrid__InternalRegistry__shutdown_name, ::Ice::Idempotent, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Object* IceGrid::upCast(::IceGrid::InternalDbEnvDescriptor* p) { return p; }
::Ice::ObjectPtr
IceGrid::InternalDbEnvDescriptor::ice_clone() const
{
    ::Ice::Object* __p = new InternalDbEnvDescriptor(*this);
    return __p;
}

namespace
{
const ::std::string __IceGrid__InternalDbEnvDescriptor_ids[2] =
{
    "::Ice::Object",
    "::IceGrid::InternalDbEnvDescriptor"
};

}

bool
IceGrid::InternalDbEnvDescriptor::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceGrid__InternalDbEnvDescriptor_ids, __IceGrid__InternalDbEnvDescriptor_ids + 2, _s);
}

::std::vector< ::std::string>
IceGrid::InternalDbEnvDescriptor::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceGrid__InternalDbEnvDescriptor_ids[0], &__IceGrid__InternalDbEnvDescriptor_ids[2]);
}

const ::std::string&
IceGrid::InternalDbEnvDescriptor::ice_id(const ::Ice::Current&) const
{
    return __IceGrid__InternalDbEnvDescriptor_ids[1];
}

const ::std::string&
IceGrid::InternalDbEnvDescriptor::ice_staticId()
{
    return __IceGrid__InternalDbEnvDescriptor_ids[1];
}

void
IceGrid::InternalDbEnvDescriptor::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(name);
    __os->write(properties);
    __os->endWriteSlice();
}

void
IceGrid::InternalDbEnvDescriptor::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(name);
    __is->read(properties);
    __is->endReadSlice();
}

namespace
{

class __F__IceGrid__InternalDbEnvDescriptor : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::IceGrid::InternalDbEnvDescriptor::ice_staticId());
        return new ::IceGrid::InternalDbEnvDescriptor;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__IceGrid__InternalDbEnvDescriptor_Ptr = new __F__IceGrid__InternalDbEnvDescriptor;

class __F__IceGrid__InternalDbEnvDescriptor__Init
{
public:

    __F__IceGrid__InternalDbEnvDescriptor__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::IceGrid::InternalDbEnvDescriptor::ice_staticId(), __F__IceGrid__InternalDbEnvDescriptor_Ptr);
    }

    ~__F__IceGrid__InternalDbEnvDescriptor__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::IceGrid::InternalDbEnvDescriptor::ice_staticId());
    }
};

const __F__IceGrid__InternalDbEnvDescriptor__Init __F__IceGrid__InternalDbEnvDescriptor__i;

}

const ::Ice::ObjectFactoryPtr&
IceGrid::InternalDbEnvDescriptor::ice_factory()
{
    return __F__IceGrid__InternalDbEnvDescriptor_Ptr;
}

void 
IceGrid::__patch(InternalDbEnvDescriptorPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceGrid::InternalDbEnvDescriptorPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceGrid::InternalDbEnvDescriptor::ice_staticId(), v);
    }
}

::Ice::Object* IceGrid::upCast(::IceGrid::InternalAdapterDescriptor* p) { return p; }
::Ice::ObjectPtr
IceGrid::InternalAdapterDescriptor::ice_clone() const
{
    ::Ice::Object* __p = new InternalAdapterDescriptor(*this);
    return __p;
}

namespace
{
const ::std::string __IceGrid__InternalAdapterDescriptor_ids[2] =
{
    "::Ice::Object",
    "::IceGrid::InternalAdapterDescriptor"
};

}

bool
IceGrid::InternalAdapterDescriptor::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceGrid__InternalAdapterDescriptor_ids, __IceGrid__InternalAdapterDescriptor_ids + 2, _s);
}

::std::vector< ::std::string>
IceGrid::InternalAdapterDescriptor::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceGrid__InternalAdapterDescriptor_ids[0], &__IceGrid__InternalAdapterDescriptor_ids[2]);
}

const ::std::string&
IceGrid::InternalAdapterDescriptor::ice_id(const ::Ice::Current&) const
{
    return __IceGrid__InternalAdapterDescriptor_ids[1];
}

const ::std::string&
IceGrid::InternalAdapterDescriptor::ice_staticId()
{
    return __IceGrid__InternalAdapterDescriptor_ids[1];
}

void
IceGrid::InternalAdapterDescriptor::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(id);
    __os->write(serverLifetime);
    __os->endWriteSlice();
}

void
IceGrid::InternalAdapterDescriptor::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(id);
    __is->read(serverLifetime);
    __is->endReadSlice();
}

namespace
{

class __F__IceGrid__InternalAdapterDescriptor : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::IceGrid::InternalAdapterDescriptor::ice_staticId());
        return new ::IceGrid::InternalAdapterDescriptor;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__IceGrid__InternalAdapterDescriptor_Ptr = new __F__IceGrid__InternalAdapterDescriptor;

class __F__IceGrid__InternalAdapterDescriptor__Init
{
public:

    __F__IceGrid__InternalAdapterDescriptor__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::IceGrid::InternalAdapterDescriptor::ice_staticId(), __F__IceGrid__InternalAdapterDescriptor_Ptr);
    }

    ~__F__IceGrid__InternalAdapterDescriptor__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::IceGrid::InternalAdapterDescriptor::ice_staticId());
    }
};

const __F__IceGrid__InternalAdapterDescriptor__Init __F__IceGrid__InternalAdapterDescriptor__i;

}

const ::Ice::ObjectFactoryPtr&
IceGrid::InternalAdapterDescriptor::ice_factory()
{
    return __F__IceGrid__InternalAdapterDescriptor_Ptr;
}

void 
IceGrid::__patch(InternalAdapterDescriptorPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceGrid::InternalAdapterDescriptorPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceGrid::InternalAdapterDescriptor::ice_staticId(), v);
    }
}

::Ice::Object* IceGrid::upCast(::IceGrid::InternalDistributionDescriptor* p) { return p; }
::Ice::ObjectPtr
IceGrid::InternalDistributionDescriptor::ice_clone() const
{
    ::Ice::Object* __p = new InternalDistributionDescriptor(*this);
    return __p;
}

namespace
{
const ::std::string __IceGrid__InternalDistributionDescriptor_ids[2] =
{
    "::Ice::Object",
    "::IceGrid::InternalDistributionDescriptor"
};

}

bool
IceGrid::InternalDistributionDescriptor::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceGrid__InternalDistributionDescriptor_ids, __IceGrid__InternalDistributionDescriptor_ids + 2, _s);
}

::std::vector< ::std::string>
IceGrid::InternalDistributionDescriptor::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceGrid__InternalDistributionDescriptor_ids[0], &__IceGrid__InternalDistributionDescriptor_ids[2]);
}

const ::std::string&
IceGrid::InternalDistributionDescriptor::ice_id(const ::Ice::Current&) const
{
    return __IceGrid__InternalDistributionDescriptor_ids[1];
}

const ::std::string&
IceGrid::InternalDistributionDescriptor::ice_staticId()
{
    return __IceGrid__InternalDistributionDescriptor_ids[1];
}

void
IceGrid::InternalDistributionDescriptor::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(icepatch);
    __os->write(directories);
    __os->endWriteSlice();
}

void
IceGrid::InternalDistributionDescriptor::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(icepatch);
    __is->read(directories);
    __is->endReadSlice();
}

namespace
{

class __F__IceGrid__InternalDistributionDescriptor : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::IceGrid::InternalDistributionDescriptor::ice_staticId());
        return new ::IceGrid::InternalDistributionDescriptor;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__IceGrid__InternalDistributionDescriptor_Ptr = new __F__IceGrid__InternalDistributionDescriptor;

class __F__IceGrid__InternalDistributionDescriptor__Init
{
public:

    __F__IceGrid__InternalDistributionDescriptor__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::IceGrid::InternalDistributionDescriptor::ice_staticId(), __F__IceGrid__InternalDistributionDescriptor_Ptr);
    }

    ~__F__IceGrid__InternalDistributionDescriptor__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::IceGrid::InternalDistributionDescriptor::ice_staticId());
    }
};

const __F__IceGrid__InternalDistributionDescriptor__Init __F__IceGrid__InternalDistributionDescriptor__i;

}

const ::Ice::ObjectFactoryPtr&
IceGrid::InternalDistributionDescriptor::ice_factory()
{
    return __F__IceGrid__InternalDistributionDescriptor_Ptr;
}

void 
IceGrid::__patch(InternalDistributionDescriptorPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceGrid::InternalDistributionDescriptorPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceGrid::InternalDistributionDescriptor::ice_staticId(), v);
    }
}

::Ice::Object* IceGrid::upCast(::IceGrid::InternalServerDescriptor* p) { return p; }
::Ice::ObjectPtr
IceGrid::InternalServerDescriptor::ice_clone() const
{
    ::Ice::Object* __p = new InternalServerDescriptor(*this);
    return __p;
}

namespace
{
const ::std::string __IceGrid__InternalServerDescriptor_ids[2] =
{
    "::Ice::Object",
    "::IceGrid::InternalServerDescriptor"
};

}

bool
IceGrid::InternalServerDescriptor::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceGrid__InternalServerDescriptor_ids, __IceGrid__InternalServerDescriptor_ids + 2, _s);
}

::std::vector< ::std::string>
IceGrid::InternalServerDescriptor::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceGrid__InternalServerDescriptor_ids[0], &__IceGrid__InternalServerDescriptor_ids[2]);
}

const ::std::string&
IceGrid::InternalServerDescriptor::ice_id(const ::Ice::Current&) const
{
    return __IceGrid__InternalServerDescriptor_ids[1];
}

const ::std::string&
IceGrid::InternalServerDescriptor::ice_staticId()
{
    return __IceGrid__InternalServerDescriptor_ids[1];
}

void
IceGrid::InternalServerDescriptor::__addObject(::IceInternal::GCCountMap& _c)
{
    ::IceInternal::GCCountMap::iterator pos = _c.find(this);
    if(pos == _c.end())
    {
        _c[this] = 1;
    }
    else
    {
        ++pos->second;
    }
}

bool
IceGrid::InternalServerDescriptor::__usesGC()
{
    return true;
}

void
IceGrid::InternalServerDescriptor::__gcReachable(::IceInternal::GCCountMap& _c) const
{
    if(distrib)
    {
        ::IceGrid::upCast(distrib.get())->__addObject(_c);
    }
    {
        for(::IceGrid::InternalAdapterDescriptorSeq::const_iterator _i0 = adapters.begin(); _i0 != adapters.end(); ++_i0)
        {
            if((*_i0))
            {
                ::IceGrid::upCast((*_i0).get())->__addObject(_c);
            }
        }
    }
    {
        for(::IceGrid::InternalDbEnvDescriptorSeq::const_iterator _i0 = dbEnvs.begin(); _i0 != dbEnvs.end(); ++_i0)
        {
            if((*_i0))
            {
                ::IceGrid::upCast((*_i0).get())->__addObject(_c);
            }
        }
    }
}

void
IceGrid::InternalServerDescriptor::__gcClear()
{
    if(distrib)
    {
        if(::IceGrid::upCast(distrib.get())->__usesGC())
        {
            ::IceGrid::upCast(distrib.get())->__decRefUnsafe();
            distrib.__clearHandleUnsafe();
        }
        else
        {
            distrib = 0;
        }
    }
    {
        for(::IceGrid::InternalAdapterDescriptorSeq::iterator _i0 = adapters.begin(); _i0 != adapters.end(); ++_i0)
        {
            if((*_i0))
            {
                if(::IceGrid::upCast((*_i0).get())->__usesGC())
                {
                    ::IceGrid::upCast((*_i0).get())->__decRefUnsafe();
                    (*_i0).__clearHandleUnsafe();
                }
                else
                {
                    (*_i0) = 0;
                }
            }
        }
    }
    {
        for(::IceGrid::InternalDbEnvDescriptorSeq::iterator _i0 = dbEnvs.begin(); _i0 != dbEnvs.end(); ++_i0)
        {
            if((*_i0))
            {
                if(::IceGrid::upCast((*_i0).get())->__usesGC())
                {
                    ::IceGrid::upCast((*_i0).get())->__decRefUnsafe();
                    (*_i0).__clearHandleUnsafe();
                }
                else
                {
                    (*_i0) = 0;
                }
            }
        }
    }
}

void
IceGrid::InternalServerDescriptor::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(id);
    __os->write(application);
    __os->write(uuid);
    __os->write(revision);
    __os->write(sessionId);
    __os->write(exe);
    __os->write(pwd);
    __os->write(user);
    __os->write(activation);
    __os->write(activationTimeout);
    __os->write(deactivationTimeout);
    __os->write(applicationDistrib);
    __os->write(distrib);
    __os->write(processRegistered);
    __os->write(options);
    __os->write(envs);
    __os->write(logs);
    __os->write(adapters);
    __os->write(dbEnvs);
    __os->write(properties);
    __os->endWriteSlice();
}

void
IceGrid::InternalServerDescriptor::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(id);
    __is->read(application);
    __is->read(uuid);
    __is->read(revision);
    __is->read(sessionId);
    __is->read(exe);
    __is->read(pwd);
    __is->read(user);
    __is->read(activation);
    __is->read(activationTimeout);
    __is->read(deactivationTimeout);
    __is->read(applicationDistrib);
    __is->read(distrib);
    __is->read(processRegistered);
    __is->read(options);
    __is->read(envs);
    __is->read(logs);
    __is->read(adapters);
    __is->read(dbEnvs);
    __is->read(properties);
    __is->endReadSlice();
}

namespace
{

class __F__IceGrid__InternalServerDescriptor : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::IceGrid::InternalServerDescriptor::ice_staticId());
        return new ::IceGrid::InternalServerDescriptor;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__IceGrid__InternalServerDescriptor_Ptr = new __F__IceGrid__InternalServerDescriptor;

class __F__IceGrid__InternalServerDescriptor__Init
{
public:

    __F__IceGrid__InternalServerDescriptor__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::IceGrid::InternalServerDescriptor::ice_staticId(), __F__IceGrid__InternalServerDescriptor_Ptr);
    }

    ~__F__IceGrid__InternalServerDescriptor__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::IceGrid::InternalServerDescriptor::ice_staticId());
    }
};

const __F__IceGrid__InternalServerDescriptor__Init __F__IceGrid__InternalServerDescriptor__i;

}

const ::Ice::ObjectFactoryPtr&
IceGrid::InternalServerDescriptor::ice_factory()
{
    return __F__IceGrid__InternalServerDescriptor_Ptr;
}

void 
IceGrid::__patch(InternalServerDescriptorPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceGrid::InternalServerDescriptorPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceGrid::InternalServerDescriptor::ice_staticId(), v);
    }
}

::Ice::Object* IceGrid::upCast(::IceGrid::Adapter* p) { return p; }

namespace
{
const ::std::string __IceGrid__Adapter_ids[2] =
{
    "::Ice::Object",
    "::IceGrid::Adapter"
};

}

bool
IceGrid::Adapter::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceGrid__Adapter_ids, __IceGrid__Adapter_ids + 2, _s);
}

::std::vector< ::std::string>
IceGrid::Adapter::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceGrid__Adapter_ids[0], &__IceGrid__Adapter_ids[2]);
}

const ::std::string&
IceGrid::Adapter::ice_id(const ::Ice::Current&) const
{
    return __IceGrid__Adapter_ids[1];
}

const ::std::string&
IceGrid::Adapter::ice_staticId()
{
    return __IceGrid__Adapter_ids[1];
}

::Ice::DispatchStatus
IceGrid::Adapter::___activate(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::IceGrid::AMD_Adapter_activatePtr __cb = new IceAsync::IceGrid::AMD_Adapter_activate(__inS);
    try
    {
        activate_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
IceGrid::Adapter::___getDirectProxy(::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    try
    {
        ::Ice::ObjectPrx __ret = getDirectProxy(__current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::IceGrid::AdapterNotActiveException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
IceGrid::Adapter::___setDirectProxy(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    __inS.endReadParams();
    try
    {
        setDirectProxy(proxy, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::IceGrid::AdapterActiveException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __IceGrid__Adapter_all[] =
{
    "activate",
    "getDirectProxy",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "setDirectProxy"
};

}

::Ice::DispatchStatus
IceGrid::Adapter::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__IceGrid__Adapter_all, __IceGrid__Adapter_all + 7, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __IceGrid__Adapter_all)
    {
        case 0:
        {
            return ___activate(in, current);
        }
        case 1:
        {
            return ___getDirectProxy(in, current);
        }
        case 2:
        {
            return ___ice_id(in, current);
        }
        case 3:
        {
            return ___ice_ids(in, current);
        }
        case 4:
        {
            return ___ice_isA(in, current);
        }
        case 5:
        {
            return ___ice_ping(in, current);
        }
        case 6:
        {
            return ___setDirectProxy(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
IceGrid::Adapter::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
IceGrid::Adapter::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
IceGrid::__patch(AdapterPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceGrid::AdapterPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceGrid::Adapter::ice_staticId(), v);
    }
}

::Ice::Object* IceGrid::upCast(::IceGrid::FileReader* p) { return p; }

namespace
{
const ::std::string __IceGrid__FileReader_ids[2] =
{
    "::Ice::Object",
    "::IceGrid::FileReader"
};

}

bool
IceGrid::FileReader::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceGrid__FileReader_ids, __IceGrid__FileReader_ids + 2, _s);
}

::std::vector< ::std::string>
IceGrid::FileReader::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceGrid__FileReader_ids[0], &__IceGrid__FileReader_ids[2]);
}

const ::std::string&
IceGrid::FileReader::ice_id(const ::Ice::Current&) const
{
    return __IceGrid__FileReader_ids[1];
}

const ::std::string&
IceGrid::FileReader::ice_staticId()
{
    return __IceGrid__FileReader_ids[1];
}

::Ice::DispatchStatus
IceGrid::FileReader::___getOffsetFromEnd(::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string filename;
    ::Ice::Int lines;
    __is->read(filename);
    __is->read(lines);
    __inS.endReadParams();
    try
    {
        ::Ice::Long __ret = getOffsetFromEnd(filename, lines, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::IceGrid::FileNotAvailableException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
IceGrid::FileReader::___read(::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string filename;
    ::Ice::Long pos;
    ::Ice::Int size;
    __is->read(filename);
    __is->read(pos);
    __is->read(size);
    __inS.endReadParams();
    ::Ice::Long newPos;
    ::Ice::StringSeq lines;
    try
    {
        bool __ret = read(filename, pos, size, newPos, lines, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(newPos);
        __os->write(lines);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::IceGrid::FileNotAvailableException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __IceGrid__FileReader_all[] =
{
    "getOffsetFromEnd",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "read"
};

}

::Ice::DispatchStatus
IceGrid::FileReader::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__IceGrid__FileReader_all, __IceGrid__FileReader_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __IceGrid__FileReader_all)
    {
        case 0:
        {
            return ___getOffsetFromEnd(in, current);
        }
        case 1:
        {
            return ___ice_id(in, current);
        }
        case 2:
        {
            return ___ice_ids(in, current);
        }
        case 3:
        {
            return ___ice_isA(in, current);
        }
        case 4:
        {
            return ___ice_ping(in, current);
        }
        case 5:
        {
            return ___read(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
IceGrid::FileReader::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
IceGrid::FileReader::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
IceGrid::__patch(FileReaderPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceGrid::FileReaderPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceGrid::FileReader::ice_staticId(), v);
    }
}

::Ice::Object* IceGrid::upCast(::IceGrid::Server* p) { return p; }

namespace
{
const ::std::string __IceGrid__Server_ids[3] =
{
    "::Ice::Object",
    "::IceGrid::FileReader",
    "::IceGrid::Server"
};

}

bool
IceGrid::Server::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceGrid__Server_ids, __IceGrid__Server_ids + 3, _s);
}

::std::vector< ::std::string>
IceGrid::Server::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceGrid__Server_ids[0], &__IceGrid__Server_ids[3]);
}

const ::std::string&
IceGrid::Server::ice_id(const ::Ice::Current&) const
{
    return __IceGrid__Server_ids[2];
}

const ::std::string&
IceGrid::Server::ice_staticId()
{
    return __IceGrid__Server_ids[2];
}

::Ice::DispatchStatus
IceGrid::Server::___start(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::IceGrid::AMD_Server_startPtr __cb = new IceAsync::IceGrid::AMD_Server_start(__inS);
    try
    {
        start_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
IceGrid::Server::___stop(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::IceGrid::AMD_Server_stopPtr __cb = new IceAsync::IceGrid::AMD_Server_stop(__inS);
    try
    {
        stop_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
IceGrid::Server::___checkUpdate(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::IceGrid::InternalServerDescriptorPtr svr;
    bool noRestart;
    __is->read(svr);
    __is->read(noRestart);
    __is->readPendingObjects();
    __inS.endReadParams();
    try
    {
        bool __ret = checkUpdate(svr, noRestart, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::IceGrid::DeploymentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
IceGrid::Server::___setEnabled(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    bool enable;
    __is->read(enable);
    __inS.endReadParams();
    setEnabled(enable, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::Server::___isEnabled(::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    bool __ret = isEnabled(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::Server::___sendSignal(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string signal;
    __is->read(signal);
    __inS.endReadParams();
    try
    {
        sendSignal(signal, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::IceGrid::BadSignalException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
IceGrid::Server::___writeMessage(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string message;
    ::Ice::Int fd;
    __is->read(message);
    __is->read(fd);
    __inS.endReadParams();
    writeMessage(message, fd, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::Server::___getState(::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::IceGrid::ServerState __ret = getState(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::Server::___getPid(::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::Ice::Int __ret = getPid(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::Server::___setProcess(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::ProcessPrx proc;
    __is->read(proc);
    __inS.endReadParams();
    ::IceGrid::AMD_Server_setProcessPtr __cb = new IceAsync::IceGrid::AMD_Server_setProcess(__inS);
    try
    {
        setProcess_async(__cb, proc, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

namespace
{
const ::std::string __IceGrid__Server_all[] =
{
    "checkUpdate",
    "getOffsetFromEnd",
    "getPid",
    "getState",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "isEnabled",
    "read",
    "sendSignal",
    "setEnabled",
    "setProcess",
    "start",
    "stop",
    "writeMessage"
};

}

::Ice::DispatchStatus
IceGrid::Server::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__IceGrid__Server_all, __IceGrid__Server_all + 16, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __IceGrid__Server_all)
    {
        case 0:
        {
            return ___checkUpdate(in, current);
        }
        case 1:
        {
            return ___getOffsetFromEnd(in, current);
        }
        case 2:
        {
            return ___getPid(in, current);
        }
        case 3:
        {
            return ___getState(in, current);
        }
        case 4:
        {
            return ___ice_id(in, current);
        }
        case 5:
        {
            return ___ice_ids(in, current);
        }
        case 6:
        {
            return ___ice_isA(in, current);
        }
        case 7:
        {
            return ___ice_ping(in, current);
        }
        case 8:
        {
            return ___isEnabled(in, current);
        }
        case 9:
        {
            return ___read(in, current);
        }
        case 10:
        {
            return ___sendSignal(in, current);
        }
        case 11:
        {
            return ___setEnabled(in, current);
        }
        case 12:
        {
            return ___setProcess(in, current);
        }
        case 13:
        {
            return ___start(in, current);
        }
        case 14:
        {
            return ___stop(in, current);
        }
        case 15:
        {
            return ___writeMessage(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
IceGrid::Server::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
IceGrid::Server::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
IceGrid::__patch(ServerPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceGrid::ServerPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceGrid::Server::ice_staticId(), v);
    }
}

::Ice::Object* IceGrid::upCast(::IceGrid::ReplicaObserver* p) { return p; }

namespace
{
const ::std::string __IceGrid__ReplicaObserver_ids[2] =
{
    "::Ice::Object",
    "::IceGrid::ReplicaObserver"
};

}

bool
IceGrid::ReplicaObserver::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceGrid__ReplicaObserver_ids, __IceGrid__ReplicaObserver_ids + 2, _s);
}

::std::vector< ::std::string>
IceGrid::ReplicaObserver::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceGrid__ReplicaObserver_ids[0], &__IceGrid__ReplicaObserver_ids[2]);
}

const ::std::string&
IceGrid::ReplicaObserver::ice_id(const ::Ice::Current&) const
{
    return __IceGrid__ReplicaObserver_ids[1];
}

const ::std::string&
IceGrid::ReplicaObserver::ice_staticId()
{
    return __IceGrid__ReplicaObserver_ids[1];
}

::Ice::DispatchStatus
IceGrid::ReplicaObserver::___replicaInit(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::IceGrid::InternalRegistryPrxSeq replicas;
    __is->read(replicas);
    __inS.endReadParams();
    replicaInit(replicas, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::ReplicaObserver::___replicaAdded(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::IceGrid::InternalRegistryPrx replica;
    __is->read(replica);
    __inS.endReadParams();
    replicaAdded(replica, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::ReplicaObserver::___replicaRemoved(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::IceGrid::InternalRegistryPrx replica;
    __is->read(replica);
    __inS.endReadParams();
    replicaRemoved(replica, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __IceGrid__ReplicaObserver_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "replicaAdded",
    "replicaInit",
    "replicaRemoved"
};

}

::Ice::DispatchStatus
IceGrid::ReplicaObserver::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__IceGrid__ReplicaObserver_all, __IceGrid__ReplicaObserver_all + 7, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __IceGrid__ReplicaObserver_all)
    {
        case 0:
        {
            return ___ice_id(in, current);
        }
        case 1:
        {
            return ___ice_ids(in, current);
        }
        case 2:
        {
            return ___ice_isA(in, current);
        }
        case 3:
        {
            return ___ice_ping(in, current);
        }
        case 4:
        {
            return ___replicaAdded(in, current);
        }
        case 5:
        {
            return ___replicaInit(in, current);
        }
        case 6:
        {
            return ___replicaRemoved(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
IceGrid::ReplicaObserver::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
IceGrid::ReplicaObserver::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
IceGrid::__patch(ReplicaObserverPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceGrid::ReplicaObserverPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceGrid::ReplicaObserver::ice_staticId(), v);
    }
}

::Ice::Object* IceGrid::upCast(::IceGrid::PatcherFeedback* p) { return p; }

namespace
{
const ::std::string __IceGrid__PatcherFeedback_ids[2] =
{
    "::Ice::Object",
    "::IceGrid::PatcherFeedback"
};

}

bool
IceGrid::PatcherFeedback::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceGrid__PatcherFeedback_ids, __IceGrid__PatcherFeedback_ids + 2, _s);
}

::std::vector< ::std::string>
IceGrid::PatcherFeedback::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceGrid__PatcherFeedback_ids[0], &__IceGrid__PatcherFeedback_ids[2]);
}

const ::std::string&
IceGrid::PatcherFeedback::ice_id(const ::Ice::Current&) const
{
    return __IceGrid__PatcherFeedback_ids[1];
}

const ::std::string&
IceGrid::PatcherFeedback::ice_staticId()
{
    return __IceGrid__PatcherFeedback_ids[1];
}

::Ice::DispatchStatus
IceGrid::PatcherFeedback::___finished(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    finished(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::PatcherFeedback::___failed(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string reason;
    __is->read(reason);
    __inS.endReadParams();
    failed(reason, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __IceGrid__PatcherFeedback_all[] =
{
    "failed",
    "finished",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
IceGrid::PatcherFeedback::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__IceGrid__PatcherFeedback_all, __IceGrid__PatcherFeedback_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __IceGrid__PatcherFeedback_all)
    {
        case 0:
        {
            return ___failed(in, current);
        }
        case 1:
        {
            return ___finished(in, current);
        }
        case 2:
        {
            return ___ice_id(in, current);
        }
        case 3:
        {
            return ___ice_ids(in, current);
        }
        case 4:
        {
            return ___ice_isA(in, current);
        }
        case 5:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
IceGrid::PatcherFeedback::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
IceGrid::PatcherFeedback::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
IceGrid::__patch(PatcherFeedbackPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceGrid::PatcherFeedbackPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceGrid::PatcherFeedback::ice_staticId(), v);
    }
}

::Ice::Object* IceGrid::upCast(::IceGrid::Node* p) { return p; }

namespace
{
const ::std::string __IceGrid__Node_ids[4] =
{
    "::Ice::Object",
    "::IceGrid::FileReader",
    "::IceGrid::Node",
    "::IceGrid::ReplicaObserver"
};

}

bool
IceGrid::Node::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceGrid__Node_ids, __IceGrid__Node_ids + 4, _s);
}

::std::vector< ::std::string>
IceGrid::Node::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceGrid__Node_ids[0], &__IceGrid__Node_ids[4]);
}

const ::std::string&
IceGrid::Node::ice_id(const ::Ice::Current&) const
{
    return __IceGrid__Node_ids[2];
}

const ::std::string&
IceGrid::Node::ice_staticId()
{
    return __IceGrid__Node_ids[2];
}

::Ice::DispatchStatus
IceGrid::Node::___loadServer(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::IceGrid::InternalServerDescriptorPtr svr;
    ::std::string replicaName;
    __is->read(svr);
    __is->read(replicaName);
    __is->readPendingObjects();
    __inS.endReadParams();
    ::IceGrid::AMD_Node_loadServerPtr __cb = new IceAsync::IceGrid::AMD_Node_loadServer(__inS);
    try
    {
        loadServer_async(__cb, svr, replicaName, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
IceGrid::Node::___loadServerWithoutRestart(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::IceGrid::InternalServerDescriptorPtr svr;
    ::std::string replicaName;
    __is->read(svr);
    __is->read(replicaName);
    __is->readPendingObjects();
    __inS.endReadParams();
    ::IceGrid::AMD_Node_loadServerWithoutRestartPtr __cb = new IceAsync::IceGrid::AMD_Node_loadServerWithoutRestart(__inS);
    try
    {
        loadServerWithoutRestart_async(__cb, svr, replicaName, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
IceGrid::Node::___destroyServer(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string name;
    ::std::string uuid;
    ::Ice::Int revision;
    ::std::string replicaName;
    __is->read(name);
    __is->read(uuid);
    __is->read(revision);
    __is->read(replicaName);
    __inS.endReadParams();
    ::IceGrid::AMD_Node_destroyServerPtr __cb = new IceAsync::IceGrid::AMD_Node_destroyServer(__inS);
    try
    {
        destroyServer_async(__cb, name, uuid, revision, replicaName, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
IceGrid::Node::___patch(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::IceGrid::PatcherFeedbackPrx feedback;
    ::std::string application;
    ::std::string server;
    ::IceGrid::InternalDistributionDescriptorPtr appDistrib;
    bool shutdown;
    __is->read(feedback);
    __is->read(application);
    __is->read(server);
    __is->read(appDistrib);
    __is->read(shutdown);
    __is->readPendingObjects();
    __inS.endReadParams();
    ::IceGrid::AMD_Node_patchPtr __cb = new IceAsync::IceGrid::AMD_Node_patch(__inS);
    try
    {
        patch_async(__cb, feedback, application, server, appDistrib, shutdown, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
IceGrid::Node::___registerWithReplica(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::IceGrid::InternalRegistryPrx replica;
    __is->read(replica);
    __inS.endReadParams();
    registerWithReplica(replica, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::Node::___getName(::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::std::string __ret = getName(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::Node::___getHostname(::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::std::string __ret = getHostname(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::Node::___getLoad(::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::IceGrid::LoadInfo __ret = getLoad(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::Node::___getProcessorSocketCount(::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::Ice::Int __ret = getProcessorSocketCount(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::Node::___shutdown(::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    shutdown(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __IceGrid__Node_all[] =
{
    "destroyServer",
    "getHostname",
    "getLoad",
    "getName",
    "getOffsetFromEnd",
    "getProcessorSocketCount",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "loadServer",
    "loadServerWithoutRestart",
    "patch",
    "read",
    "registerWithReplica",
    "replicaAdded",
    "replicaInit",
    "replicaRemoved",
    "shutdown"
};

}

::Ice::DispatchStatus
IceGrid::Node::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__IceGrid__Node_all, __IceGrid__Node_all + 19, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __IceGrid__Node_all)
    {
        case 0:
        {
            return ___destroyServer(in, current);
        }
        case 1:
        {
            return ___getHostname(in, current);
        }
        case 2:
        {
            return ___getLoad(in, current);
        }
        case 3:
        {
            return ___getName(in, current);
        }
        case 4:
        {
            return ___getOffsetFromEnd(in, current);
        }
        case 5:
        {
            return ___getProcessorSocketCount(in, current);
        }
        case 6:
        {
            return ___ice_id(in, current);
        }
        case 7:
        {
            return ___ice_ids(in, current);
        }
        case 8:
        {
            return ___ice_isA(in, current);
        }
        case 9:
        {
            return ___ice_ping(in, current);
        }
        case 10:
        {
            return ___loadServer(in, current);
        }
        case 11:
        {
            return ___loadServerWithoutRestart(in, current);
        }
        case 12:
        {
            return ___patch(in, current);
        }
        case 13:
        {
            return ___read(in, current);
        }
        case 14:
        {
            return ___registerWithReplica(in, current);
        }
        case 15:
        {
            return ___replicaAdded(in, current);
        }
        case 16:
        {
            return ___replicaInit(in, current);
        }
        case 17:
        {
            return ___replicaRemoved(in, current);
        }
        case 18:
        {
            return ___shutdown(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
IceGrid::Node::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
IceGrid::Node::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
IceGrid::__patch(NodePtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceGrid::NodePtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceGrid::Node::ice_staticId(), v);
    }
}

::Ice::Object* IceGrid::upCast(::IceGrid::NodeSession* p) { return p; }

namespace
{
const ::std::string __IceGrid__NodeSession_ids[2] =
{
    "::Ice::Object",
    "::IceGrid::NodeSession"
};

}

bool
IceGrid::NodeSession::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceGrid__NodeSession_ids, __IceGrid__NodeSession_ids + 2, _s);
}

::std::vector< ::std::string>
IceGrid::NodeSession::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceGrid__NodeSession_ids[0], &__IceGrid__NodeSession_ids[2]);
}

const ::std::string&
IceGrid::NodeSession::ice_id(const ::Ice::Current&) const
{
    return __IceGrid__NodeSession_ids[1];
}

const ::std::string&
IceGrid::NodeSession::ice_staticId()
{
    return __IceGrid__NodeSession_ids[1];
}

::Ice::DispatchStatus
IceGrid::NodeSession::___keepAlive(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::IceGrid::LoadInfo load;
    __is->read(load);
    __inS.endReadParams();
    keepAlive(load, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::NodeSession::___setReplicaObserver(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::IceGrid::ReplicaObserverPrx observer;
    __is->read(observer);
    __inS.endReadParams();
    setReplicaObserver(observer, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::NodeSession::___getTimeout(::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::Ice::Int __ret = getTimeout(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::NodeSession::___getObserver(::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::IceGrid::NodeObserverPrx __ret = getObserver(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::NodeSession::___loadServers(::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::IceGrid::AMD_NodeSession_loadServersPtr __cb = new IceAsync::IceGrid::AMD_NodeSession_loadServers(__inS);
    try
    {
        loadServers_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
IceGrid::NodeSession::___getServers(::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::Ice::StringSeq __ret = getServers(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::NodeSession::___waitForApplicationUpdate(::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string application;
    ::Ice::Int revision;
    __is->read(application);
    __is->read(revision);
    __inS.endReadParams();
    ::IceGrid::AMD_NodeSession_waitForApplicationUpdatePtr __cb = new IceAsync::IceGrid::AMD_NodeSession_waitForApplicationUpdate(__inS);
    try
    {
        waitForApplicationUpdate_async(__cb, application, revision, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
IceGrid::NodeSession::___destroy(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    destroy(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __IceGrid__NodeSession_all[] =
{
    "destroy",
    "getObserver",
    "getServers",
    "getTimeout",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "keepAlive",
    "loadServers",
    "setReplicaObserver",
    "waitForApplicationUpdate"
};

}

::Ice::DispatchStatus
IceGrid::NodeSession::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__IceGrid__NodeSession_all, __IceGrid__NodeSession_all + 12, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __IceGrid__NodeSession_all)
    {
        case 0:
        {
            return ___destroy(in, current);
        }
        case 1:
        {
            return ___getObserver(in, current);
        }
        case 2:
        {
            return ___getServers(in, current);
        }
        case 3:
        {
            return ___getTimeout(in, current);
        }
        case 4:
        {
            return ___ice_id(in, current);
        }
        case 5:
        {
            return ___ice_ids(in, current);
        }
        case 6:
        {
            return ___ice_isA(in, current);
        }
        case 7:
        {
            return ___ice_ping(in, current);
        }
        case 8:
        {
            return ___keepAlive(in, current);
        }
        case 9:
        {
            return ___loadServers(in, current);
        }
        case 10:
        {
            return ___setReplicaObserver(in, current);
        }
        case 11:
        {
            return ___waitForApplicationUpdate(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
IceGrid::NodeSession::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
IceGrid::NodeSession::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
IceGrid::__patch(NodeSessionPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceGrid::NodeSessionPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceGrid::NodeSession::ice_staticId(), v);
    }
}

::Ice::Object* IceGrid::upCast(::IceGrid::DatabaseObserver* p) { return p; }

namespace
{
const ::std::string __IceGrid__DatabaseObserver_ids[5] =
{
    "::Ice::Object",
    "::IceGrid::AdapterObserver",
    "::IceGrid::ApplicationObserver",
    "::IceGrid::DatabaseObserver",
    "::IceGrid::ObjectObserver"
};

}

bool
IceGrid::DatabaseObserver::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceGrid__DatabaseObserver_ids, __IceGrid__DatabaseObserver_ids + 5, _s);
}

::std::vector< ::std::string>
IceGrid::DatabaseObserver::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceGrid__DatabaseObserver_ids[0], &__IceGrid__DatabaseObserver_ids[5]);
}

const ::std::string&
IceGrid::DatabaseObserver::ice_id(const ::Ice::Current&) const
{
    return __IceGrid__DatabaseObserver_ids[3];
}

const ::std::string&
IceGrid::DatabaseObserver::ice_staticId()
{
    return __IceGrid__DatabaseObserver_ids[3];
}

namespace
{
const ::std::string __IceGrid__DatabaseObserver_all[] =
{
    "adapterAdded",
    "adapterInit",
    "adapterRemoved",
    "adapterUpdated",
    "applicationAdded",
    "applicationInit",
    "applicationRemoved",
    "applicationUpdated",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "objectAdded",
    "objectInit",
    "objectRemoved",
    "objectUpdated"
};

}

::Ice::DispatchStatus
IceGrid::DatabaseObserver::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__IceGrid__DatabaseObserver_all, __IceGrid__DatabaseObserver_all + 16, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __IceGrid__DatabaseObserver_all)
    {
        case 0:
        {
            return ___adapterAdded(in, current);
        }
        case 1:
        {
            return ___adapterInit(in, current);
        }
        case 2:
        {
            return ___adapterRemoved(in, current);
        }
        case 3:
        {
            return ___adapterUpdated(in, current);
        }
        case 4:
        {
            return ___applicationAdded(in, current);
        }
        case 5:
        {
            return ___applicationInit(in, current);
        }
        case 6:
        {
            return ___applicationRemoved(in, current);
        }
        case 7:
        {
            return ___applicationUpdated(in, current);
        }
        case 8:
        {
            return ___ice_id(in, current);
        }
        case 9:
        {
            return ___ice_ids(in, current);
        }
        case 10:
        {
            return ___ice_isA(in, current);
        }
        case 11:
        {
            return ___ice_ping(in, current);
        }
        case 12:
        {
            return ___objectAdded(in, current);
        }
        case 13:
        {
            return ___objectInit(in, current);
        }
        case 14:
        {
            return ___objectRemoved(in, current);
        }
        case 15:
        {
            return ___objectUpdated(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
IceGrid::DatabaseObserver::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
IceGrid::DatabaseObserver::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
IceGrid::__patch(DatabaseObserverPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceGrid::DatabaseObserverPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceGrid::DatabaseObserver::ice_staticId(), v);
    }
}

::Ice::Object* IceGrid::upCast(::IceGrid::ReplicaSession* p) { return p; }

namespace
{
const ::std::string __IceGrid__ReplicaSession_ids[2] =
{
    "::Ice::Object",
    "::IceGrid::ReplicaSession"
};

}

bool
IceGrid::ReplicaSession::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceGrid__ReplicaSession_ids, __IceGrid__ReplicaSession_ids + 2, _s);
}

::std::vector< ::std::string>
IceGrid::ReplicaSession::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceGrid__ReplicaSession_ids[0], &__IceGrid__ReplicaSession_ids[2]);
}

const ::std::string&
IceGrid::ReplicaSession::ice_id(const ::Ice::Current&) const
{
    return __IceGrid__ReplicaSession_ids[1];
}

const ::std::string&
IceGrid::ReplicaSession::ice_staticId()
{
    return __IceGrid__ReplicaSession_ids[1];
}

::Ice::DispatchStatus
IceGrid::ReplicaSession::___keepAlive(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    keepAlive(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::ReplicaSession::___getTimeout(::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::Ice::Int __ret = getTimeout(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::ReplicaSession::___setDatabaseObserver(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::IceGrid::DatabaseObserverPrx dbObs;
    IceUtil::Optional< ::IceGrid::StringLongDict> serials;
    __is->read(dbObs);
    __is->read(1, serials);
    __inS.endReadParams();
    try
    {
        setDatabaseObserver(dbObs, serials, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::IceGrid::DeploymentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    catch(const ::IceGrid::ObserverAlreadyRegisteredException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
IceGrid::ReplicaSession::___setEndpoints(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::IceGrid::StringObjectProxyDict endpoints;
    __is->read(endpoints);
    __inS.endReadParams();
    setEndpoints(endpoints, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::ReplicaSession::___registerWellKnownObjects(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::IceGrid::ObjectInfoSeq objects;
    __is->read(objects);
    __inS.endReadParams();
    registerWellKnownObjects(objects, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::ReplicaSession::___setAdapterDirectProxy(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string adapterId;
    ::std::string replicaGroupId;
    ::Ice::ObjectPrx proxy;
    __is->read(adapterId);
    __is->read(replicaGroupId);
    __is->read(proxy);
    __inS.endReadParams();
    try
    {
        setAdapterDirectProxy(adapterId, replicaGroupId, proxy, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::IceGrid::AdapterExistsException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    catch(const ::IceGrid::AdapterNotExistException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
IceGrid::ReplicaSession::___receivedUpdate(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::IceGrid::TopicName name;
    ::Ice::Int serial;
    ::std::string failure;
    __is->read(name);
    __is->read(serial);
    __is->read(failure);
    __inS.endReadParams();
    receivedUpdate(name, serial, failure, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::ReplicaSession::___destroy(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    destroy(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __IceGrid__ReplicaSession_all[] =
{
    "destroy",
    "getTimeout",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "keepAlive",
    "receivedUpdate",
    "registerWellKnownObjects",
    "setAdapterDirectProxy",
    "setDatabaseObserver",
    "setEndpoints"
};

}

::Ice::DispatchStatus
IceGrid::ReplicaSession::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__IceGrid__ReplicaSession_all, __IceGrid__ReplicaSession_all + 12, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __IceGrid__ReplicaSession_all)
    {
        case 0:
        {
            return ___destroy(in, current);
        }
        case 1:
        {
            return ___getTimeout(in, current);
        }
        case 2:
        {
            return ___ice_id(in, current);
        }
        case 3:
        {
            return ___ice_ids(in, current);
        }
        case 4:
        {
            return ___ice_isA(in, current);
        }
        case 5:
        {
            return ___ice_ping(in, current);
        }
        case 6:
        {
            return ___keepAlive(in, current);
        }
        case 7:
        {
            return ___receivedUpdate(in, current);
        }
        case 8:
        {
            return ___registerWellKnownObjects(in, current);
        }
        case 9:
        {
            return ___setAdapterDirectProxy(in, current);
        }
        case 10:
        {
            return ___setDatabaseObserver(in, current);
        }
        case 11:
        {
            return ___setEndpoints(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
IceGrid::ReplicaSession::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
IceGrid::ReplicaSession::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
IceGrid::__patch(ReplicaSessionPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceGrid::ReplicaSessionPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceGrid::ReplicaSession::ice_staticId(), v);
    }
}

::Ice::Object* IceGrid::upCast(::IceGrid::InternalNodeInfo* p) { return p; }
::Ice::ObjectPtr
IceGrid::InternalNodeInfo::ice_clone() const
{
    ::Ice::Object* __p = new InternalNodeInfo(*this);
    return __p;
}

namespace
{
const ::std::string __IceGrid__InternalNodeInfo_ids[2] =
{
    "::Ice::Object",
    "::IceGrid::InternalNodeInfo"
};

}

bool
IceGrid::InternalNodeInfo::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceGrid__InternalNodeInfo_ids, __IceGrid__InternalNodeInfo_ids + 2, _s);
}

::std::vector< ::std::string>
IceGrid::InternalNodeInfo::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceGrid__InternalNodeInfo_ids[0], &__IceGrid__InternalNodeInfo_ids[2]);
}

const ::std::string&
IceGrid::InternalNodeInfo::ice_id(const ::Ice::Current&) const
{
    return __IceGrid__InternalNodeInfo_ids[1];
}

const ::std::string&
IceGrid::InternalNodeInfo::ice_staticId()
{
    return __IceGrid__InternalNodeInfo_ids[1];
}

void
IceGrid::InternalNodeInfo::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(name);
    __os->write(os);
    __os->write(hostname);
    __os->write(release);
    __os->write(version);
    __os->write(machine);
    __os->write(nProcessors);
    __os->write(dataDir);
    __os->endWriteSlice();
}

void
IceGrid::InternalNodeInfo::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(name);
    __is->read(os);
    __is->read(hostname);
    __is->read(release);
    __is->read(version);
    __is->read(machine);
    __is->read(nProcessors);
    __is->read(dataDir);
    __is->endReadSlice();
}

namespace
{

class __F__IceGrid__InternalNodeInfo : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::IceGrid::InternalNodeInfo::ice_staticId());
        return new ::IceGrid::InternalNodeInfo;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__IceGrid__InternalNodeInfo_Ptr = new __F__IceGrid__InternalNodeInfo;

class __F__IceGrid__InternalNodeInfo__Init
{
public:

    __F__IceGrid__InternalNodeInfo__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::IceGrid::InternalNodeInfo::ice_staticId(), __F__IceGrid__InternalNodeInfo_Ptr);
    }

    ~__F__IceGrid__InternalNodeInfo__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::IceGrid::InternalNodeInfo::ice_staticId());
    }
};

const __F__IceGrid__InternalNodeInfo__Init __F__IceGrid__InternalNodeInfo__i;

}

const ::Ice::ObjectFactoryPtr&
IceGrid::InternalNodeInfo::ice_factory()
{
    return __F__IceGrid__InternalNodeInfo_Ptr;
}

void 
IceGrid::__patch(InternalNodeInfoPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceGrid::InternalNodeInfoPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceGrid::InternalNodeInfo::ice_staticId(), v);
    }
}

::Ice::Object* IceGrid::upCast(::IceGrid::InternalReplicaInfo* p) { return p; }
::Ice::ObjectPtr
IceGrid::InternalReplicaInfo::ice_clone() const
{
    ::Ice::Object* __p = new InternalReplicaInfo(*this);
    return __p;
}

namespace
{
const ::std::string __IceGrid__InternalReplicaInfo_ids[2] =
{
    "::Ice::Object",
    "::IceGrid::InternalReplicaInfo"
};

}

bool
IceGrid::InternalReplicaInfo::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceGrid__InternalReplicaInfo_ids, __IceGrid__InternalReplicaInfo_ids + 2, _s);
}

::std::vector< ::std::string>
IceGrid::InternalReplicaInfo::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceGrid__InternalReplicaInfo_ids[0], &__IceGrid__InternalReplicaInfo_ids[2]);
}

const ::std::string&
IceGrid::InternalReplicaInfo::ice_id(const ::Ice::Current&) const
{
    return __IceGrid__InternalReplicaInfo_ids[1];
}

const ::std::string&
IceGrid::InternalReplicaInfo::ice_staticId()
{
    return __IceGrid__InternalReplicaInfo_ids[1];
}

void
IceGrid::InternalReplicaInfo::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(name);
    __os->write(hostname);
    __os->endWriteSlice();
}

void
IceGrid::InternalReplicaInfo::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(name);
    __is->read(hostname);
    __is->endReadSlice();
}

namespace
{

class __F__IceGrid__InternalReplicaInfo : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::IceGrid::InternalReplicaInfo::ice_staticId());
        return new ::IceGrid::InternalReplicaInfo;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__IceGrid__InternalReplicaInfo_Ptr = new __F__IceGrid__InternalReplicaInfo;

class __F__IceGrid__InternalReplicaInfo__Init
{
public:

    __F__IceGrid__InternalReplicaInfo__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::IceGrid::InternalReplicaInfo::ice_staticId(), __F__IceGrid__InternalReplicaInfo_Ptr);
    }

    ~__F__IceGrid__InternalReplicaInfo__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::IceGrid::InternalReplicaInfo::ice_staticId());
    }
};

const __F__IceGrid__InternalReplicaInfo__Init __F__IceGrid__InternalReplicaInfo__i;

}

const ::Ice::ObjectFactoryPtr&
IceGrid::InternalReplicaInfo::ice_factory()
{
    return __F__IceGrid__InternalReplicaInfo_Ptr;
}

void 
IceGrid::__patch(InternalReplicaInfoPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceGrid::InternalReplicaInfoPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceGrid::InternalReplicaInfo::ice_staticId(), v);
    }
}

::Ice::Object* IceGrid::upCast(::IceGrid::InternalRegistry* p) { return p; }

namespace
{
const ::std::string __IceGrid__InternalRegistry_ids[3] =
{
    "::Ice::Object",
    "::IceGrid::FileReader",
    "::IceGrid::InternalRegistry"
};

}

bool
IceGrid::InternalRegistry::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceGrid__InternalRegistry_ids, __IceGrid__InternalRegistry_ids + 3, _s);
}

::std::vector< ::std::string>
IceGrid::InternalRegistry::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceGrid__InternalRegistry_ids[0], &__IceGrid__InternalRegistry_ids[3]);
}

const ::std::string&
IceGrid::InternalRegistry::ice_id(const ::Ice::Current&) const
{
    return __IceGrid__InternalRegistry_ids[2];
}

const ::std::string&
IceGrid::InternalRegistry::ice_staticId()
{
    return __IceGrid__InternalRegistry_ids[2];
}

::Ice::DispatchStatus
IceGrid::InternalRegistry::___registerNode(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::IceGrid::InternalNodeInfoPtr info;
    ::IceGrid::NodePrx prx;
    ::IceGrid::LoadInfo loadInf;
    __is->read(info);
    __is->read(prx);
    __is->read(loadInf);
    __is->readPendingObjects();
    __inS.endReadParams();
    try
    {
        ::IceGrid::NodeSessionPrx __ret = registerNode(info, prx, loadInf, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::IceGrid::NodeActiveException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    catch(const ::IceGrid::PermissionDeniedException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
IceGrid::InternalRegistry::___registerReplica(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::IceGrid::InternalReplicaInfoPtr info;
    ::IceGrid::InternalRegistryPrx prx;
    __is->read(info);
    __is->read(prx);
    __is->readPendingObjects();
    __inS.endReadParams();
    try
    {
        ::IceGrid::ReplicaSessionPrx __ret = registerReplica(info, prx, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::IceGrid::PermissionDeniedException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    catch(const ::IceGrid::ReplicaActiveException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
IceGrid::InternalRegistry::___registerWithReplica(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::IceGrid::InternalRegistryPrx prx;
    __is->read(prx);
    __inS.endReadParams();
    registerWithReplica(prx, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::InternalRegistry::___getNodes(::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::IceGrid::NodePrxSeq __ret = getNodes(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::InternalRegistry::___getReplicas(::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::IceGrid::InternalRegistryPrxSeq __ret = getReplicas(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::InternalRegistry::___getApplications(::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::Ice::Long serial;
    ::IceGrid::ApplicationInfoSeq __ret = getApplications(serial, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(serial);
    __os->write(__ret);
    __os->writePendingObjects();
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::InternalRegistry::___getAdapters(::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::Ice::Long serial;
    ::IceGrid::AdapterInfoSeq __ret = getAdapters(serial, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(serial);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::InternalRegistry::___getObjects(::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::Ice::Long serial;
    ::IceGrid::ObjectInfoSeq __ret = getObjects(serial, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(serial);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceGrid::InternalRegistry::___shutdown(::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    shutdown(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __IceGrid__InternalRegistry_all[] =
{
    "getAdapters",
    "getApplications",
    "getNodes",
    "getObjects",
    "getOffsetFromEnd",
    "getReplicas",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "read",
    "registerNode",
    "registerReplica",
    "registerWithReplica",
    "shutdown"
};

}

::Ice::DispatchStatus
IceGrid::InternalRegistry::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__IceGrid__InternalRegistry_all, __IceGrid__InternalRegistry_all + 15, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __IceGrid__InternalRegistry_all)
    {
        case 0:
        {
            return ___getAdapters(in, current);
        }
        case 1:
        {
            return ___getApplications(in, current);
        }
        case 2:
        {
            return ___getNodes(in, current);
        }
        case 3:
        {
            return ___getObjects(in, current);
        }
        case 4:
        {
            return ___getOffsetFromEnd(in, current);
        }
        case 5:
        {
            return ___getReplicas(in, current);
        }
        case 6:
        {
            return ___ice_id(in, current);
        }
        case 7:
        {
            return ___ice_ids(in, current);
        }
        case 8:
        {
            return ___ice_isA(in, current);
        }
        case 9:
        {
            return ___ice_ping(in, current);
        }
        case 10:
        {
            return ___read(in, current);
        }
        case 11:
        {
            return ___registerNode(in, current);
        }
        case 12:
        {
            return ___registerReplica(in, current);
        }
        case 13:
        {
            return ___registerWithReplica(in, current);
        }
        case 14:
        {
            return ___shutdown(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
IceGrid::InternalRegistry::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
IceGrid::InternalRegistry::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
IceGrid::__patch(InternalRegistryPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceGrid::InternalRegistryPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceGrid::InternalRegistry::ice_staticId(), v);
    }
}

namespace
{

const char* __sliceChecksums[] =
{
    "::IceGrid::Adapter", "cdcea08d3ac862a3f37b45e93d3516cf",
    "::IceGrid::AdapterActiveException", "9e82c6f52ae5b9b3dded4da03c1e68e8",
    "::IceGrid::AdapterExistsException", "103296618e9b935090172ac4b2a3cd6",
    "::IceGrid::AdapterNotActiveException", "7632b297a062f716b967442ccdeb1d5",
    "::IceGrid::AdapterPrxDict", "b1ad556aafdb114dc2761db172cf99a",
    "::IceGrid::DatabaseObserver", "53301c4475ff93212867232dc1dc3279",
    "::IceGrid::FileReader", "34d7c15576824a7bb03f3a9bdebe9d3e",
    "::IceGrid::InternalAdapterDescriptor", "4f5dff85cb69f8828588d994955b9",
    "::IceGrid::InternalAdapterDescriptorSeq", "c8e25d41d9125509ce869edc97951ea",
    "::IceGrid::InternalDbEnvDescriptor", "43b063bd2ede5da688de887658298f6d",
    "::IceGrid::InternalDbEnvDescriptorSeq", "0c74f576958516b314146ab4522f90",
    "::IceGrid::InternalDistributionDescriptor", "6993cce3aedd64cff0c1be09f51663d",
    "::IceGrid::InternalNodeInfo", "f4c1cad7a934c6a5405e542f5597a6f",
    "::IceGrid::InternalRegistry", "3b5892a32cd95ad08e75581a51bd8b89",
    "::IceGrid::InternalRegistryPrxSeq", "58708c5e95bc51953e8aa915ef989f7a",
    "::IceGrid::InternalReplicaInfo", "83a38a194bb3a225b57fa7d3232c4f6",
    "::IceGrid::InternalServerDescriptor", "59ac3e29239c6da932b4d6d222a759",
    "::IceGrid::Node", "bf26d792ce8163df6521f29e2c15e81d",
    "::IceGrid::NodeActiveException", "ab256cead26199fac7d4cbaac2a372d",
    "::IceGrid::NodePrxSeq", "613421b8e9538ceadd9baeb198c83716",
    "::IceGrid::NodeSession", "b5106acfb96f34efc3f872265f179a7",
    "::IceGrid::PatcherFeedback", "b89b6c26e96a271336302120d3abb5b1",
    "::IceGrid::PropertyDescriptorSeqDict", "ff2c8d165b85af94f3869734b1477b0",
    "::IceGrid::ReplicaActiveException", "9a58f1c394a8e4356971cbb8c9aa27e6",
    "::IceGrid::ReplicaObserver", "282c75598b4b27f617e712d4c82610bf",
    "::IceGrid::ReplicaSession", "c493b0e621c9f243c9b196aa9ad6c45c",
    "::IceGrid::Server", "99edec4dc56fac19bacb4b78a27462",
    "::IceGrid::StringLongDict", "cba34f3c88284830366bea75d528ce9",
    "::IceGrid::TopicName", "81b0c4d6778ad5390ac9867409d486",
    0
};
const IceInternal::SliceChecksumInit __sliceChecksumInit(__sliceChecksums);

}
