// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `IceStormInternal.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef ICE_STORM_SERVICE_API_EXPORTS
#   define ICE_STORM_SERVICE_API_EXPORTS
#endif
#include <IceStorm/IceStormInternal.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/BasicStream.h>
#include <Ice/Object.h>
#include <IceUtil/Iterator.h>
#include <IceUtil/DisableWarnings.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace
{

const ::std::string __IceStorm__TopicLink__forward_name = "forward";

const ::std::string __IceStorm__TopicInternal__getLinkProxy_name = "getLinkProxy";

const ::std::string __IceStorm__TopicInternal__reap_name = "reap";

const ::std::string __IceStorm__TopicManagerInternal__getReplicaNode_name = "getReplicaNode";

}

namespace
{

const char* __IceStorm__ReapWouldBlock_name = "IceStorm::ReapWouldBlock";

struct __F__IceStorm__ReapWouldBlock : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::IceStorm::ReapWouldBlock();
    }
};

class __F__IceStorm__ReapWouldBlock__Init
{
public:

    __F__IceStorm__ReapWouldBlock__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::IceStorm::ReapWouldBlock", new __F__IceStorm__ReapWouldBlock);
    }

    ~__F__IceStorm__ReapWouldBlock__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::IceStorm::ReapWouldBlock");
    }
};

const __F__IceStorm__ReapWouldBlock__Init __F__IceStorm__ReapWouldBlock__i;

}

IceStorm::ReapWouldBlock::~ReapWouldBlock() throw()
{
}

::std::string
IceStorm::ReapWouldBlock::ice_name() const
{
    return __IceStorm__ReapWouldBlock_name;
}

IceStorm::ReapWouldBlock*
IceStorm::ReapWouldBlock::ice_clone() const
{
    return new ReapWouldBlock(*this);
}

void
IceStorm::ReapWouldBlock::ice_throw() const
{
    throw *this;
}

void
IceStorm::ReapWouldBlock::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::IceStorm::ReapWouldBlock", -1, true);
    __os->endWriteSlice();
}

void
IceStorm::ReapWouldBlock::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

namespace Ice
{
#ifdef ICE_HAS_DECLSPEC_IMPORT_EXPORT
template struct ICE_STORM_SERVICE_API StreamWriter< ::IceStorm::EventDataPtr, ::IceInternal::BasicStream>;
template struct ICE_STORM_SERVICE_API StreamReader< ::IceStorm::EventDataPtr, ::IceInternal::BasicStream>;
#endif
}
#ifdef __SUNPRO_CC
class ICE_DECLSPEC_EXPORT IceProxy::IceStorm::TopicLink;
#endif
ICE_DECLSPEC_EXPORT ::IceProxy::Ice::Object* ::IceProxy::IceStorm::upCast(::IceProxy::IceStorm::TopicLink* p) { return p; }

void
::IceProxy::IceStorm::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceStorm::TopicLink>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceStorm::TopicLink;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::IceStorm::TopicLink::forward(const ::IceStorm::EventDataSeq& events, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceStorm__TopicLink__forward_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceStorm::TopicLink* __del = dynamic_cast< ::IceDelegate::IceStorm::TopicLink*>(__delBase.get());
            __del->forward(events, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceStorm::TopicLink::begin_forward(const ::IceStorm::EventDataSeq& events, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceStorm__TopicLink__forward_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceStorm__TopicLink__forward_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(events);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceStorm::TopicLink::end_forward(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceStorm__TopicLink__forward_name);
}

const ::std::string&
IceProxy::IceStorm::TopicLink::ice_staticId()
{
    return ::IceStorm::TopicLink::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceStorm::TopicLink::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceStorm::TopicLink);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceStorm::TopicLink::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceStorm::TopicLink);
}

::IceProxy::Ice::Object*
IceProxy::IceStorm::TopicLink::__newInstance() const
{
    return new TopicLink;
}
#ifdef __SUNPRO_CC
class ICE_DECLSPEC_EXPORT IceProxy::IceStorm::TopicInternal;
#endif
ICE_DECLSPEC_EXPORT ::IceProxy::Ice::Object* ::IceProxy::IceStorm::upCast(::IceProxy::IceStorm::TopicInternal* p) { return p; }

void
::IceProxy::IceStorm::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceStorm::TopicInternal>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceStorm::TopicInternal;
        v->__copyFrom(proxy);
    }
}

::IceStorm::TopicLinkPrx
IceProxy::IceStorm::TopicInternal::getLinkProxy(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceStorm__TopicInternal__getLinkProxy_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceStorm__TopicInternal__getLinkProxy_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceStorm::TopicInternal* __del = dynamic_cast< ::IceDelegate::IceStorm::TopicInternal*>(__delBase.get());
            return __del->getLinkProxy(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceStorm::TopicInternal::begin_getLinkProxy(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceStorm__TopicInternal__getLinkProxy_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceStorm__TopicInternal__getLinkProxy_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceStorm__TopicInternal__getLinkProxy_name, ::Ice::Idempotent, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::IceStorm::TopicLinkPrx
IceProxy::IceStorm::TopicInternal::end_getLinkProxy(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceStorm__TopicInternal__getLinkProxy_name);
    ::IceStorm::TopicLinkPrx __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::IceStorm::TopicInternal::reap(const ::Ice::IdentitySeq& id, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceStorm__TopicInternal__reap_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceStorm__TopicInternal__reap_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceStorm::TopicInternal* __del = dynamic_cast< ::IceDelegate::IceStorm::TopicInternal*>(__delBase.get());
            __del->reap(id, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceStorm::TopicInternal::begin_reap(const ::Ice::IdentitySeq& id, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceStorm__TopicInternal__reap_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceStorm__TopicInternal__reap_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceStorm__TopicInternal__reap_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(id);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceStorm::TopicInternal::end_reap(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceStorm__TopicInternal__reap_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::IceStorm::ReapWouldBlock&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::IceStorm::TopicInternal::ice_staticId()
{
    return ::IceStorm::TopicInternal::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceStorm::TopicInternal::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceStorm::TopicInternal);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceStorm::TopicInternal::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceStorm::TopicInternal);
}

::IceProxy::Ice::Object*
IceProxy::IceStorm::TopicInternal::__newInstance() const
{
    return new TopicInternal;
}
#ifdef __SUNPRO_CC
class ICE_DECLSPEC_EXPORT IceProxy::IceStorm::TopicManagerInternal;
#endif
ICE_DECLSPEC_EXPORT ::IceProxy::Ice::Object* ::IceProxy::IceStorm::upCast(::IceProxy::IceStorm::TopicManagerInternal* p) { return p; }

void
::IceProxy::IceStorm::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceStorm::TopicManagerInternal>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceStorm::TopicManagerInternal;
        v->__copyFrom(proxy);
    }
}

::IceStormElection::NodePrx
IceProxy::IceStorm::TopicManagerInternal::getReplicaNode(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceStorm__TopicManagerInternal__getReplicaNode_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceStorm__TopicManagerInternal__getReplicaNode_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceStorm::TopicManagerInternal* __del = dynamic_cast< ::IceDelegate::IceStorm::TopicManagerInternal*>(__delBase.get());
            return __del->getReplicaNode(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceStorm::TopicManagerInternal::begin_getReplicaNode(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceStorm__TopicManagerInternal__getReplicaNode_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceStorm__TopicManagerInternal__getReplicaNode_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceStorm__TopicManagerInternal__getReplicaNode_name, ::Ice::Idempotent, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::IceStormElection::NodePrx
IceProxy::IceStorm::TopicManagerInternal::end_getReplicaNode(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceStorm__TopicManagerInternal__getReplicaNode_name);
    ::IceStormElection::NodePrx __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::IceStorm::TopicManagerInternal::ice_staticId()
{
    return ::IceStorm::TopicManagerInternal::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceStorm::TopicManagerInternal::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceStorm::TopicManagerInternal);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceStorm::TopicManagerInternal::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceStorm::TopicManagerInternal);
}

::IceProxy::Ice::Object*
IceProxy::IceStorm::TopicManagerInternal::__newInstance() const
{
    return new TopicManagerInternal;
}

void
IceDelegateM::IceStorm::TopicLink::forward(const ::IceStorm::EventDataSeq& events, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceStorm__TopicLink__forward_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(events);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::IceStorm::TopicLinkPrx
IceDelegateM::IceStorm::TopicInternal::getLinkProxy(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceStorm__TopicInternal__getLinkProxy_name, ::Ice::Idempotent, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::IceStorm::TopicLinkPrx __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::IceStorm::TopicInternal::reap(const ::Ice::IdentitySeq& id, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceStorm__TopicInternal__reap_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(id);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::IceStorm::ReapWouldBlock&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::IceStormElection::NodePrx
IceDelegateM::IceStorm::TopicManagerInternal::getReplicaNode(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceStorm__TopicManagerInternal__getReplicaNode_name, ::Ice::Idempotent, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::IceStormElection::NodePrx __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateD::IceStorm::TopicLink::forward(const ::IceStorm::EventDataSeq& events, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::IceStorm::EventDataSeq& __p_events, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_events(__p_events)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceStorm::TopicLink* servant = dynamic_cast< ::IceStorm::TopicLink*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->forward(_m_events, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::IceStorm::EventDataSeq& _m_events;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceStorm__TopicLink__forward_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(events, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::IceStorm::TopicLinkPrx
IceDelegateD::IceStorm::TopicInternal::getLinkProxy(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::IceStorm::TopicLinkPrx& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceStorm::TopicInternal* servant = dynamic_cast< ::IceStorm::TopicInternal*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getLinkProxy(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::IceStorm::TopicLinkPrx& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceStorm__TopicInternal__getLinkProxy_name, ::Ice::Idempotent, __context);
    ::IceStorm::TopicLinkPrx __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::IceStorm::TopicInternal::reap(const ::Ice::IdentitySeq& id, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::IdentitySeq& __p_id, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_id(__p_id)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceStorm::TopicInternal* servant = dynamic_cast< ::IceStorm::TopicInternal*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->reap(_m_id, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::Ice::IdentitySeq& _m_id;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceStorm__TopicInternal__reap_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(id, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::IceStorm::ReapWouldBlock&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::IceStormElection::NodePrx
IceDelegateD::IceStorm::TopicManagerInternal::getReplicaNode(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::IceStormElection::NodePrx& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceStorm::TopicManagerInternal* servant = dynamic_cast< ::IceStorm::TopicManagerInternal*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getReplicaNode(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::IceStormElection::NodePrx& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceStorm__TopicManagerInternal__getReplicaNode_name, ::Ice::Idempotent, __context);
    ::IceStormElection::NodePrx __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

ICE_DECLSPEC_EXPORT ::Ice::Object* IceStorm::upCast(::IceStorm::TopicLink* p) { return p; }

namespace
{
const ::std::string __IceStorm__TopicLink_ids[2] =
{
    "::Ice::Object",
    "::IceStorm::TopicLink"
};

}

bool
IceStorm::TopicLink::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceStorm__TopicLink_ids, __IceStorm__TopicLink_ids + 2, _s);
}

::std::vector< ::std::string>
IceStorm::TopicLink::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceStorm__TopicLink_ids[0], &__IceStorm__TopicLink_ids[2]);
}

const ::std::string&
IceStorm::TopicLink::ice_id(const ::Ice::Current&) const
{
    return __IceStorm__TopicLink_ids[1];
}

const ::std::string&
IceStorm::TopicLink::ice_staticId()
{
    return __IceStorm__TopicLink_ids[1];
}

::Ice::DispatchStatus
IceStorm::TopicLink::___forward(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::IceStorm::EventDataSeq events;
    __is->read(events);
    __inS.endReadParams();
    forward(events, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __IceStorm__TopicLink_all[] =
{
    "forward",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
IceStorm::TopicLink::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__IceStorm__TopicLink_all, __IceStorm__TopicLink_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __IceStorm__TopicLink_all)
    {
        case 0:
        {
            return ___forward(in, current);
        }
        case 1:
        {
            return ___ice_id(in, current);
        }
        case 2:
        {
            return ___ice_ids(in, current);
        }
        case 3:
        {
            return ___ice_isA(in, current);
        }
        case 4:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
IceStorm::TopicLink::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
IceStorm::TopicLink::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void ICE_DECLSPEC_EXPORT 
IceStorm::__patch(TopicLinkPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceStorm::TopicLinkPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceStorm::TopicLink::ice_staticId(), v);
    }
}

ICE_DECLSPEC_EXPORT ::Ice::Object* IceStorm::upCast(::IceStorm::TopicInternal* p) { return p; }

namespace
{
const ::std::string __IceStorm__TopicInternal_ids[3] =
{
    "::Ice::Object",
    "::IceStorm::Topic",
    "::IceStorm::TopicInternal"
};

}

bool
IceStorm::TopicInternal::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceStorm__TopicInternal_ids, __IceStorm__TopicInternal_ids + 3, _s);
}

::std::vector< ::std::string>
IceStorm::TopicInternal::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceStorm__TopicInternal_ids[0], &__IceStorm__TopicInternal_ids[3]);
}

const ::std::string&
IceStorm::TopicInternal::ice_id(const ::Ice::Current&) const
{
    return __IceStorm__TopicInternal_ids[2];
}

const ::std::string&
IceStorm::TopicInternal::ice_staticId()
{
    return __IceStorm__TopicInternal_ids[2];
}

::Ice::DispatchStatus
IceStorm::TopicInternal::___getLinkProxy(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::IceStorm::TopicLinkPrx __ret = getLinkProxy(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceStorm::TopicInternal::___reap(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::IdentitySeq id;
    __is->read(id);
    __inS.endReadParams();
    try
    {
        reap(id, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::IceStorm::ReapWouldBlock& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __IceStorm__TopicInternal_all[] =
{
    "destroy",
    "getLinkInfoSeq",
    "getLinkProxy",
    "getName",
    "getNonReplicatedPublisher",
    "getPublisher",
    "getSubscribers",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "link",
    "reap",
    "subscribe",
    "subscribeAndGetPublisher",
    "unlink",
    "unsubscribe"
};

}

::Ice::DispatchStatus
IceStorm::TopicInternal::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__IceStorm__TopicInternal_all, __IceStorm__TopicInternal_all + 17, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __IceStorm__TopicInternal_all)
    {
        case 0:
        {
            return ___destroy(in, current);
        }
        case 1:
        {
            return ___getLinkInfoSeq(in, current);
        }
        case 2:
        {
            return ___getLinkProxy(in, current);
        }
        case 3:
        {
            return ___getName(in, current);
        }
        case 4:
        {
            return ___getNonReplicatedPublisher(in, current);
        }
        case 5:
        {
            return ___getPublisher(in, current);
        }
        case 6:
        {
            return ___getSubscribers(in, current);
        }
        case 7:
        {
            return ___ice_id(in, current);
        }
        case 8:
        {
            return ___ice_ids(in, current);
        }
        case 9:
        {
            return ___ice_isA(in, current);
        }
        case 10:
        {
            return ___ice_ping(in, current);
        }
        case 11:
        {
            return ___link(in, current);
        }
        case 12:
        {
            return ___reap(in, current);
        }
        case 13:
        {
            return ___subscribe(in, current);
        }
        case 14:
        {
            return ___subscribeAndGetPublisher(in, current);
        }
        case 15:
        {
            return ___unlink(in, current);
        }
        case 16:
        {
            return ___unsubscribe(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
IceStorm::TopicInternal::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
IceStorm::TopicInternal::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void ICE_DECLSPEC_EXPORT 
IceStorm::__patch(TopicInternalPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceStorm::TopicInternalPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceStorm::TopicInternal::ice_staticId(), v);
    }
}

ICE_DECLSPEC_EXPORT ::Ice::Object* IceStorm::upCast(::IceStorm::TopicManagerInternal* p) { return p; }

namespace
{
const ::std::string __IceStorm__TopicManagerInternal_ids[3] =
{
    "::Ice::Object",
    "::IceStorm::TopicManager",
    "::IceStorm::TopicManagerInternal"
};

}

bool
IceStorm::TopicManagerInternal::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceStorm__TopicManagerInternal_ids, __IceStorm__TopicManagerInternal_ids + 3, _s);
}

::std::vector< ::std::string>
IceStorm::TopicManagerInternal::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceStorm__TopicManagerInternal_ids[0], &__IceStorm__TopicManagerInternal_ids[3]);
}

const ::std::string&
IceStorm::TopicManagerInternal::ice_id(const ::Ice::Current&) const
{
    return __IceStorm__TopicManagerInternal_ids[2];
}

const ::std::string&
IceStorm::TopicManagerInternal::ice_staticId()
{
    return __IceStorm__TopicManagerInternal_ids[2];
}

::Ice::DispatchStatus
IceStorm::TopicManagerInternal::___getReplicaNode(::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::IceStormElection::NodePrx __ret = getReplicaNode(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __IceStorm__TopicManagerInternal_all[] =
{
    "create",
    "getReplicaNode",
    "getSliceChecksums",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "retrieve",
    "retrieveAll"
};

}

::Ice::DispatchStatus
IceStorm::TopicManagerInternal::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__IceStorm__TopicManagerInternal_all, __IceStorm__TopicManagerInternal_all + 9, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __IceStorm__TopicManagerInternal_all)
    {
        case 0:
        {
            return ___create(in, current);
        }
        case 1:
        {
            return ___getReplicaNode(in, current);
        }
        case 2:
        {
            return ___getSliceChecksums(in, current);
        }
        case 3:
        {
            return ___ice_id(in, current);
        }
        case 4:
        {
            return ___ice_ids(in, current);
        }
        case 5:
        {
            return ___ice_isA(in, current);
        }
        case 6:
        {
            return ___ice_ping(in, current);
        }
        case 7:
        {
            return ___retrieve(in, current);
        }
        case 8:
        {
            return ___retrieveAll(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
IceStorm::TopicManagerInternal::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
IceStorm::TopicManagerInternal::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void ICE_DECLSPEC_EXPORT 
IceStorm::__patch(TopicManagerInternalPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceStorm::TopicManagerInternalPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceStorm::TopicManagerInternal::ice_staticId(), v);
    }
}
