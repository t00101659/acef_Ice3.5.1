// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `Election.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef ICE_STORM_SERVICE_API_EXPORTS
#   define ICE_STORM_SERVICE_API_EXPORTS
#endif
#include <IceStorm/Election.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/BasicStream.h>
#include <Ice/Object.h>
#include <IceUtil/Iterator.h>
#include <IceUtil/DisableWarnings.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace
{

const ::std::string __IceStormElection__ReplicaObserver__init_name = "init";

const ::std::string __IceStormElection__ReplicaObserver__createTopic_name = "createTopic";

const ::std::string __IceStormElection__ReplicaObserver__destroyTopic_name = "destroyTopic";

const ::std::string __IceStormElection__ReplicaObserver__addSubscriber_name = "addSubscriber";

const ::std::string __IceStormElection__ReplicaObserver__removeSubscriber_name = "removeSubscriber";

const ::std::string __IceStormElection__TopicManagerSync__getContent_name = "getContent";

const ::std::string __IceStormElection__Node__invitation_name = "invitation";

const ::std::string __IceStormElection__Node__ready_name = "ready";

const ::std::string __IceStormElection__Node__accept_name = "accept";

const ::std::string __IceStormElection__Node__areYouCoordinator_name = "areYouCoordinator";

const ::std::string __IceStormElection__Node__areYouThere_name = "areYouThere";

const ::std::string __IceStormElection__Node__sync_name = "sync";

const ::std::string __IceStormElection__Node__nodes_name = "nodes";

const ::std::string __IceStormElection__Node__query_name = "query";

}

namespace
{

const char* __IceStormElection__ObserverInconsistencyException_name = "IceStormElection::ObserverInconsistencyException";

struct __F__IceStormElection__ObserverInconsistencyException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::IceStormElection::ObserverInconsistencyException();
    }
};

class __F__IceStormElection__ObserverInconsistencyException__Init
{
public:

    __F__IceStormElection__ObserverInconsistencyException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::IceStormElection::ObserverInconsistencyException", new __F__IceStormElection__ObserverInconsistencyException);
    }

    ~__F__IceStormElection__ObserverInconsistencyException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::IceStormElection::ObserverInconsistencyException");
    }
};

const __F__IceStormElection__ObserverInconsistencyException__Init __F__IceStormElection__ObserverInconsistencyException__i;

}

IceStormElection::ObserverInconsistencyException::ObserverInconsistencyException(const ::std::string& __ice_reason) :
    ::Ice::UserException(),
    reason(__ice_reason)
{
}

IceStormElection::ObserverInconsistencyException::~ObserverInconsistencyException() throw()
{
}

::std::string
IceStormElection::ObserverInconsistencyException::ice_name() const
{
    return __IceStormElection__ObserverInconsistencyException_name;
}

IceStormElection::ObserverInconsistencyException*
IceStormElection::ObserverInconsistencyException::ice_clone() const
{
    return new ObserverInconsistencyException(*this);
}

void
IceStormElection::ObserverInconsistencyException::ice_throw() const
{
    throw *this;
}

void
IceStormElection::ObserverInconsistencyException::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::IceStormElection::ObserverInconsistencyException", -1, true);
    __os->write(reason);
    __os->endWriteSlice();
}

void
IceStormElection::ObserverInconsistencyException::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(reason);
    __is->endReadSlice();
}

namespace Ice
{
#ifdef ICE_HAS_DECLSPEC_IMPORT_EXPORT
template struct ICE_STORM_SERVICE_API StreamWriter< ::IceStormElection::TopicContent, ::IceInternal::BasicStream>;
template struct ICE_STORM_SERVICE_API StreamReader< ::IceStormElection::TopicContent, ::IceInternal::BasicStream>;
#endif
#ifdef ICE_HAS_DECLSPEC_IMPORT_EXPORT
template struct ICE_STORM_SERVICE_API StreamWriter< ::IceStormElection::NodeInfo, ::IceInternal::BasicStream>;
template struct ICE_STORM_SERVICE_API StreamReader< ::IceStormElection::NodeInfo, ::IceInternal::BasicStream>;
#endif
#ifdef ICE_HAS_DECLSPEC_IMPORT_EXPORT
template struct ICE_STORM_SERVICE_API StreamWriter< ::IceStormElection::GroupInfo, ::IceInternal::BasicStream>;
template struct ICE_STORM_SERVICE_API StreamReader< ::IceStormElection::GroupInfo, ::IceInternal::BasicStream>;
#endif
#ifdef ICE_HAS_DECLSPEC_IMPORT_EXPORT
template struct ICE_STORM_SERVICE_API StreamWriter< ::IceStormElection::QueryInfo, ::IceInternal::BasicStream>;
template struct ICE_STORM_SERVICE_API StreamReader< ::IceStormElection::QueryInfo, ::IceInternal::BasicStream>;
#endif
}
#ifdef __SUNPRO_CC
class ICE_DECLSPEC_EXPORT IceProxy::IceStormElection::ReplicaObserver;
#endif
ICE_DECLSPEC_EXPORT ::IceProxy::Ice::Object* ::IceProxy::IceStormElection::upCast(::IceProxy::IceStormElection::ReplicaObserver* p) { return p; }

void
::IceProxy::IceStormElection::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceStormElection::ReplicaObserver>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceStormElection::ReplicaObserver;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::IceStormElection::ReplicaObserver::init(const ::IceStormElection::LogUpdate& llu, const ::IceStormElection::TopicContentSeq& content, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceStormElection__ReplicaObserver__init_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceStormElection__ReplicaObserver__init_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceStormElection::ReplicaObserver* __del = dynamic_cast< ::IceDelegate::IceStormElection::ReplicaObserver*>(__delBase.get());
            __del->init(llu, content, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceStormElection::ReplicaObserver::begin_init(const ::IceStormElection::LogUpdate& llu, const ::IceStormElection::TopicContentSeq& content, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceStormElection__ReplicaObserver__init_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceStormElection__ReplicaObserver__init_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceStormElection__ReplicaObserver__init_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(llu);
        __os->write(content);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceStormElection::ReplicaObserver::end_init(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceStormElection__ReplicaObserver__init_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::IceStormElection::ObserverInconsistencyException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::IceStormElection::ReplicaObserver::createTopic(const ::IceStormElection::LogUpdate& llu, const ::std::string& name, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceStormElection__ReplicaObserver__createTopic_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceStormElection__ReplicaObserver__createTopic_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceStormElection::ReplicaObserver* __del = dynamic_cast< ::IceDelegate::IceStormElection::ReplicaObserver*>(__delBase.get());
            __del->createTopic(llu, name, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceStormElection::ReplicaObserver::begin_createTopic(const ::IceStormElection::LogUpdate& llu, const ::std::string& name, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceStormElection__ReplicaObserver__createTopic_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceStormElection__ReplicaObserver__createTopic_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceStormElection__ReplicaObserver__createTopic_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(llu);
        __os->write(name);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceStormElection::ReplicaObserver::end_createTopic(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceStormElection__ReplicaObserver__createTopic_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::IceStormElection::ObserverInconsistencyException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::IceStormElection::ReplicaObserver::destroyTopic(const ::IceStormElection::LogUpdate& llu, const ::std::string& name, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceStormElection__ReplicaObserver__destroyTopic_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceStormElection__ReplicaObserver__destroyTopic_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceStormElection::ReplicaObserver* __del = dynamic_cast< ::IceDelegate::IceStormElection::ReplicaObserver*>(__delBase.get());
            __del->destroyTopic(llu, name, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceStormElection::ReplicaObserver::begin_destroyTopic(const ::IceStormElection::LogUpdate& llu, const ::std::string& name, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceStormElection__ReplicaObserver__destroyTopic_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceStormElection__ReplicaObserver__destroyTopic_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceStormElection__ReplicaObserver__destroyTopic_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(llu);
        __os->write(name);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceStormElection::ReplicaObserver::end_destroyTopic(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceStormElection__ReplicaObserver__destroyTopic_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::IceStormElection::ObserverInconsistencyException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::IceStormElection::ReplicaObserver::addSubscriber(const ::IceStormElection::LogUpdate& llu, const ::std::string& topic, const ::IceStorm::SubscriberRecord& record, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceStormElection__ReplicaObserver__addSubscriber_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceStormElection__ReplicaObserver__addSubscriber_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceStormElection::ReplicaObserver* __del = dynamic_cast< ::IceDelegate::IceStormElection::ReplicaObserver*>(__delBase.get());
            __del->addSubscriber(llu, topic, record, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceStormElection::ReplicaObserver::begin_addSubscriber(const ::IceStormElection::LogUpdate& llu, const ::std::string& topic, const ::IceStorm::SubscriberRecord& record, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceStormElection__ReplicaObserver__addSubscriber_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceStormElection__ReplicaObserver__addSubscriber_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceStormElection__ReplicaObserver__addSubscriber_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(llu);
        __os->write(topic);
        __os->write(record);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceStormElection::ReplicaObserver::end_addSubscriber(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceStormElection__ReplicaObserver__addSubscriber_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::IceStormElection::ObserverInconsistencyException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::IceStormElection::ReplicaObserver::removeSubscriber(const ::IceStormElection::LogUpdate& llu, const ::std::string& topic, const ::Ice::IdentitySeq& subscribers, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceStormElection__ReplicaObserver__removeSubscriber_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceStormElection__ReplicaObserver__removeSubscriber_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceStormElection::ReplicaObserver* __del = dynamic_cast< ::IceDelegate::IceStormElection::ReplicaObserver*>(__delBase.get());
            __del->removeSubscriber(llu, topic, subscribers, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceStormElection::ReplicaObserver::begin_removeSubscriber(const ::IceStormElection::LogUpdate& llu, const ::std::string& topic, const ::Ice::IdentitySeq& subscribers, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceStormElection__ReplicaObserver__removeSubscriber_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceStormElection__ReplicaObserver__removeSubscriber_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceStormElection__ReplicaObserver__removeSubscriber_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(llu);
        __os->write(topic);
        __os->write(subscribers);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceStormElection::ReplicaObserver::end_removeSubscriber(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceStormElection__ReplicaObserver__removeSubscriber_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::IceStormElection::ObserverInconsistencyException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::IceStormElection::ReplicaObserver::ice_staticId()
{
    return ::IceStormElection::ReplicaObserver::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceStormElection::ReplicaObserver::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceStormElection::ReplicaObserver);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceStormElection::ReplicaObserver::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceStormElection::ReplicaObserver);
}

::IceProxy::Ice::Object*
IceProxy::IceStormElection::ReplicaObserver::__newInstance() const
{
    return new ReplicaObserver;
}
#ifdef __SUNPRO_CC
class ICE_DECLSPEC_EXPORT IceProxy::IceStormElection::TopicManagerSync;
#endif
ICE_DECLSPEC_EXPORT ::IceProxy::Ice::Object* ::IceProxy::IceStormElection::upCast(::IceProxy::IceStormElection::TopicManagerSync* p) { return p; }

void
::IceProxy::IceStormElection::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceStormElection::TopicManagerSync>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceStormElection::TopicManagerSync;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::IceStormElection::TopicManagerSync::getContent(::IceStormElection::LogUpdate& llu, ::IceStormElection::TopicContentSeq& content, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceStormElection__TopicManagerSync__getContent_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceStormElection__TopicManagerSync__getContent_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceStormElection::TopicManagerSync* __del = dynamic_cast< ::IceDelegate::IceStormElection::TopicManagerSync*>(__delBase.get());
            __del->getContent(llu, content, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceStormElection::TopicManagerSync::begin_getContent(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceStormElection__TopicManagerSync__getContent_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceStormElection__TopicManagerSync__getContent_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceStormElection__TopicManagerSync__getContent_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceStormElection::TopicManagerSync::end_getContent(::IceStormElection::LogUpdate& llu, ::IceStormElection::TopicContentSeq& content, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceStormElection__TopicManagerSync__getContent_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(llu);
        __is->read(content);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::IceStormElection::TopicManagerSync::ice_staticId()
{
    return ::IceStormElection::TopicManagerSync::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceStormElection::TopicManagerSync::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceStormElection::TopicManagerSync);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceStormElection::TopicManagerSync::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceStormElection::TopicManagerSync);
}

::IceProxy::Ice::Object*
IceProxy::IceStormElection::TopicManagerSync::__newInstance() const
{
    return new TopicManagerSync;
}
#ifdef __SUNPRO_CC
class ICE_DECLSPEC_EXPORT IceProxy::IceStormElection::Node;
#endif
ICE_DECLSPEC_EXPORT ::IceProxy::Ice::Object* ::IceProxy::IceStormElection::upCast(::IceProxy::IceStormElection::Node* p) { return p; }

void
::IceProxy::IceStormElection::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceStormElection::Node>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceStormElection::Node;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::IceStormElection::Node::invitation(::Ice::Int j, const ::std::string& gn, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceStormElection__Node__invitation_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceStormElection::Node* __del = dynamic_cast< ::IceDelegate::IceStormElection::Node*>(__delBase.get());
            __del->invitation(j, gn, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceStormElection::Node::begin_invitation(::Ice::Int j, const ::std::string& gn, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceStormElection__Node__invitation_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceStormElection__Node__invitation_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(j);
        __os->write(gn);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceStormElection::Node::end_invitation(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceStormElection__Node__invitation_name);
}

void
IceProxy::IceStormElection::Node::ready(::Ice::Int j, const ::std::string& gn, const ::Ice::ObjectPrx& coordinator, ::Ice::Int max, ::Ice::Long generation, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceStormElection__Node__ready_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceStormElection::Node* __del = dynamic_cast< ::IceDelegate::IceStormElection::Node*>(__delBase.get());
            __del->ready(j, gn, coordinator, max, generation, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceStormElection::Node::begin_ready(::Ice::Int j, const ::std::string& gn, const ::Ice::ObjectPrx& coordinator, ::Ice::Int max, ::Ice::Long generation, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceStormElection__Node__ready_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceStormElection__Node__ready_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(j);
        __os->write(gn);
        __os->write(coordinator);
        __os->write(max);
        __os->write(generation);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceStormElection::Node::end_ready(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceStormElection__Node__ready_name);
}

void
IceProxy::IceStormElection::Node::accept(::Ice::Int j, const ::std::string& gn, const ::Ice::IntSeq& forwardedInvites, const ::Ice::ObjectPrx& observer, const ::IceStormElection::LogUpdate& llu, ::Ice::Int max, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceStormElection__Node__accept_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::IceStormElection::Node* __del = dynamic_cast< ::IceDelegate::IceStormElection::Node*>(__delBase.get());
            __del->accept(j, gn, forwardedInvites, observer, llu, max, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceStormElection::Node::begin_accept(::Ice::Int j, const ::std::string& gn, const ::Ice::IntSeq& forwardedInvites, const ::Ice::ObjectPrx& observer, const ::IceStormElection::LogUpdate& llu, ::Ice::Int max, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceStormElection__Node__accept_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceStormElection__Node__accept_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(j);
        __os->write(gn);
        __os->write(forwardedInvites);
        __os->write(observer);
        __os->write(llu);
        __os->write(max);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceStormElection::Node::end_accept(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __IceStormElection__Node__accept_name);
}

bool
IceProxy::IceStormElection::Node::areYouCoordinator(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceStormElection__Node__areYouCoordinator_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceStormElection__Node__areYouCoordinator_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceStormElection::Node* __del = dynamic_cast< ::IceDelegate::IceStormElection::Node*>(__delBase.get());
            return __del->areYouCoordinator(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceStormElection::Node::begin_areYouCoordinator(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceStormElection__Node__areYouCoordinator_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceStormElection__Node__areYouCoordinator_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceStormElection__Node__areYouCoordinator_name, ::Ice::Idempotent, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::IceStormElection::Node::end_areYouCoordinator(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceStormElection__Node__areYouCoordinator_name);
    bool __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

bool
IceProxy::IceStormElection::Node::areYouThere(const ::std::string& gn, ::Ice::Int j, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceStormElection__Node__areYouThere_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceStormElection__Node__areYouThere_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceStormElection::Node* __del = dynamic_cast< ::IceDelegate::IceStormElection::Node*>(__delBase.get());
            return __del->areYouThere(gn, j, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceStormElection::Node::begin_areYouThere(const ::std::string& gn, ::Ice::Int j, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceStormElection__Node__areYouThere_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceStormElection__Node__areYouThere_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceStormElection__Node__areYouThere_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(gn);
        __os->write(j);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::IceStormElection::Node::end_areYouThere(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceStormElection__Node__areYouThere_name);
    bool __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::ObjectPrx
IceProxy::IceStormElection::Node::sync(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceStormElection__Node__sync_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceStormElection__Node__sync_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceStormElection::Node* __del = dynamic_cast< ::IceDelegate::IceStormElection::Node*>(__delBase.get());
            return __del->sync(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceStormElection::Node::begin_sync(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceStormElection__Node__sync_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceStormElection__Node__sync_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceStormElection__Node__sync_name, ::Ice::Idempotent, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::ObjectPrx
IceProxy::IceStormElection::Node::end_sync(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceStormElection__Node__sync_name);
    ::Ice::ObjectPrx __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::IceStormElection::NodeInfoSeq
IceProxy::IceStormElection::Node::nodes(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceStormElection__Node__nodes_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceStormElection__Node__nodes_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceStormElection::Node* __del = dynamic_cast< ::IceDelegate::IceStormElection::Node*>(__delBase.get());
            return __del->nodes(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceStormElection::Node::begin_nodes(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceStormElection__Node__nodes_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceStormElection__Node__nodes_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceStormElection__Node__nodes_name, ::Ice::Idempotent, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::IceStormElection::NodeInfoSeq
IceProxy::IceStormElection::Node::end_nodes(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceStormElection__Node__nodes_name);
    ::IceStormElection::NodeInfoSeq __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::IceStormElection::QueryInfo
IceProxy::IceStormElection::Node::query(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceStormElection__Node__query_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceStormElection__Node__query_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceStormElection::Node* __del = dynamic_cast< ::IceDelegate::IceStormElection::Node*>(__delBase.get());
            return __del->query(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceStormElection::Node::begin_query(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceStormElection__Node__query_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceStormElection__Node__query_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceStormElection__Node__query_name, ::Ice::Idempotent, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::IceStormElection::QueryInfo
IceProxy::IceStormElection::Node::end_query(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceStormElection__Node__query_name);
    ::IceStormElection::QueryInfo __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::IceStormElection::Node::ice_staticId()
{
    return ::IceStormElection::Node::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceStormElection::Node::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceStormElection::Node);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceStormElection::Node::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceStormElection::Node);
}

::IceProxy::Ice::Object*
IceProxy::IceStormElection::Node::__newInstance() const
{
    return new Node;
}

void
IceDelegateM::IceStormElection::ReplicaObserver::init(const ::IceStormElection::LogUpdate& llu, const ::IceStormElection::TopicContentSeq& content, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceStormElection__ReplicaObserver__init_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(llu);
        __os->write(content);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::IceStormElection::ObserverInconsistencyException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::IceStormElection::ReplicaObserver::createTopic(const ::IceStormElection::LogUpdate& llu, const ::std::string& name, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceStormElection__ReplicaObserver__createTopic_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(llu);
        __os->write(name);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::IceStormElection::ObserverInconsistencyException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::IceStormElection::ReplicaObserver::destroyTopic(const ::IceStormElection::LogUpdate& llu, const ::std::string& name, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceStormElection__ReplicaObserver__destroyTopic_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(llu);
        __os->write(name);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::IceStormElection::ObserverInconsistencyException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::IceStormElection::ReplicaObserver::addSubscriber(const ::IceStormElection::LogUpdate& llu, const ::std::string& topic, const ::IceStorm::SubscriberRecord& record, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceStormElection__ReplicaObserver__addSubscriber_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(llu);
        __os->write(topic);
        __os->write(record);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::IceStormElection::ObserverInconsistencyException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::IceStormElection::ReplicaObserver::removeSubscriber(const ::IceStormElection::LogUpdate& llu, const ::std::string& topic, const ::Ice::IdentitySeq& subscribers, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceStormElection__ReplicaObserver__removeSubscriber_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(llu);
        __os->write(topic);
        __os->write(subscribers);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::IceStormElection::ObserverInconsistencyException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::IceStormElection::TopicManagerSync::getContent(::IceStormElection::LogUpdate& llu, ::IceStormElection::TopicContentSeq& content, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceStormElection__TopicManagerSync__getContent_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(llu);
        __is->read(content);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::IceStormElection::Node::invitation(::Ice::Int j, const ::std::string& gn, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceStormElection__Node__invitation_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(j);
        __os->write(gn);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::IceStormElection::Node::ready(::Ice::Int j, const ::std::string& gn, const ::Ice::ObjectPrx& coordinator, ::Ice::Int max, ::Ice::Long generation, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceStormElection__Node__ready_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(j);
        __os->write(gn);
        __os->write(coordinator);
        __os->write(max);
        __os->write(generation);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::IceStormElection::Node::accept(::Ice::Int j, const ::std::string& gn, const ::Ice::IntSeq& forwardedInvites, const ::Ice::ObjectPrx& observer, const ::IceStormElection::LogUpdate& llu, ::Ice::Int max, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceStormElection__Node__accept_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(j);
        __os->write(gn);
        __os->write(forwardedInvites);
        __os->write(observer);
        __os->write(llu);
        __os->write(max);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

bool
IceDelegateM::IceStormElection::Node::areYouCoordinator(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceStormElection__Node__areYouCoordinator_name, ::Ice::Idempotent, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::IceStormElection::Node::areYouThere(const ::std::string& gn, ::Ice::Int j, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceStormElection__Node__areYouThere_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(gn);
        __os->write(j);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::ObjectPrx
IceDelegateM::IceStormElection::Node::sync(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceStormElection__Node__sync_name, ::Ice::Idempotent, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Ice::ObjectPrx __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::IceStormElection::NodeInfoSeq
IceDelegateM::IceStormElection::Node::nodes(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceStormElection__Node__nodes_name, ::Ice::Idempotent, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::IceStormElection::NodeInfoSeq __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::IceStormElection::QueryInfo
IceDelegateM::IceStormElection::Node::query(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceStormElection__Node__query_name, ::Ice::Idempotent, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::IceStormElection::QueryInfo __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateD::IceStormElection::ReplicaObserver::init(const ::IceStormElection::LogUpdate& llu, const ::IceStormElection::TopicContentSeq& content, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::IceStormElection::LogUpdate& __p_llu, const ::IceStormElection::TopicContentSeq& __p_content, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_llu(__p_llu),
            _m_content(__p_content)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceStormElection::ReplicaObserver* servant = dynamic_cast< ::IceStormElection::ReplicaObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->init(_m_llu, _m_content, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::IceStormElection::LogUpdate& _m_llu;
        const ::IceStormElection::TopicContentSeq& _m_content;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceStormElection__ReplicaObserver__init_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(llu, content, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::IceStormElection::ObserverInconsistencyException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceStormElection::ReplicaObserver::createTopic(const ::IceStormElection::LogUpdate& llu, const ::std::string& name, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::IceStormElection::LogUpdate& __p_llu, const ::std::string& __p_name, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_llu(__p_llu),
            _m_name(__p_name)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceStormElection::ReplicaObserver* servant = dynamic_cast< ::IceStormElection::ReplicaObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->createTopic(_m_llu, _m_name, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::IceStormElection::LogUpdate& _m_llu;
        const ::std::string& _m_name;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceStormElection__ReplicaObserver__createTopic_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(llu, name, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::IceStormElection::ObserverInconsistencyException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceStormElection::ReplicaObserver::destroyTopic(const ::IceStormElection::LogUpdate& llu, const ::std::string& name, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::IceStormElection::LogUpdate& __p_llu, const ::std::string& __p_name, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_llu(__p_llu),
            _m_name(__p_name)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceStormElection::ReplicaObserver* servant = dynamic_cast< ::IceStormElection::ReplicaObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->destroyTopic(_m_llu, _m_name, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::IceStormElection::LogUpdate& _m_llu;
        const ::std::string& _m_name;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceStormElection__ReplicaObserver__destroyTopic_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(llu, name, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::IceStormElection::ObserverInconsistencyException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceStormElection::ReplicaObserver::addSubscriber(const ::IceStormElection::LogUpdate& llu, const ::std::string& topic, const ::IceStorm::SubscriberRecord& record, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::IceStormElection::LogUpdate& __p_llu, const ::std::string& __p_topic, const ::IceStorm::SubscriberRecord& __p_record, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_llu(__p_llu),
            _m_topic(__p_topic),
            _m_record(__p_record)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceStormElection::ReplicaObserver* servant = dynamic_cast< ::IceStormElection::ReplicaObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->addSubscriber(_m_llu, _m_topic, _m_record, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::IceStormElection::LogUpdate& _m_llu;
        const ::std::string& _m_topic;
        const ::IceStorm::SubscriberRecord& _m_record;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceStormElection__ReplicaObserver__addSubscriber_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(llu, topic, record, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::IceStormElection::ObserverInconsistencyException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceStormElection::ReplicaObserver::removeSubscriber(const ::IceStormElection::LogUpdate& llu, const ::std::string& topic, const ::Ice::IdentitySeq& subscribers, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::IceStormElection::LogUpdate& __p_llu, const ::std::string& __p_topic, const ::Ice::IdentitySeq& __p_subscribers, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_llu(__p_llu),
            _m_topic(__p_topic),
            _m_subscribers(__p_subscribers)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceStormElection::ReplicaObserver* servant = dynamic_cast< ::IceStormElection::ReplicaObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->removeSubscriber(_m_llu, _m_topic, _m_subscribers, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::IceStormElection::LogUpdate& _m_llu;
        const ::std::string& _m_topic;
        const ::Ice::IdentitySeq& _m_subscribers;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceStormElection__ReplicaObserver__removeSubscriber_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(llu, topic, subscribers, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::IceStormElection::ObserverInconsistencyException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceStormElection::TopicManagerSync::getContent(::IceStormElection::LogUpdate& llu, ::IceStormElection::TopicContentSeq& content, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::IceStormElection::LogUpdate& __p_llu, ::IceStormElection::TopicContentSeq& __p_content, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_llu(__p_llu),
            _m_content(__p_content)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceStormElection::TopicManagerSync* servant = dynamic_cast< ::IceStormElection::TopicManagerSync*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->getContent(_m_llu, _m_content, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::IceStormElection::LogUpdate& _m_llu;
        ::IceStormElection::TopicContentSeq& _m_content;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceStormElection__TopicManagerSync__getContent_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(llu, content, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceStormElection::Node::invitation(::Ice::Int j, const ::std::string& gn, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int __p_j, const ::std::string& __p_gn, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_j(__p_j),
            _m_gn(__p_gn)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceStormElection::Node* servant = dynamic_cast< ::IceStormElection::Node*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->invitation(_m_j, _m_gn, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_j;
        const ::std::string& _m_gn;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceStormElection__Node__invitation_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(j, gn, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceStormElection::Node::ready(::Ice::Int j, const ::std::string& gn, const ::Ice::ObjectPrx& coordinator, ::Ice::Int max, ::Ice::Long generation, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int __p_j, const ::std::string& __p_gn, const ::Ice::ObjectPrx& __p_coordinator, ::Ice::Int __p_max, ::Ice::Long __p_generation, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_j(__p_j),
            _m_gn(__p_gn),
            _m_coordinator(__p_coordinator),
            _m_max(__p_max),
            _m_generation(__p_generation)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceStormElection::Node* servant = dynamic_cast< ::IceStormElection::Node*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->ready(_m_j, _m_gn, _m_coordinator, _m_max, _m_generation, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_j;
        const ::std::string& _m_gn;
        const ::Ice::ObjectPrx& _m_coordinator;
        ::Ice::Int _m_max;
        ::Ice::Long _m_generation;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceStormElection__Node__ready_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(j, gn, coordinator, max, generation, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceStormElection::Node::accept(::Ice::Int j, const ::std::string& gn, const ::Ice::IntSeq& forwardedInvites, const ::Ice::ObjectPrx& observer, const ::IceStormElection::LogUpdate& llu, ::Ice::Int max, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int __p_j, const ::std::string& __p_gn, const ::Ice::IntSeq& __p_forwardedInvites, const ::Ice::ObjectPrx& __p_observer, const ::IceStormElection::LogUpdate& __p_llu, ::Ice::Int __p_max, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_j(__p_j),
            _m_gn(__p_gn),
            _m_forwardedInvites(__p_forwardedInvites),
            _m_observer(__p_observer),
            _m_llu(__p_llu),
            _m_max(__p_max)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceStormElection::Node* servant = dynamic_cast< ::IceStormElection::Node*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->accept(_m_j, _m_gn, _m_forwardedInvites, _m_observer, _m_llu, _m_max, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_j;
        const ::std::string& _m_gn;
        const ::Ice::IntSeq& _m_forwardedInvites;
        const ::Ice::ObjectPrx& _m_observer;
        const ::IceStormElection::LogUpdate& _m_llu;
        ::Ice::Int _m_max;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceStormElection__Node__accept_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(j, gn, forwardedInvites, observer, llu, max, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

bool
IceDelegateD::IceStormElection::Node::areYouCoordinator(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceStormElection::Node* servant = dynamic_cast< ::IceStormElection::Node*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->areYouCoordinator(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceStormElection__Node__areYouCoordinator_name, ::Ice::Idempotent, __context);
    bool __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

bool
IceDelegateD::IceStormElection::Node::areYouThere(const ::std::string& gn, ::Ice::Int j, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool& __result, const ::std::string& __p_gn, ::Ice::Int __p_j, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_gn(__p_gn),
            _m_j(__p_j)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceStormElection::Node* servant = dynamic_cast< ::IceStormElection::Node*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->areYouThere(_m_gn, _m_j, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool& _result;
        const ::std::string& _m_gn;
        ::Ice::Int _m_j;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceStormElection__Node__areYouThere_name, ::Ice::Idempotent, __context);
    bool __result;
    try
    {
        _DirectI __direct(__result, gn, j, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::ObjectPrx
IceDelegateD::IceStormElection::Node::sync(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::ObjectPrx& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceStormElection::Node* servant = dynamic_cast< ::IceStormElection::Node*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->sync(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::ObjectPrx& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceStormElection__Node__sync_name, ::Ice::Idempotent, __context);
    ::Ice::ObjectPrx __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::IceStormElection::NodeInfoSeq
IceDelegateD::IceStormElection::Node::nodes(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::IceStormElection::NodeInfoSeq& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceStormElection::Node* servant = dynamic_cast< ::IceStormElection::Node*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->nodes(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::IceStormElection::NodeInfoSeq& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceStormElection__Node__nodes_name, ::Ice::Idempotent, __context);
    ::IceStormElection::NodeInfoSeq __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::IceStormElection::QueryInfo
IceDelegateD::IceStormElection::Node::query(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::IceStormElection::QueryInfo& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceStormElection::Node* servant = dynamic_cast< ::IceStormElection::Node*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->query(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::IceStormElection::QueryInfo& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceStormElection__Node__query_name, ::Ice::Idempotent, __context);
    ::IceStormElection::QueryInfo __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

ICE_DECLSPEC_EXPORT ::Ice::Object* IceStormElection::upCast(::IceStormElection::ReplicaObserver* p) { return p; }

namespace
{
const ::std::string __IceStormElection__ReplicaObserver_ids[2] =
{
    "::Ice::Object",
    "::IceStormElection::ReplicaObserver"
};

}

bool
IceStormElection::ReplicaObserver::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceStormElection__ReplicaObserver_ids, __IceStormElection__ReplicaObserver_ids + 2, _s);
}

::std::vector< ::std::string>
IceStormElection::ReplicaObserver::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceStormElection__ReplicaObserver_ids[0], &__IceStormElection__ReplicaObserver_ids[2]);
}

const ::std::string&
IceStormElection::ReplicaObserver::ice_id(const ::Ice::Current&) const
{
    return __IceStormElection__ReplicaObserver_ids[1];
}

const ::std::string&
IceStormElection::ReplicaObserver::ice_staticId()
{
    return __IceStormElection__ReplicaObserver_ids[1];
}

::Ice::DispatchStatus
IceStormElection::ReplicaObserver::___init(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::IceStormElection::LogUpdate llu;
    ::IceStormElection::TopicContentSeq content;
    __is->read(llu);
    __is->read(content);
    __inS.endReadParams();
    try
    {
        init(llu, content, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::IceStormElection::ObserverInconsistencyException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
IceStormElection::ReplicaObserver::___createTopic(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::IceStormElection::LogUpdate llu;
    ::std::string name;
    __is->read(llu);
    __is->read(name);
    __inS.endReadParams();
    try
    {
        createTopic(llu, name, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::IceStormElection::ObserverInconsistencyException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
IceStormElection::ReplicaObserver::___destroyTopic(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::IceStormElection::LogUpdate llu;
    ::std::string name;
    __is->read(llu);
    __is->read(name);
    __inS.endReadParams();
    try
    {
        destroyTopic(llu, name, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::IceStormElection::ObserverInconsistencyException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
IceStormElection::ReplicaObserver::___addSubscriber(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::IceStormElection::LogUpdate llu;
    ::std::string topic;
    ::IceStorm::SubscriberRecord record;
    __is->read(llu);
    __is->read(topic);
    __is->read(record);
    __inS.endReadParams();
    try
    {
        addSubscriber(llu, topic, record, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::IceStormElection::ObserverInconsistencyException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
IceStormElection::ReplicaObserver::___removeSubscriber(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::IceStormElection::LogUpdate llu;
    ::std::string topic;
    ::Ice::IdentitySeq subscribers;
    __is->read(llu);
    __is->read(topic);
    __is->read(subscribers);
    __inS.endReadParams();
    try
    {
        removeSubscriber(llu, topic, subscribers, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::IceStormElection::ObserverInconsistencyException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __IceStormElection__ReplicaObserver_all[] =
{
    "addSubscriber",
    "createTopic",
    "destroyTopic",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "init",
    "removeSubscriber"
};

}

::Ice::DispatchStatus
IceStormElection::ReplicaObserver::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__IceStormElection__ReplicaObserver_all, __IceStormElection__ReplicaObserver_all + 9, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __IceStormElection__ReplicaObserver_all)
    {
        case 0:
        {
            return ___addSubscriber(in, current);
        }
        case 1:
        {
            return ___createTopic(in, current);
        }
        case 2:
        {
            return ___destroyTopic(in, current);
        }
        case 3:
        {
            return ___ice_id(in, current);
        }
        case 4:
        {
            return ___ice_ids(in, current);
        }
        case 5:
        {
            return ___ice_isA(in, current);
        }
        case 6:
        {
            return ___ice_ping(in, current);
        }
        case 7:
        {
            return ___init(in, current);
        }
        case 8:
        {
            return ___removeSubscriber(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
IceStormElection::ReplicaObserver::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
IceStormElection::ReplicaObserver::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void ICE_DECLSPEC_EXPORT 
IceStormElection::__patch(ReplicaObserverPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceStormElection::ReplicaObserverPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceStormElection::ReplicaObserver::ice_staticId(), v);
    }
}

ICE_DECLSPEC_EXPORT ::Ice::Object* IceStormElection::upCast(::IceStormElection::TopicManagerSync* p) { return p; }

namespace
{
const ::std::string __IceStormElection__TopicManagerSync_ids[2] =
{
    "::Ice::Object",
    "::IceStormElection::TopicManagerSync"
};

}

bool
IceStormElection::TopicManagerSync::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceStormElection__TopicManagerSync_ids, __IceStormElection__TopicManagerSync_ids + 2, _s);
}

::std::vector< ::std::string>
IceStormElection::TopicManagerSync::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceStormElection__TopicManagerSync_ids[0], &__IceStormElection__TopicManagerSync_ids[2]);
}

const ::std::string&
IceStormElection::TopicManagerSync::ice_id(const ::Ice::Current&) const
{
    return __IceStormElection__TopicManagerSync_ids[1];
}

const ::std::string&
IceStormElection::TopicManagerSync::ice_staticId()
{
    return __IceStormElection__TopicManagerSync_ids[1];
}

::Ice::DispatchStatus
IceStormElection::TopicManagerSync::___getContent(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::IceStormElection::LogUpdate llu;
    ::IceStormElection::TopicContentSeq content;
    getContent(llu, content, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(llu);
    __os->write(content);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __IceStormElection__TopicManagerSync_all[] =
{
    "getContent",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
IceStormElection::TopicManagerSync::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__IceStormElection__TopicManagerSync_all, __IceStormElection__TopicManagerSync_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __IceStormElection__TopicManagerSync_all)
    {
        case 0:
        {
            return ___getContent(in, current);
        }
        case 1:
        {
            return ___ice_id(in, current);
        }
        case 2:
        {
            return ___ice_ids(in, current);
        }
        case 3:
        {
            return ___ice_isA(in, current);
        }
        case 4:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
IceStormElection::TopicManagerSync::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
IceStormElection::TopicManagerSync::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void ICE_DECLSPEC_EXPORT 
IceStormElection::__patch(TopicManagerSyncPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceStormElection::TopicManagerSyncPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceStormElection::TopicManagerSync::ice_staticId(), v);
    }
}

ICE_DECLSPEC_EXPORT ::Ice::Object* IceStormElection::upCast(::IceStormElection::Node* p) { return p; }

namespace
{
const ::std::string __IceStormElection__Node_ids[2] =
{
    "::Ice::Object",
    "::IceStormElection::Node"
};

}

bool
IceStormElection::Node::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceStormElection__Node_ids, __IceStormElection__Node_ids + 2, _s);
}

::std::vector< ::std::string>
IceStormElection::Node::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceStormElection__Node_ids[0], &__IceStormElection__Node_ids[2]);
}

const ::std::string&
IceStormElection::Node::ice_id(const ::Ice::Current&) const
{
    return __IceStormElection__Node_ids[1];
}

const ::std::string&
IceStormElection::Node::ice_staticId()
{
    return __IceStormElection__Node_ids[1];
}

::Ice::DispatchStatus
IceStormElection::Node::___invitation(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int j;
    ::std::string gn;
    __is->read(j);
    __is->read(gn);
    __inS.endReadParams();
    invitation(j, gn, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceStormElection::Node::___ready(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int j;
    ::std::string gn;
    ::Ice::ObjectPrx coordinator;
    ::Ice::Int max;
    ::Ice::Long generation;
    __is->read(j);
    __is->read(gn);
    __is->read(coordinator);
    __is->read(max);
    __is->read(generation);
    __inS.endReadParams();
    ready(j, gn, coordinator, max, generation, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceStormElection::Node::___accept(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int j;
    ::std::string gn;
    ::Ice::IntSeq forwardedInvites;
    ::Ice::ObjectPrx observer;
    ::IceStormElection::LogUpdate llu;
    ::Ice::Int max;
    __is->read(j);
    __is->read(gn);
    __is->read(forwardedInvites);
    __is->read(observer);
    __is->read(llu);
    __is->read(max);
    __inS.endReadParams();
    accept(j, gn, forwardedInvites, observer, llu, max, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceStormElection::Node::___areYouCoordinator(::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    bool __ret = areYouCoordinator(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceStormElection::Node::___areYouThere(::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string gn;
    ::Ice::Int j;
    __is->read(gn);
    __is->read(j);
    __inS.endReadParams();
    bool __ret = areYouThere(gn, j, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceStormElection::Node::___sync(::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::Ice::ObjectPrx __ret = sync(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceStormElection::Node::___nodes(::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::IceStormElection::NodeInfoSeq __ret = nodes(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceStormElection::Node::___query(::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::IceStormElection::QueryInfo __ret = query(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __IceStormElection__Node_all[] =
{
    "accept",
    "areYouCoordinator",
    "areYouThere",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "invitation",
    "nodes",
    "query",
    "ready",
    "sync"
};

}

::Ice::DispatchStatus
IceStormElection::Node::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__IceStormElection__Node_all, __IceStormElection__Node_all + 12, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __IceStormElection__Node_all)
    {
        case 0:
        {
            return ___accept(in, current);
        }
        case 1:
        {
            return ___areYouCoordinator(in, current);
        }
        case 2:
        {
            return ___areYouThere(in, current);
        }
        case 3:
        {
            return ___ice_id(in, current);
        }
        case 4:
        {
            return ___ice_ids(in, current);
        }
        case 5:
        {
            return ___ice_isA(in, current);
        }
        case 6:
        {
            return ___ice_ping(in, current);
        }
        case 7:
        {
            return ___invitation(in, current);
        }
        case 8:
        {
            return ___nodes(in, current);
        }
        case 9:
        {
            return ___query(in, current);
        }
        case 10:
        {
            return ___ready(in, current);
        }
        case 11:
        {
            return ___sync(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
IceStormElection::Node::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
IceStormElection::Node::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void ICE_DECLSPEC_EXPORT 
IceStormElection::__patch(NodePtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceStormElection::NodePtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceStormElection::Node::ice_staticId(), v);
    }
}
