// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `Election.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __IceStorm_Election_h__
#define __IceStorm_Election_h__

#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/Direct.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <IceUtil/Optional.h>
#include <Ice/StreamF.h>
#include <Ice/Identity.h>
#include <Ice/BuiltinSequences.h>
#include <IceStorm/SubscriberRecord.h>
#include <IceStorm/LLURecord.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

#ifndef ICE_STORM_SERVICE_API
#   ifdef ICE_STORM_SERVICE_API_EXPORTS
#       define ICE_STORM_SERVICE_API ICE_DECLSPEC_EXPORT
#   else
#       define ICE_STORM_SERVICE_API ICE_DECLSPEC_IMPORT
#   endif
#endif

namespace IceProxy
{

namespace IceStormElection
{

class ReplicaObserver;
ICE_STORM_SERVICE_API void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::IceStormElection::ReplicaObserver>&);
ICE_STORM_SERVICE_API ::IceProxy::Ice::Object* upCast(::IceProxy::IceStormElection::ReplicaObserver*);

class TopicManagerSync;
ICE_STORM_SERVICE_API void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::IceStormElection::TopicManagerSync>&);
ICE_STORM_SERVICE_API ::IceProxy::Ice::Object* upCast(::IceProxy::IceStormElection::TopicManagerSync*);

class Node;
ICE_STORM_SERVICE_API void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::IceStormElection::Node>&);
ICE_STORM_SERVICE_API ::IceProxy::Ice::Object* upCast(::IceProxy::IceStormElection::Node*);

}

}

namespace IceStormElection
{

class ReplicaObserver;
bool operator==(const ReplicaObserver&, const ReplicaObserver&);
bool operator<(const ReplicaObserver&, const ReplicaObserver&);
ICE_STORM_SERVICE_API ::Ice::Object* upCast(::IceStormElection::ReplicaObserver*);
typedef ::IceInternal::Handle< ::IceStormElection::ReplicaObserver> ReplicaObserverPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::IceStormElection::ReplicaObserver> ReplicaObserverPrx;
ICE_STORM_SERVICE_API void __patch(ReplicaObserverPtr&, const ::Ice::ObjectPtr&);

class TopicManagerSync;
bool operator==(const TopicManagerSync&, const TopicManagerSync&);
bool operator<(const TopicManagerSync&, const TopicManagerSync&);
ICE_STORM_SERVICE_API ::Ice::Object* upCast(::IceStormElection::TopicManagerSync*);
typedef ::IceInternal::Handle< ::IceStormElection::TopicManagerSync> TopicManagerSyncPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::IceStormElection::TopicManagerSync> TopicManagerSyncPrx;
ICE_STORM_SERVICE_API void __patch(TopicManagerSyncPtr&, const ::Ice::ObjectPtr&);

class Node;
bool operator==(const Node&, const Node&);
bool operator<(const Node&, const Node&);
ICE_STORM_SERVICE_API ::Ice::Object* upCast(::IceStormElection::Node*);
typedef ::IceInternal::Handle< ::IceStormElection::Node> NodePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::IceStormElection::Node> NodePrx;
ICE_STORM_SERVICE_API void __patch(NodePtr&, const ::Ice::ObjectPtr&);

}

namespace IceStormElection
{

struct TopicContent
{
    ::Ice::Identity id;
    ::IceStorm::SubscriberRecordSeq records;
};

typedef ::std::vector< ::IceStormElection::TopicContent> TopicContentSeq;

class ICE_STORM_SERVICE_API ObserverInconsistencyException : public ::Ice::UserException
{
public:

    ObserverInconsistencyException() {}
    explicit ObserverInconsistencyException(const ::std::string&);
    virtual ~ObserverInconsistencyException() throw();

    virtual ::std::string ice_name() const;
    virtual ObserverInconsistencyException* ice_clone() const;
    virtual void ice_throw() const;

    ::std::string reason;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
    #endif
};

static ObserverInconsistencyException __ObserverInconsistencyException_init;

enum NodeState
{
    NodeStateInactive,
    NodeStateElection,
    NodeStateReorganization,
    NodeStateNormal
};

struct NodeInfo
{
    ::Ice::Int id;
    ::IceStormElection::NodePrx n;
};

typedef ::std::vector< ::IceStormElection::NodeInfo> NodeInfoSeq;

struct GroupInfo
{
    ::Ice::Int id;
    ::IceStormElection::LogUpdate llu;

    bool operator==(const GroupInfo& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(id != __rhs.id)
        {
            return false;
        }
        if(llu != __rhs.llu)
        {
            return false;
        }
        return true;
    }

    bool operator<(const GroupInfo& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(id < __rhs.id)
        {
            return true;
        }
        else if(__rhs.id < id)
        {
            return false;
        }
        if(llu < __rhs.llu)
        {
            return true;
        }
        else if(__rhs.llu < llu)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const GroupInfo& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const GroupInfo& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const GroupInfo& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const GroupInfo& __rhs) const
    {
        return !operator<(__rhs);
    }
};

typedef ::std::vector< ::IceStormElection::GroupInfo> GroupInfoSeq;

struct QueryInfo
{
    ::Ice::Int id;
    ::Ice::Int coord;
    ::std::string group;
    ::Ice::ObjectPrx replica;
    ::IceStormElection::NodeState state;
    ::IceStormElection::GroupInfoSeq up;
    ::Ice::Int max;
};

}

namespace Ice
{
template<>
struct StreamableTraits< ::IceStormElection::TopicContent>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 3;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::IceStormElection::TopicContent, S>
{
    static void write(S* __os, const ::IceStormElection::TopicContent& v)
    {
        __os->write(v.id);
        __os->write(v.records);
    }
};

template<class S>
struct StreamReader< ::IceStormElection::TopicContent, S>
{
    static void read(S* __is, ::IceStormElection::TopicContent& v)
    {
        __is->read(v.id);
        __is->read(v.records);
    }
};

#if defined(ICE_HAS_DECLSPEC_IMPORT_EXPORT) && !defined(ICE_STORM_SERVICE_API_EXPORTS)
template struct ICE_STORM_SERVICE_API StreamWriter< ::IceStormElection::TopicContent, ::IceInternal::BasicStream>;
template struct ICE_STORM_SERVICE_API StreamReader< ::IceStormElection::TopicContent, ::IceInternal::BasicStream>;
#endif

template<>
struct StreamableTraits< ::IceStormElection::ObserverInconsistencyException>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::IceStormElection::NodeState>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 3;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::IceStormElection::NodeInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 6;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::IceStormElection::NodeInfo, S>
{
    static void write(S* __os, const ::IceStormElection::NodeInfo& v)
    {
        __os->write(v.id);
        __os->write(v.n);
    }
};

template<class S>
struct StreamReader< ::IceStormElection::NodeInfo, S>
{
    static void read(S* __is, ::IceStormElection::NodeInfo& v)
    {
        __is->read(v.id);
        __is->read(v.n);
    }
};

#if defined(ICE_HAS_DECLSPEC_IMPORT_EXPORT) && !defined(ICE_STORM_SERVICE_API_EXPORTS)
template struct ICE_STORM_SERVICE_API StreamWriter< ::IceStormElection::NodeInfo, ::IceInternal::BasicStream>;
template struct ICE_STORM_SERVICE_API StreamReader< ::IceStormElection::NodeInfo, ::IceInternal::BasicStream>;
#endif

template<>
struct StreamableTraits< ::IceStormElection::GroupInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 20;
    static const bool fixedLength = true;
};

template<class S>
struct StreamWriter< ::IceStormElection::GroupInfo, S>
{
    static void write(S* __os, const ::IceStormElection::GroupInfo& v)
    {
        __os->write(v.id);
        __os->write(v.llu);
    }
};

template<class S>
struct StreamReader< ::IceStormElection::GroupInfo, S>
{
    static void read(S* __is, ::IceStormElection::GroupInfo& v)
    {
        __is->read(v.id);
        __is->read(v.llu);
    }
};

#if defined(ICE_HAS_DECLSPEC_IMPORT_EXPORT) && !defined(ICE_STORM_SERVICE_API_EXPORTS)
template struct ICE_STORM_SERVICE_API StreamWriter< ::IceStormElection::GroupInfo, ::IceInternal::BasicStream>;
template struct ICE_STORM_SERVICE_API StreamReader< ::IceStormElection::GroupInfo, ::IceInternal::BasicStream>;
#endif

template<>
struct StreamableTraits< ::IceStormElection::QueryInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 17;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::IceStormElection::QueryInfo, S>
{
    static void write(S* __os, const ::IceStormElection::QueryInfo& v)
    {
        __os->write(v.id);
        __os->write(v.coord);
        __os->write(v.group);
        __os->write(v.replica);
        __os->write(v.state);
        __os->write(v.up);
        __os->write(v.max);
    }
};

template<class S>
struct StreamReader< ::IceStormElection::QueryInfo, S>
{
    static void read(S* __is, ::IceStormElection::QueryInfo& v)
    {
        __is->read(v.id);
        __is->read(v.coord);
        __is->read(v.group);
        __is->read(v.replica);
        __is->read(v.state);
        __is->read(v.up);
        __is->read(v.max);
    }
};

#if defined(ICE_HAS_DECLSPEC_IMPORT_EXPORT) && !defined(ICE_STORM_SERVICE_API_EXPORTS)
template struct ICE_STORM_SERVICE_API StreamWriter< ::IceStormElection::QueryInfo, ::IceInternal::BasicStream>;
template struct ICE_STORM_SERVICE_API StreamReader< ::IceStormElection::QueryInfo, ::IceInternal::BasicStream>;
#endif

}

namespace IceStormElection
{

class Callback_ReplicaObserver_init_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ReplicaObserver_init_Base> Callback_ReplicaObserver_initPtr;

class Callback_ReplicaObserver_createTopic_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ReplicaObserver_createTopic_Base> Callback_ReplicaObserver_createTopicPtr;

class Callback_ReplicaObserver_destroyTopic_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ReplicaObserver_destroyTopic_Base> Callback_ReplicaObserver_destroyTopicPtr;

class Callback_ReplicaObserver_addSubscriber_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ReplicaObserver_addSubscriber_Base> Callback_ReplicaObserver_addSubscriberPtr;

class Callback_ReplicaObserver_removeSubscriber_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ReplicaObserver_removeSubscriber_Base> Callback_ReplicaObserver_removeSubscriberPtr;

class Callback_TopicManagerSync_getContent_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TopicManagerSync_getContent_Base> Callback_TopicManagerSync_getContentPtr;

class Callback_Node_invitation_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Node_invitation_Base> Callback_Node_invitationPtr;

class Callback_Node_ready_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Node_ready_Base> Callback_Node_readyPtr;

class Callback_Node_accept_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Node_accept_Base> Callback_Node_acceptPtr;

class Callback_Node_areYouCoordinator_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Node_areYouCoordinator_Base> Callback_Node_areYouCoordinatorPtr;

class Callback_Node_areYouThere_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Node_areYouThere_Base> Callback_Node_areYouTherePtr;

class Callback_Node_sync_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Node_sync_Base> Callback_Node_syncPtr;

class Callback_Node_nodes_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Node_nodes_Base> Callback_Node_nodesPtr;

class Callback_Node_query_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Node_query_Base> Callback_Node_queryPtr;

}

namespace IceProxy
{

namespace IceStormElection
{

class ReplicaObserver : virtual public ::IceProxy::Ice::Object
{
public:

    void init(const ::IceStormElection::LogUpdate& llu, const ::IceStormElection::TopicContentSeq& content)
    {
        init(llu, content, 0);
    }
    void init(const ::IceStormElection::LogUpdate& llu, const ::IceStormElection::TopicContentSeq& content, const ::Ice::Context& __ctx)
    {
        init(llu, content, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_init(const ::IceStormElection::LogUpdate& llu, const ::IceStormElection::TopicContentSeq& content, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_init(llu, content, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_init(const ::IceStormElection::LogUpdate& llu, const ::IceStormElection::TopicContentSeq& content, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_init(llu, content, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_init(const ::IceStormElection::LogUpdate& llu, const ::IceStormElection::TopicContentSeq& content, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_init(llu, content, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_init(const ::IceStormElection::LogUpdate& llu, const ::IceStormElection::TopicContentSeq& content, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_init(llu, content, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_init(const ::IceStormElection::LogUpdate& llu, const ::IceStormElection::TopicContentSeq& content, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::IceStormElection::ReplicaObserverPrx __proxy = ::IceStormElection::ReplicaObserverPrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_init(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_init(llu, content, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_init(const ::IceStormElection::LogUpdate& llu, const ::IceStormElection::TopicContentSeq& content)
    {
        return begin_init(llu, content, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_init(const ::IceStormElection::LogUpdate& llu, const ::IceStormElection::TopicContentSeq& content, const ::Ice::Context& __ctx)
    {
        return begin_init(llu, content, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_init(const ::IceStormElection::LogUpdate& llu, const ::IceStormElection::TopicContentSeq& content, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_init(llu, content, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_init(const ::IceStormElection::LogUpdate& llu, const ::IceStormElection::TopicContentSeq& content, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_init(llu, content, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_init(const ::IceStormElection::LogUpdate& llu, const ::IceStormElection::TopicContentSeq& content, const ::IceStormElection::Callback_ReplicaObserver_initPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_init(llu, content, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_init(const ::IceStormElection::LogUpdate& llu, const ::IceStormElection::TopicContentSeq& content, const ::Ice::Context& __ctx, const ::IceStormElection::Callback_ReplicaObserver_initPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_init(llu, content, &__ctx, __del, __cookie);
    }

    ICE_STORM_SERVICE_API void end_init(const ::Ice::AsyncResultPtr&);
    
private:

    ICE_STORM_SERVICE_API void init(const ::IceStormElection::LogUpdate&, const ::IceStormElection::TopicContentSeq&, const ::Ice::Context*);
    ICE_STORM_SERVICE_API ::Ice::AsyncResultPtr begin_init(const ::IceStormElection::LogUpdate&, const ::IceStormElection::TopicContentSeq&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void createTopic(const ::IceStormElection::LogUpdate& llu, const ::std::string& name)
    {
        createTopic(llu, name, 0);
    }
    void createTopic(const ::IceStormElection::LogUpdate& llu, const ::std::string& name, const ::Ice::Context& __ctx)
    {
        createTopic(llu, name, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_createTopic(const ::IceStormElection::LogUpdate& llu, const ::std::string& name, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_createTopic(llu, name, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_createTopic(const ::IceStormElection::LogUpdate& llu, const ::std::string& name, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_createTopic(llu, name, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_createTopic(const ::IceStormElection::LogUpdate& llu, const ::std::string& name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_createTopic(llu, name, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_createTopic(const ::IceStormElection::LogUpdate& llu, const ::std::string& name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_createTopic(llu, name, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_createTopic(const ::IceStormElection::LogUpdate& llu, const ::std::string& name, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::IceStormElection::ReplicaObserverPrx __proxy = ::IceStormElection::ReplicaObserverPrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_createTopic(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_createTopic(llu, name, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_createTopic(const ::IceStormElection::LogUpdate& llu, const ::std::string& name)
    {
        return begin_createTopic(llu, name, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createTopic(const ::IceStormElection::LogUpdate& llu, const ::std::string& name, const ::Ice::Context& __ctx)
    {
        return begin_createTopic(llu, name, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createTopic(const ::IceStormElection::LogUpdate& llu, const ::std::string& name, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createTopic(llu, name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createTopic(const ::IceStormElection::LogUpdate& llu, const ::std::string& name, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createTopic(llu, name, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createTopic(const ::IceStormElection::LogUpdate& llu, const ::std::string& name, const ::IceStormElection::Callback_ReplicaObserver_createTopicPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createTopic(llu, name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createTopic(const ::IceStormElection::LogUpdate& llu, const ::std::string& name, const ::Ice::Context& __ctx, const ::IceStormElection::Callback_ReplicaObserver_createTopicPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createTopic(llu, name, &__ctx, __del, __cookie);
    }

    ICE_STORM_SERVICE_API void end_createTopic(const ::Ice::AsyncResultPtr&);
    
private:

    ICE_STORM_SERVICE_API void createTopic(const ::IceStormElection::LogUpdate&, const ::std::string&, const ::Ice::Context*);
    ICE_STORM_SERVICE_API ::Ice::AsyncResultPtr begin_createTopic(const ::IceStormElection::LogUpdate&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void destroyTopic(const ::IceStormElection::LogUpdate& llu, const ::std::string& name)
    {
        destroyTopic(llu, name, 0);
    }
    void destroyTopic(const ::IceStormElection::LogUpdate& llu, const ::std::string& name, const ::Ice::Context& __ctx)
    {
        destroyTopic(llu, name, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_destroyTopic(const ::IceStormElection::LogUpdate& llu, const ::std::string& name, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_destroyTopic(llu, name, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_destroyTopic(const ::IceStormElection::LogUpdate& llu, const ::std::string& name, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_destroyTopic(llu, name, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_destroyTopic(const ::IceStormElection::LogUpdate& llu, const ::std::string& name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_destroyTopic(llu, name, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_destroyTopic(const ::IceStormElection::LogUpdate& llu, const ::std::string& name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_destroyTopic(llu, name, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_destroyTopic(const ::IceStormElection::LogUpdate& llu, const ::std::string& name, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::IceStormElection::ReplicaObserverPrx __proxy = ::IceStormElection::ReplicaObserverPrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_destroyTopic(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_destroyTopic(llu, name, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_destroyTopic(const ::IceStormElection::LogUpdate& llu, const ::std::string& name)
    {
        return begin_destroyTopic(llu, name, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_destroyTopic(const ::IceStormElection::LogUpdate& llu, const ::std::string& name, const ::Ice::Context& __ctx)
    {
        return begin_destroyTopic(llu, name, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_destroyTopic(const ::IceStormElection::LogUpdate& llu, const ::std::string& name, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_destroyTopic(llu, name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_destroyTopic(const ::IceStormElection::LogUpdate& llu, const ::std::string& name, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_destroyTopic(llu, name, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_destroyTopic(const ::IceStormElection::LogUpdate& llu, const ::std::string& name, const ::IceStormElection::Callback_ReplicaObserver_destroyTopicPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_destroyTopic(llu, name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_destroyTopic(const ::IceStormElection::LogUpdate& llu, const ::std::string& name, const ::Ice::Context& __ctx, const ::IceStormElection::Callback_ReplicaObserver_destroyTopicPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_destroyTopic(llu, name, &__ctx, __del, __cookie);
    }

    ICE_STORM_SERVICE_API void end_destroyTopic(const ::Ice::AsyncResultPtr&);
    
private:

    ICE_STORM_SERVICE_API void destroyTopic(const ::IceStormElection::LogUpdate&, const ::std::string&, const ::Ice::Context*);
    ICE_STORM_SERVICE_API ::Ice::AsyncResultPtr begin_destroyTopic(const ::IceStormElection::LogUpdate&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void addSubscriber(const ::IceStormElection::LogUpdate& llu, const ::std::string& topic, const ::IceStorm::SubscriberRecord& record)
    {
        addSubscriber(llu, topic, record, 0);
    }
    void addSubscriber(const ::IceStormElection::LogUpdate& llu, const ::std::string& topic, const ::IceStorm::SubscriberRecord& record, const ::Ice::Context& __ctx)
    {
        addSubscriber(llu, topic, record, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_addSubscriber(const ::IceStormElection::LogUpdate& llu, const ::std::string& topic, const ::IceStorm::SubscriberRecord& record, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_addSubscriber(llu, topic, record, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_addSubscriber(const ::IceStormElection::LogUpdate& llu, const ::std::string& topic, const ::IceStorm::SubscriberRecord& record, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_addSubscriber(llu, topic, record, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_addSubscriber(const ::IceStormElection::LogUpdate& llu, const ::std::string& topic, const ::IceStorm::SubscriberRecord& record, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_addSubscriber(llu, topic, record, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_addSubscriber(const ::IceStormElection::LogUpdate& llu, const ::std::string& topic, const ::IceStorm::SubscriberRecord& record, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_addSubscriber(llu, topic, record, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_addSubscriber(const ::IceStormElection::LogUpdate& llu, const ::std::string& topic, const ::IceStorm::SubscriberRecord& record, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::IceStormElection::ReplicaObserverPrx __proxy = ::IceStormElection::ReplicaObserverPrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_addSubscriber(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_addSubscriber(llu, topic, record, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_addSubscriber(const ::IceStormElection::LogUpdate& llu, const ::std::string& topic, const ::IceStorm::SubscriberRecord& record)
    {
        return begin_addSubscriber(llu, topic, record, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addSubscriber(const ::IceStormElection::LogUpdate& llu, const ::std::string& topic, const ::IceStorm::SubscriberRecord& record, const ::Ice::Context& __ctx)
    {
        return begin_addSubscriber(llu, topic, record, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addSubscriber(const ::IceStormElection::LogUpdate& llu, const ::std::string& topic, const ::IceStorm::SubscriberRecord& record, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addSubscriber(llu, topic, record, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addSubscriber(const ::IceStormElection::LogUpdate& llu, const ::std::string& topic, const ::IceStorm::SubscriberRecord& record, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addSubscriber(llu, topic, record, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addSubscriber(const ::IceStormElection::LogUpdate& llu, const ::std::string& topic, const ::IceStorm::SubscriberRecord& record, const ::IceStormElection::Callback_ReplicaObserver_addSubscriberPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addSubscriber(llu, topic, record, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addSubscriber(const ::IceStormElection::LogUpdate& llu, const ::std::string& topic, const ::IceStorm::SubscriberRecord& record, const ::Ice::Context& __ctx, const ::IceStormElection::Callback_ReplicaObserver_addSubscriberPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addSubscriber(llu, topic, record, &__ctx, __del, __cookie);
    }

    ICE_STORM_SERVICE_API void end_addSubscriber(const ::Ice::AsyncResultPtr&);
    
private:

    ICE_STORM_SERVICE_API void addSubscriber(const ::IceStormElection::LogUpdate&, const ::std::string&, const ::IceStorm::SubscriberRecord&, const ::Ice::Context*);
    ICE_STORM_SERVICE_API ::Ice::AsyncResultPtr begin_addSubscriber(const ::IceStormElection::LogUpdate&, const ::std::string&, const ::IceStorm::SubscriberRecord&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void removeSubscriber(const ::IceStormElection::LogUpdate& llu, const ::std::string& topic, const ::Ice::IdentitySeq& subscribers)
    {
        removeSubscriber(llu, topic, subscribers, 0);
    }
    void removeSubscriber(const ::IceStormElection::LogUpdate& llu, const ::std::string& topic, const ::Ice::IdentitySeq& subscribers, const ::Ice::Context& __ctx)
    {
        removeSubscriber(llu, topic, subscribers, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_removeSubscriber(const ::IceStormElection::LogUpdate& llu, const ::std::string& topic, const ::Ice::IdentitySeq& subscribers, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_removeSubscriber(llu, topic, subscribers, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_removeSubscriber(const ::IceStormElection::LogUpdate& llu, const ::std::string& topic, const ::Ice::IdentitySeq& subscribers, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_removeSubscriber(llu, topic, subscribers, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_removeSubscriber(const ::IceStormElection::LogUpdate& llu, const ::std::string& topic, const ::Ice::IdentitySeq& subscribers, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_removeSubscriber(llu, topic, subscribers, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_removeSubscriber(const ::IceStormElection::LogUpdate& llu, const ::std::string& topic, const ::Ice::IdentitySeq& subscribers, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_removeSubscriber(llu, topic, subscribers, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_removeSubscriber(const ::IceStormElection::LogUpdate& llu, const ::std::string& topic, const ::Ice::IdentitySeq& subscribers, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::IceStormElection::ReplicaObserverPrx __proxy = ::IceStormElection::ReplicaObserverPrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_removeSubscriber(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_removeSubscriber(llu, topic, subscribers, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_removeSubscriber(const ::IceStormElection::LogUpdate& llu, const ::std::string& topic, const ::Ice::IdentitySeq& subscribers)
    {
        return begin_removeSubscriber(llu, topic, subscribers, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeSubscriber(const ::IceStormElection::LogUpdate& llu, const ::std::string& topic, const ::Ice::IdentitySeq& subscribers, const ::Ice::Context& __ctx)
    {
        return begin_removeSubscriber(llu, topic, subscribers, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeSubscriber(const ::IceStormElection::LogUpdate& llu, const ::std::string& topic, const ::Ice::IdentitySeq& subscribers, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeSubscriber(llu, topic, subscribers, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeSubscriber(const ::IceStormElection::LogUpdate& llu, const ::std::string& topic, const ::Ice::IdentitySeq& subscribers, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeSubscriber(llu, topic, subscribers, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeSubscriber(const ::IceStormElection::LogUpdate& llu, const ::std::string& topic, const ::Ice::IdentitySeq& subscribers, const ::IceStormElection::Callback_ReplicaObserver_removeSubscriberPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeSubscriber(llu, topic, subscribers, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeSubscriber(const ::IceStormElection::LogUpdate& llu, const ::std::string& topic, const ::Ice::IdentitySeq& subscribers, const ::Ice::Context& __ctx, const ::IceStormElection::Callback_ReplicaObserver_removeSubscriberPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeSubscriber(llu, topic, subscribers, &__ctx, __del, __cookie);
    }

    ICE_STORM_SERVICE_API void end_removeSubscriber(const ::Ice::AsyncResultPtr&);
    
private:

    ICE_STORM_SERVICE_API void removeSubscriber(const ::IceStormElection::LogUpdate&, const ::std::string&, const ::Ice::IdentitySeq&, const ::Ice::Context*);
    ICE_STORM_SERVICE_API ::Ice::AsyncResultPtr begin_removeSubscriber(const ::IceStormElection::LogUpdate&, const ::std::string&, const ::Ice::IdentitySeq&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<ReplicaObserver> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<ReplicaObserver*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<ReplicaObserver> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<ReplicaObserver*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<ReplicaObserver> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<ReplicaObserver*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<ReplicaObserver> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<ReplicaObserver*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<ReplicaObserver> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<ReplicaObserver*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<ReplicaObserver> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<ReplicaObserver*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<ReplicaObserver> ice_secure(bool __secure) const
    {
        return dynamic_cast<ReplicaObserver*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<ReplicaObserver> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<ReplicaObserver*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<ReplicaObserver> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<ReplicaObserver*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<ReplicaObserver> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<ReplicaObserver*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<ReplicaObserver> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<ReplicaObserver*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<ReplicaObserver> ice_twoway() const
    {
        return dynamic_cast<ReplicaObserver*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<ReplicaObserver> ice_oneway() const
    {
        return dynamic_cast<ReplicaObserver*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<ReplicaObserver> ice_batchOneway() const
    {
        return dynamic_cast<ReplicaObserver*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<ReplicaObserver> ice_datagram() const
    {
        return dynamic_cast<ReplicaObserver*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<ReplicaObserver> ice_batchDatagram() const
    {
        return dynamic_cast<ReplicaObserver*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<ReplicaObserver> ice_compress(bool __compress) const
    {
        return dynamic_cast<ReplicaObserver*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<ReplicaObserver> ice_timeout(int __timeout) const
    {
        return dynamic_cast<ReplicaObserver*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<ReplicaObserver> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<ReplicaObserver*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<ReplicaObserver> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<ReplicaObserver*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    ICE_STORM_SERVICE_API static const ::std::string& ice_staticId();

private: 

    ICE_STORM_SERVICE_API virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    ICE_STORM_SERVICE_API virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    ICE_STORM_SERVICE_API virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class TopicManagerSync : virtual public ::IceProxy::Ice::Object
{
public:

    void getContent(::IceStormElection::LogUpdate& llu, ::IceStormElection::TopicContentSeq& content)
    {
        getContent(llu, content, 0);
    }
    void getContent(::IceStormElection::LogUpdate& llu, ::IceStormElection::TopicContentSeq& content, const ::Ice::Context& __ctx)
    {
        getContent(llu, content, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getContent(const ::IceInternal::Function<void (const ::IceStormElection::LogUpdate&, const ::IceStormElection::TopicContentSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getContent(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getContent(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getContent(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getContent(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::IceStormElection::LogUpdate&, const ::IceStormElection::TopicContentSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getContent(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getContent(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getContent(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getContent(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::IceStormElection::LogUpdate&, const ::IceStormElection::TopicContentSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::IceStormElection::LogUpdate&, const ::IceStormElection::TopicContentSeq&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::IceStormElection::TopicManagerSyncPrx __proxy = ::IceStormElection::TopicManagerSyncPrx::uncheckedCast(__result->getProxy());
                ::IceStormElection::LogUpdate llu;
                ::IceStormElection::TopicContentSeq content;
                try
                {
                    __proxy->end_getContent(llu, content, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(llu, content);
                }
            }
        
        private:
            
            ::std::function<void (const ::IceStormElection::LogUpdate&, const ::IceStormElection::TopicContentSeq&)> _response;
        };
        return begin_getContent(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getContent()
    {
        return begin_getContent(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getContent(const ::Ice::Context& __ctx)
    {
        return begin_getContent(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getContent(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getContent(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getContent(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getContent(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getContent(const ::IceStormElection::Callback_TopicManagerSync_getContentPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getContent(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getContent(const ::Ice::Context& __ctx, const ::IceStormElection::Callback_TopicManagerSync_getContentPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getContent(&__ctx, __del, __cookie);
    }

    ICE_STORM_SERVICE_API void end_getContent(::IceStormElection::LogUpdate& llu, ::IceStormElection::TopicContentSeq& content, const ::Ice::AsyncResultPtr&);
    
private:

    ICE_STORM_SERVICE_API void getContent(::IceStormElection::LogUpdate&, ::IceStormElection::TopicContentSeq&, const ::Ice::Context*);
    ICE_STORM_SERVICE_API ::Ice::AsyncResultPtr begin_getContent(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<TopicManagerSync> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<TopicManagerSync*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<TopicManagerSync> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<TopicManagerSync*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<TopicManagerSync> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<TopicManagerSync*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<TopicManagerSync> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<TopicManagerSync*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<TopicManagerSync> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<TopicManagerSync*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<TopicManagerSync> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<TopicManagerSync*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<TopicManagerSync> ice_secure(bool __secure) const
    {
        return dynamic_cast<TopicManagerSync*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<TopicManagerSync> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<TopicManagerSync*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<TopicManagerSync> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<TopicManagerSync*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<TopicManagerSync> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<TopicManagerSync*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<TopicManagerSync> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<TopicManagerSync*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<TopicManagerSync> ice_twoway() const
    {
        return dynamic_cast<TopicManagerSync*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<TopicManagerSync> ice_oneway() const
    {
        return dynamic_cast<TopicManagerSync*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<TopicManagerSync> ice_batchOneway() const
    {
        return dynamic_cast<TopicManagerSync*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<TopicManagerSync> ice_datagram() const
    {
        return dynamic_cast<TopicManagerSync*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<TopicManagerSync> ice_batchDatagram() const
    {
        return dynamic_cast<TopicManagerSync*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<TopicManagerSync> ice_compress(bool __compress) const
    {
        return dynamic_cast<TopicManagerSync*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<TopicManagerSync> ice_timeout(int __timeout) const
    {
        return dynamic_cast<TopicManagerSync*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<TopicManagerSync> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<TopicManagerSync*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<TopicManagerSync> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<TopicManagerSync*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    ICE_STORM_SERVICE_API static const ::std::string& ice_staticId();

private: 

    ICE_STORM_SERVICE_API virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    ICE_STORM_SERVICE_API virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    ICE_STORM_SERVICE_API virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class Node : virtual public ::IceProxy::Ice::Object
{
public:

    void invitation(::Ice::Int j, const ::std::string& gn)
    {
        invitation(j, gn, 0);
    }
    void invitation(::Ice::Int j, const ::std::string& gn, const ::Ice::Context& __ctx)
    {
        invitation(j, gn, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_invitation(::Ice::Int j, const ::std::string& gn, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_invitation(j, gn, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_invitation(::Ice::Int j, const ::std::string& gn, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_invitation(j, gn, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_invitation(::Ice::Int j, const ::std::string& gn, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_invitation(j, gn, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_invitation(::Ice::Int j, const ::std::string& gn, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_invitation(j, gn, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_invitation(::Ice::Int j, const ::std::string& gn)
    {
        return begin_invitation(j, gn, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_invitation(::Ice::Int j, const ::std::string& gn, const ::Ice::Context& __ctx)
    {
        return begin_invitation(j, gn, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_invitation(::Ice::Int j, const ::std::string& gn, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_invitation(j, gn, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_invitation(::Ice::Int j, const ::std::string& gn, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_invitation(j, gn, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_invitation(::Ice::Int j, const ::std::string& gn, const ::IceStormElection::Callback_Node_invitationPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_invitation(j, gn, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_invitation(::Ice::Int j, const ::std::string& gn, const ::Ice::Context& __ctx, const ::IceStormElection::Callback_Node_invitationPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_invitation(j, gn, &__ctx, __del, __cookie);
    }

    ICE_STORM_SERVICE_API void end_invitation(const ::Ice::AsyncResultPtr&);
    
private:

    ICE_STORM_SERVICE_API void invitation(::Ice::Int, const ::std::string&, const ::Ice::Context*);
    ICE_STORM_SERVICE_API ::Ice::AsyncResultPtr begin_invitation(::Ice::Int, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void ready(::Ice::Int j, const ::std::string& gn, const ::Ice::ObjectPrx& coordinator, ::Ice::Int max, ::Ice::Long generation)
    {
        ready(j, gn, coordinator, max, generation, 0);
    }
    void ready(::Ice::Int j, const ::std::string& gn, const ::Ice::ObjectPrx& coordinator, ::Ice::Int max, ::Ice::Long generation, const ::Ice::Context& __ctx)
    {
        ready(j, gn, coordinator, max, generation, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_ready(::Ice::Int j, const ::std::string& gn, const ::Ice::ObjectPrx& coordinator, ::Ice::Int max, ::Ice::Long generation, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_ready(j, gn, coordinator, max, generation, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_ready(::Ice::Int j, const ::std::string& gn, const ::Ice::ObjectPrx& coordinator, ::Ice::Int max, ::Ice::Long generation, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_ready(j, gn, coordinator, max, generation, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_ready(::Ice::Int j, const ::std::string& gn, const ::Ice::ObjectPrx& coordinator, ::Ice::Int max, ::Ice::Long generation, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_ready(j, gn, coordinator, max, generation, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_ready(::Ice::Int j, const ::std::string& gn, const ::Ice::ObjectPrx& coordinator, ::Ice::Int max, ::Ice::Long generation, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_ready(j, gn, coordinator, max, generation, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_ready(::Ice::Int j, const ::std::string& gn, const ::Ice::ObjectPrx& coordinator, ::Ice::Int max, ::Ice::Long generation)
    {
        return begin_ready(j, gn, coordinator, max, generation, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ready(::Ice::Int j, const ::std::string& gn, const ::Ice::ObjectPrx& coordinator, ::Ice::Int max, ::Ice::Long generation, const ::Ice::Context& __ctx)
    {
        return begin_ready(j, gn, coordinator, max, generation, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ready(::Ice::Int j, const ::std::string& gn, const ::Ice::ObjectPrx& coordinator, ::Ice::Int max, ::Ice::Long generation, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ready(j, gn, coordinator, max, generation, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ready(::Ice::Int j, const ::std::string& gn, const ::Ice::ObjectPrx& coordinator, ::Ice::Int max, ::Ice::Long generation, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ready(j, gn, coordinator, max, generation, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ready(::Ice::Int j, const ::std::string& gn, const ::Ice::ObjectPrx& coordinator, ::Ice::Int max, ::Ice::Long generation, const ::IceStormElection::Callback_Node_readyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ready(j, gn, coordinator, max, generation, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ready(::Ice::Int j, const ::std::string& gn, const ::Ice::ObjectPrx& coordinator, ::Ice::Int max, ::Ice::Long generation, const ::Ice::Context& __ctx, const ::IceStormElection::Callback_Node_readyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ready(j, gn, coordinator, max, generation, &__ctx, __del, __cookie);
    }

    ICE_STORM_SERVICE_API void end_ready(const ::Ice::AsyncResultPtr&);
    
private:

    ICE_STORM_SERVICE_API void ready(::Ice::Int, const ::std::string&, const ::Ice::ObjectPrx&, ::Ice::Int, ::Ice::Long, const ::Ice::Context*);
    ICE_STORM_SERVICE_API ::Ice::AsyncResultPtr begin_ready(::Ice::Int, const ::std::string&, const ::Ice::ObjectPrx&, ::Ice::Int, ::Ice::Long, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void accept(::Ice::Int j, const ::std::string& gn, const ::Ice::IntSeq& forwardedInvites, const ::Ice::ObjectPrx& observer, const ::IceStormElection::LogUpdate& llu, ::Ice::Int max)
    {
        accept(j, gn, forwardedInvites, observer, llu, max, 0);
    }
    void accept(::Ice::Int j, const ::std::string& gn, const ::Ice::IntSeq& forwardedInvites, const ::Ice::ObjectPrx& observer, const ::IceStormElection::LogUpdate& llu, ::Ice::Int max, const ::Ice::Context& __ctx)
    {
        accept(j, gn, forwardedInvites, observer, llu, max, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_accept(::Ice::Int j, const ::std::string& gn, const ::Ice::IntSeq& forwardedInvites, const ::Ice::ObjectPrx& observer, const ::IceStormElection::LogUpdate& llu, ::Ice::Int max, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_accept(j, gn, forwardedInvites, observer, llu, max, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_accept(::Ice::Int j, const ::std::string& gn, const ::Ice::IntSeq& forwardedInvites, const ::Ice::ObjectPrx& observer, const ::IceStormElection::LogUpdate& llu, ::Ice::Int max, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_accept(j, gn, forwardedInvites, observer, llu, max, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_accept(::Ice::Int j, const ::std::string& gn, const ::Ice::IntSeq& forwardedInvites, const ::Ice::ObjectPrx& observer, const ::IceStormElection::LogUpdate& llu, ::Ice::Int max, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_accept(j, gn, forwardedInvites, observer, llu, max, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_accept(::Ice::Int j, const ::std::string& gn, const ::Ice::IntSeq& forwardedInvites, const ::Ice::ObjectPrx& observer, const ::IceStormElection::LogUpdate& llu, ::Ice::Int max, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_accept(j, gn, forwardedInvites, observer, llu, max, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_accept(::Ice::Int j, const ::std::string& gn, const ::Ice::IntSeq& forwardedInvites, const ::Ice::ObjectPrx& observer, const ::IceStormElection::LogUpdate& llu, ::Ice::Int max)
    {
        return begin_accept(j, gn, forwardedInvites, observer, llu, max, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_accept(::Ice::Int j, const ::std::string& gn, const ::Ice::IntSeq& forwardedInvites, const ::Ice::ObjectPrx& observer, const ::IceStormElection::LogUpdate& llu, ::Ice::Int max, const ::Ice::Context& __ctx)
    {
        return begin_accept(j, gn, forwardedInvites, observer, llu, max, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_accept(::Ice::Int j, const ::std::string& gn, const ::Ice::IntSeq& forwardedInvites, const ::Ice::ObjectPrx& observer, const ::IceStormElection::LogUpdate& llu, ::Ice::Int max, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_accept(j, gn, forwardedInvites, observer, llu, max, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_accept(::Ice::Int j, const ::std::string& gn, const ::Ice::IntSeq& forwardedInvites, const ::Ice::ObjectPrx& observer, const ::IceStormElection::LogUpdate& llu, ::Ice::Int max, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_accept(j, gn, forwardedInvites, observer, llu, max, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_accept(::Ice::Int j, const ::std::string& gn, const ::Ice::IntSeq& forwardedInvites, const ::Ice::ObjectPrx& observer, const ::IceStormElection::LogUpdate& llu, ::Ice::Int max, const ::IceStormElection::Callback_Node_acceptPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_accept(j, gn, forwardedInvites, observer, llu, max, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_accept(::Ice::Int j, const ::std::string& gn, const ::Ice::IntSeq& forwardedInvites, const ::Ice::ObjectPrx& observer, const ::IceStormElection::LogUpdate& llu, ::Ice::Int max, const ::Ice::Context& __ctx, const ::IceStormElection::Callback_Node_acceptPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_accept(j, gn, forwardedInvites, observer, llu, max, &__ctx, __del, __cookie);
    }

    ICE_STORM_SERVICE_API void end_accept(const ::Ice::AsyncResultPtr&);
    
private:

    ICE_STORM_SERVICE_API void accept(::Ice::Int, const ::std::string&, const ::Ice::IntSeq&, const ::Ice::ObjectPrx&, const ::IceStormElection::LogUpdate&, ::Ice::Int, const ::Ice::Context*);
    ICE_STORM_SERVICE_API ::Ice::AsyncResultPtr begin_accept(::Ice::Int, const ::std::string&, const ::Ice::IntSeq&, const ::Ice::ObjectPrx&, const ::IceStormElection::LogUpdate&, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool areYouCoordinator()
    {
        return areYouCoordinator(0);
    }
    bool areYouCoordinator(const ::Ice::Context& __ctx)
    {
        return areYouCoordinator(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_areYouCoordinator(const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_areYouCoordinator(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_areYouCoordinator(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_areYouCoordinator(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_areYouCoordinator(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_areYouCoordinator(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_areYouCoordinator(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_areYouCoordinator(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_areYouCoordinator(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (bool)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::IceStormElection::NodePrx __proxy = ::IceStormElection::NodePrx::uncheckedCast(__result->getProxy());
                bool __ret;
                try
                {
                    __ret = __proxy->end_areYouCoordinator(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (bool)> _response;
        };
        return begin_areYouCoordinator(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_areYouCoordinator()
    {
        return begin_areYouCoordinator(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_areYouCoordinator(const ::Ice::Context& __ctx)
    {
        return begin_areYouCoordinator(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_areYouCoordinator(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_areYouCoordinator(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_areYouCoordinator(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_areYouCoordinator(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_areYouCoordinator(const ::IceStormElection::Callback_Node_areYouCoordinatorPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_areYouCoordinator(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_areYouCoordinator(const ::Ice::Context& __ctx, const ::IceStormElection::Callback_Node_areYouCoordinatorPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_areYouCoordinator(&__ctx, __del, __cookie);
    }

    ICE_STORM_SERVICE_API bool end_areYouCoordinator(const ::Ice::AsyncResultPtr&);
    
private:

    ICE_STORM_SERVICE_API bool areYouCoordinator(const ::Ice::Context*);
    ICE_STORM_SERVICE_API ::Ice::AsyncResultPtr begin_areYouCoordinator(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool areYouThere(const ::std::string& gn, ::Ice::Int j)
    {
        return areYouThere(gn, j, 0);
    }
    bool areYouThere(const ::std::string& gn, ::Ice::Int j, const ::Ice::Context& __ctx)
    {
        return areYouThere(gn, j, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_areYouThere(const ::std::string& gn, ::Ice::Int j, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_areYouThere(gn, j, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_areYouThere(const ::std::string& gn, ::Ice::Int j, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_areYouThere(gn, j, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_areYouThere(const ::std::string& gn, ::Ice::Int j, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_areYouThere(gn, j, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_areYouThere(const ::std::string& gn, ::Ice::Int j, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_areYouThere(gn, j, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_areYouThere(const ::std::string& gn, ::Ice::Int j, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (bool)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::IceStormElection::NodePrx __proxy = ::IceStormElection::NodePrx::uncheckedCast(__result->getProxy());
                bool __ret;
                try
                {
                    __ret = __proxy->end_areYouThere(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (bool)> _response;
        };
        return begin_areYouThere(gn, j, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_areYouThere(const ::std::string& gn, ::Ice::Int j)
    {
        return begin_areYouThere(gn, j, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_areYouThere(const ::std::string& gn, ::Ice::Int j, const ::Ice::Context& __ctx)
    {
        return begin_areYouThere(gn, j, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_areYouThere(const ::std::string& gn, ::Ice::Int j, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_areYouThere(gn, j, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_areYouThere(const ::std::string& gn, ::Ice::Int j, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_areYouThere(gn, j, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_areYouThere(const ::std::string& gn, ::Ice::Int j, const ::IceStormElection::Callback_Node_areYouTherePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_areYouThere(gn, j, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_areYouThere(const ::std::string& gn, ::Ice::Int j, const ::Ice::Context& __ctx, const ::IceStormElection::Callback_Node_areYouTherePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_areYouThere(gn, j, &__ctx, __del, __cookie);
    }

    ICE_STORM_SERVICE_API bool end_areYouThere(const ::Ice::AsyncResultPtr&);
    
private:

    ICE_STORM_SERVICE_API bool areYouThere(const ::std::string&, ::Ice::Int, const ::Ice::Context*);
    ICE_STORM_SERVICE_API ::Ice::AsyncResultPtr begin_areYouThere(const ::std::string&, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::ObjectPrx sync()
    {
        return sync(0);
    }
    ::Ice::ObjectPrx sync(const ::Ice::Context& __ctx)
    {
        return sync(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_sync(const ::IceInternal::Function<void (const ::Ice::ObjectPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_sync(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_sync(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_sync(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_sync(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::ObjectPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_sync(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_sync(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_sync(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_sync(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Ice::ObjectPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Ice::ObjectPrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::IceStormElection::NodePrx __proxy = ::IceStormElection::NodePrx::uncheckedCast(__result->getProxy());
                ::Ice::ObjectPrx __ret;
                try
                {
                    __ret = __proxy->end_sync(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Ice::ObjectPrx&)> _response;
        };
        return begin_sync(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_sync()
    {
        return begin_sync(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sync(const ::Ice::Context& __ctx)
    {
        return begin_sync(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sync(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sync(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sync(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sync(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sync(const ::IceStormElection::Callback_Node_syncPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sync(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sync(const ::Ice::Context& __ctx, const ::IceStormElection::Callback_Node_syncPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sync(&__ctx, __del, __cookie);
    }

    ICE_STORM_SERVICE_API ::Ice::ObjectPrx end_sync(const ::Ice::AsyncResultPtr&);
    
private:

    ICE_STORM_SERVICE_API ::Ice::ObjectPrx sync(const ::Ice::Context*);
    ICE_STORM_SERVICE_API ::Ice::AsyncResultPtr begin_sync(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::IceStormElection::NodeInfoSeq nodes()
    {
        return nodes(0);
    }
    ::IceStormElection::NodeInfoSeq nodes(const ::Ice::Context& __ctx)
    {
        return nodes(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_nodes(const ::IceInternal::Function<void (const ::IceStormElection::NodeInfoSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_nodes(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_nodes(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_nodes(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_nodes(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::IceStormElection::NodeInfoSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_nodes(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_nodes(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_nodes(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_nodes(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::IceStormElection::NodeInfoSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::IceStormElection::NodeInfoSeq&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::IceStormElection::NodePrx __proxy = ::IceStormElection::NodePrx::uncheckedCast(__result->getProxy());
                ::IceStormElection::NodeInfoSeq __ret;
                try
                {
                    __ret = __proxy->end_nodes(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::IceStormElection::NodeInfoSeq&)> _response;
        };
        return begin_nodes(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_nodes()
    {
        return begin_nodes(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_nodes(const ::Ice::Context& __ctx)
    {
        return begin_nodes(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_nodes(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_nodes(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_nodes(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_nodes(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_nodes(const ::IceStormElection::Callback_Node_nodesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_nodes(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_nodes(const ::Ice::Context& __ctx, const ::IceStormElection::Callback_Node_nodesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_nodes(&__ctx, __del, __cookie);
    }

    ICE_STORM_SERVICE_API ::IceStormElection::NodeInfoSeq end_nodes(const ::Ice::AsyncResultPtr&);
    
private:

    ICE_STORM_SERVICE_API ::IceStormElection::NodeInfoSeq nodes(const ::Ice::Context*);
    ICE_STORM_SERVICE_API ::Ice::AsyncResultPtr begin_nodes(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::IceStormElection::QueryInfo query()
    {
        return query(0);
    }
    ::IceStormElection::QueryInfo query(const ::Ice::Context& __ctx)
    {
        return query(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_query(const ::IceInternal::Function<void (const ::IceStormElection::QueryInfo&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_query(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_query(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_query(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_query(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::IceStormElection::QueryInfo&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_query(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_query(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_query(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_query(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::IceStormElection::QueryInfo&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::IceStormElection::QueryInfo&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::IceStormElection::NodePrx __proxy = ::IceStormElection::NodePrx::uncheckedCast(__result->getProxy());
                ::IceStormElection::QueryInfo __ret;
                try
                {
                    __ret = __proxy->end_query(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::IceStormElection::QueryInfo&)> _response;
        };
        return begin_query(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_query()
    {
        return begin_query(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_query(const ::Ice::Context& __ctx)
    {
        return begin_query(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_query(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_query(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_query(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_query(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_query(const ::IceStormElection::Callback_Node_queryPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_query(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_query(const ::Ice::Context& __ctx, const ::IceStormElection::Callback_Node_queryPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_query(&__ctx, __del, __cookie);
    }

    ICE_STORM_SERVICE_API ::IceStormElection::QueryInfo end_query(const ::Ice::AsyncResultPtr&);
    
private:

    ICE_STORM_SERVICE_API ::IceStormElection::QueryInfo query(const ::Ice::Context*);
    ICE_STORM_SERVICE_API ::Ice::AsyncResultPtr begin_query(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<Node> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_secure(bool __secure) const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_twoway() const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_oneway() const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_batchOneway() const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_datagram() const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_batchDatagram() const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_compress(bool __compress) const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_timeout(int __timeout) const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Node> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<Node*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    ICE_STORM_SERVICE_API static const ::std::string& ice_staticId();

private: 

    ICE_STORM_SERVICE_API virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    ICE_STORM_SERVICE_API virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    ICE_STORM_SERVICE_API virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

namespace IceDelegate
{

namespace IceStormElection
{

class ICE_STORM_SERVICE_API ReplicaObserver : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void init(const ::IceStormElection::LogUpdate&, const ::IceStormElection::TopicContentSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void createTopic(const ::IceStormElection::LogUpdate&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void destroyTopic(const ::IceStormElection::LogUpdate&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void addSubscriber(const ::IceStormElection::LogUpdate&, const ::std::string&, const ::IceStorm::SubscriberRecord&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void removeSubscriber(const ::IceStormElection::LogUpdate&, const ::std::string&, const ::Ice::IdentitySeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class ICE_STORM_SERVICE_API TopicManagerSync : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void getContent(::IceStormElection::LogUpdate&, ::IceStormElection::TopicContentSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class ICE_STORM_SERVICE_API Node : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void invitation(::Ice::Int, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void ready(::Ice::Int, const ::std::string&, const ::Ice::ObjectPrx&, ::Ice::Int, ::Ice::Long, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void accept(::Ice::Int, const ::std::string&, const ::Ice::IntSeq&, const ::Ice::ObjectPrx&, const ::IceStormElection::LogUpdate&, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual bool areYouCoordinator(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual bool areYouThere(const ::std::string&, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::ObjectPrx sync(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::IceStormElection::NodeInfoSeq nodes(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::IceStormElection::QueryInfo query(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

}

}

namespace IceDelegateM
{

namespace IceStormElection
{

class ICE_STORM_SERVICE_API ReplicaObserver : virtual public ::IceDelegate::IceStormElection::ReplicaObserver,
                                              virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void init(const ::IceStormElection::LogUpdate&, const ::IceStormElection::TopicContentSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void createTopic(const ::IceStormElection::LogUpdate&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void destroyTopic(const ::IceStormElection::LogUpdate&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void addSubscriber(const ::IceStormElection::LogUpdate&, const ::std::string&, const ::IceStorm::SubscriberRecord&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void removeSubscriber(const ::IceStormElection::LogUpdate&, const ::std::string&, const ::Ice::IdentitySeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class ICE_STORM_SERVICE_API TopicManagerSync : virtual public ::IceDelegate::IceStormElection::TopicManagerSync,
                                               virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void getContent(::IceStormElection::LogUpdate&, ::IceStormElection::TopicContentSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class ICE_STORM_SERVICE_API Node : virtual public ::IceDelegate::IceStormElection::Node,
                                   virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void invitation(::Ice::Int, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void ready(::Ice::Int, const ::std::string&, const ::Ice::ObjectPrx&, ::Ice::Int, ::Ice::Long, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void accept(::Ice::Int, const ::std::string&, const ::Ice::IntSeq&, const ::Ice::ObjectPrx&, const ::IceStormElection::LogUpdate&, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual bool areYouCoordinator(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual bool areYouThere(const ::std::string&, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::ObjectPrx sync(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::IceStormElection::NodeInfoSeq nodes(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::IceStormElection::QueryInfo query(const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

}

}

namespace IceDelegateD
{

namespace IceStormElection
{

class ICE_STORM_SERVICE_API ReplicaObserver : virtual public ::IceDelegate::IceStormElection::ReplicaObserver,
                                              virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void init(const ::IceStormElection::LogUpdate&, const ::IceStormElection::TopicContentSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void createTopic(const ::IceStormElection::LogUpdate&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void destroyTopic(const ::IceStormElection::LogUpdate&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void addSubscriber(const ::IceStormElection::LogUpdate&, const ::std::string&, const ::IceStorm::SubscriberRecord&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void removeSubscriber(const ::IceStormElection::LogUpdate&, const ::std::string&, const ::Ice::IdentitySeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class ICE_STORM_SERVICE_API TopicManagerSync : virtual public ::IceDelegate::IceStormElection::TopicManagerSync,
                                               virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void getContent(::IceStormElection::LogUpdate&, ::IceStormElection::TopicContentSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class ICE_STORM_SERVICE_API Node : virtual public ::IceDelegate::IceStormElection::Node,
                                   virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void invitation(::Ice::Int, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void ready(::Ice::Int, const ::std::string&, const ::Ice::ObjectPrx&, ::Ice::Int, ::Ice::Long, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void accept(::Ice::Int, const ::std::string&, const ::Ice::IntSeq&, const ::Ice::ObjectPrx&, const ::IceStormElection::LogUpdate&, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual bool areYouCoordinator(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual bool areYouThere(const ::std::string&, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::ObjectPrx sync(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::IceStormElection::NodeInfoSeq nodes(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::IceStormElection::QueryInfo query(const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

}

}

namespace IceStormElection
{

class ICE_STORM_SERVICE_API ReplicaObserver : virtual public ::Ice::Object
{
public:

    typedef ReplicaObserverPrx ProxyType;
    typedef ReplicaObserverPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void init(const ::IceStormElection::LogUpdate&, const ::IceStormElection::TopicContentSeq&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___init(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void createTopic(const ::IceStormElection::LogUpdate&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___createTopic(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void destroyTopic(const ::IceStormElection::LogUpdate&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___destroyTopic(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void addSubscriber(const ::IceStormElection::LogUpdate&, const ::std::string&, const ::IceStorm::SubscriberRecord&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___addSubscriber(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void removeSubscriber(const ::IceStormElection::LogUpdate&, const ::std::string&, const ::Ice::IdentitySeq&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___removeSubscriber(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const ReplicaObserver& l, const ReplicaObserver& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const ReplicaObserver& l, const ReplicaObserver& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ICE_STORM_SERVICE_API TopicManagerSync : virtual public ::Ice::Object
{
public:

    typedef TopicManagerSyncPrx ProxyType;
    typedef TopicManagerSyncPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void getContent(::IceStormElection::LogUpdate&, ::IceStormElection::TopicContentSeq&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getContent(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const TopicManagerSync& l, const TopicManagerSync& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const TopicManagerSync& l, const TopicManagerSync& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ICE_STORM_SERVICE_API Node : virtual public ::Ice::Object
{
public:

    typedef NodePrx ProxyType;
    typedef NodePtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void invitation(::Ice::Int, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___invitation(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void ready(::Ice::Int, const ::std::string&, const ::Ice::ObjectPrx&, ::Ice::Int, ::Ice::Long, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___ready(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void accept(::Ice::Int, const ::std::string&, const ::Ice::IntSeq&, const ::Ice::ObjectPrx&, const ::IceStormElection::LogUpdate&, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___accept(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool areYouCoordinator(const ::Ice::Current& = ::Ice::Current()) const = 0;
    ::Ice::DispatchStatus ___areYouCoordinator(::IceInternal::Incoming&, const ::Ice::Current&) const;

    virtual bool areYouThere(const ::std::string&, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) const = 0;
    ::Ice::DispatchStatus ___areYouThere(::IceInternal::Incoming&, const ::Ice::Current&) const;

    virtual ::Ice::ObjectPrx sync(const ::Ice::Current& = ::Ice::Current()) const = 0;
    ::Ice::DispatchStatus ___sync(::IceInternal::Incoming&, const ::Ice::Current&) const;

    virtual ::IceStormElection::NodeInfoSeq nodes(const ::Ice::Current& = ::Ice::Current()) const = 0;
    ::Ice::DispatchStatus ___nodes(::IceInternal::Incoming&, const ::Ice::Current&) const;

    virtual ::IceStormElection::QueryInfo query(const ::Ice::Current& = ::Ice::Current()) const = 0;
    ::Ice::DispatchStatus ___query(::IceInternal::Incoming&, const ::Ice::Current&) const;

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const Node& l, const Node& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Node& l, const Node& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace IceStormElection
{

template<class T>
class CallbackNC_ReplicaObserver_init : public Callback_ReplicaObserver_init_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ReplicaObserver_init(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IceStormElection::ReplicaObserverPrx __proxy = ::IceStormElection::ReplicaObserverPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_init(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_ReplicaObserver_initPtr
newCallback_ReplicaObserver_init(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ReplicaObserver_init<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ReplicaObserver_initPtr
newCallback_ReplicaObserver_init(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ReplicaObserver_init<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ReplicaObserver_initPtr
newCallback_ReplicaObserver_init(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ReplicaObserver_init<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ReplicaObserver_initPtr
newCallback_ReplicaObserver_init(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ReplicaObserver_init<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ReplicaObserver_init : public Callback_ReplicaObserver_init_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ReplicaObserver_init(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IceStormElection::ReplicaObserverPrx __proxy = ::IceStormElection::ReplicaObserverPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_init(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ReplicaObserver_initPtr
newCallback_ReplicaObserver_init(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ReplicaObserver_init<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ReplicaObserver_initPtr
newCallback_ReplicaObserver_init(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ReplicaObserver_init<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ReplicaObserver_initPtr
newCallback_ReplicaObserver_init(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ReplicaObserver_init<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ReplicaObserver_initPtr
newCallback_ReplicaObserver_init(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ReplicaObserver_init<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ReplicaObserver_createTopic : public Callback_ReplicaObserver_createTopic_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ReplicaObserver_createTopic(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IceStormElection::ReplicaObserverPrx __proxy = ::IceStormElection::ReplicaObserverPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_createTopic(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_ReplicaObserver_createTopicPtr
newCallback_ReplicaObserver_createTopic(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ReplicaObserver_createTopic<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ReplicaObserver_createTopicPtr
newCallback_ReplicaObserver_createTopic(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ReplicaObserver_createTopic<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ReplicaObserver_createTopicPtr
newCallback_ReplicaObserver_createTopic(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ReplicaObserver_createTopic<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ReplicaObserver_createTopicPtr
newCallback_ReplicaObserver_createTopic(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ReplicaObserver_createTopic<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ReplicaObserver_createTopic : public Callback_ReplicaObserver_createTopic_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ReplicaObserver_createTopic(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IceStormElection::ReplicaObserverPrx __proxy = ::IceStormElection::ReplicaObserverPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_createTopic(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ReplicaObserver_createTopicPtr
newCallback_ReplicaObserver_createTopic(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ReplicaObserver_createTopic<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ReplicaObserver_createTopicPtr
newCallback_ReplicaObserver_createTopic(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ReplicaObserver_createTopic<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ReplicaObserver_createTopicPtr
newCallback_ReplicaObserver_createTopic(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ReplicaObserver_createTopic<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ReplicaObserver_createTopicPtr
newCallback_ReplicaObserver_createTopic(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ReplicaObserver_createTopic<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ReplicaObserver_destroyTopic : public Callback_ReplicaObserver_destroyTopic_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ReplicaObserver_destroyTopic(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IceStormElection::ReplicaObserverPrx __proxy = ::IceStormElection::ReplicaObserverPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_destroyTopic(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_ReplicaObserver_destroyTopicPtr
newCallback_ReplicaObserver_destroyTopic(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ReplicaObserver_destroyTopic<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ReplicaObserver_destroyTopicPtr
newCallback_ReplicaObserver_destroyTopic(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ReplicaObserver_destroyTopic<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ReplicaObserver_destroyTopicPtr
newCallback_ReplicaObserver_destroyTopic(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ReplicaObserver_destroyTopic<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ReplicaObserver_destroyTopicPtr
newCallback_ReplicaObserver_destroyTopic(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ReplicaObserver_destroyTopic<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ReplicaObserver_destroyTopic : public Callback_ReplicaObserver_destroyTopic_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ReplicaObserver_destroyTopic(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IceStormElection::ReplicaObserverPrx __proxy = ::IceStormElection::ReplicaObserverPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_destroyTopic(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ReplicaObserver_destroyTopicPtr
newCallback_ReplicaObserver_destroyTopic(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ReplicaObserver_destroyTopic<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ReplicaObserver_destroyTopicPtr
newCallback_ReplicaObserver_destroyTopic(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ReplicaObserver_destroyTopic<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ReplicaObserver_destroyTopicPtr
newCallback_ReplicaObserver_destroyTopic(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ReplicaObserver_destroyTopic<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ReplicaObserver_destroyTopicPtr
newCallback_ReplicaObserver_destroyTopic(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ReplicaObserver_destroyTopic<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ReplicaObserver_addSubscriber : public Callback_ReplicaObserver_addSubscriber_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ReplicaObserver_addSubscriber(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IceStormElection::ReplicaObserverPrx __proxy = ::IceStormElection::ReplicaObserverPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_addSubscriber(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_ReplicaObserver_addSubscriberPtr
newCallback_ReplicaObserver_addSubscriber(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ReplicaObserver_addSubscriber<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ReplicaObserver_addSubscriberPtr
newCallback_ReplicaObserver_addSubscriber(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ReplicaObserver_addSubscriber<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ReplicaObserver_addSubscriberPtr
newCallback_ReplicaObserver_addSubscriber(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ReplicaObserver_addSubscriber<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ReplicaObserver_addSubscriberPtr
newCallback_ReplicaObserver_addSubscriber(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ReplicaObserver_addSubscriber<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ReplicaObserver_addSubscriber : public Callback_ReplicaObserver_addSubscriber_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ReplicaObserver_addSubscriber(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IceStormElection::ReplicaObserverPrx __proxy = ::IceStormElection::ReplicaObserverPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_addSubscriber(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ReplicaObserver_addSubscriberPtr
newCallback_ReplicaObserver_addSubscriber(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ReplicaObserver_addSubscriber<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ReplicaObserver_addSubscriberPtr
newCallback_ReplicaObserver_addSubscriber(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ReplicaObserver_addSubscriber<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ReplicaObserver_addSubscriberPtr
newCallback_ReplicaObserver_addSubscriber(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ReplicaObserver_addSubscriber<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ReplicaObserver_addSubscriberPtr
newCallback_ReplicaObserver_addSubscriber(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ReplicaObserver_addSubscriber<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ReplicaObserver_removeSubscriber : public Callback_ReplicaObserver_removeSubscriber_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ReplicaObserver_removeSubscriber(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IceStormElection::ReplicaObserverPrx __proxy = ::IceStormElection::ReplicaObserverPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_removeSubscriber(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_ReplicaObserver_removeSubscriberPtr
newCallback_ReplicaObserver_removeSubscriber(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ReplicaObserver_removeSubscriber<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ReplicaObserver_removeSubscriberPtr
newCallback_ReplicaObserver_removeSubscriber(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ReplicaObserver_removeSubscriber<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ReplicaObserver_removeSubscriberPtr
newCallback_ReplicaObserver_removeSubscriber(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ReplicaObserver_removeSubscriber<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ReplicaObserver_removeSubscriberPtr
newCallback_ReplicaObserver_removeSubscriber(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ReplicaObserver_removeSubscriber<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ReplicaObserver_removeSubscriber : public Callback_ReplicaObserver_removeSubscriber_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ReplicaObserver_removeSubscriber(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IceStormElection::ReplicaObserverPrx __proxy = ::IceStormElection::ReplicaObserverPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_removeSubscriber(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ReplicaObserver_removeSubscriberPtr
newCallback_ReplicaObserver_removeSubscriber(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ReplicaObserver_removeSubscriber<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ReplicaObserver_removeSubscriberPtr
newCallback_ReplicaObserver_removeSubscriber(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ReplicaObserver_removeSubscriber<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ReplicaObserver_removeSubscriberPtr
newCallback_ReplicaObserver_removeSubscriber(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ReplicaObserver_removeSubscriber<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ReplicaObserver_removeSubscriberPtr
newCallback_ReplicaObserver_removeSubscriber(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ReplicaObserver_removeSubscriber<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_TopicManagerSync_getContent : public Callback_TopicManagerSync_getContent_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::IceStormElection::LogUpdate&, const ::IceStormElection::TopicContentSeq&);

    CallbackNC_TopicManagerSync_getContent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IceStormElection::TopicManagerSyncPrx __proxy = ::IceStormElection::TopicManagerSyncPrx::uncheckedCast(__result->getProxy());
        ::IceStormElection::LogUpdate llu;
        ::IceStormElection::TopicContentSeq content;
        try
        {
            __proxy->end_getContent(llu, content, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(llu, content);
        }
    }

    Response response;
};

template<class T> Callback_TopicManagerSync_getContentPtr
newCallback_TopicManagerSync_getContent(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::IceStormElection::LogUpdate&, const ::IceStormElection::TopicContentSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TopicManagerSync_getContent<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TopicManagerSync_getContentPtr
newCallback_TopicManagerSync_getContent(T* instance, void (T::*cb)(const ::IceStormElection::LogUpdate&, const ::IceStormElection::TopicContentSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TopicManagerSync_getContent<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TopicManagerSync_getContent : public Callback_TopicManagerSync_getContent_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::IceStormElection::LogUpdate&, const ::IceStormElection::TopicContentSeq&, const CT&);

    Callback_TopicManagerSync_getContent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IceStormElection::TopicManagerSyncPrx __proxy = ::IceStormElection::TopicManagerSyncPrx::uncheckedCast(__result->getProxy());
        ::IceStormElection::LogUpdate llu;
        ::IceStormElection::TopicContentSeq content;
        try
        {
            __proxy->end_getContent(llu, content, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(llu, content, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_TopicManagerSync_getContentPtr
newCallback_TopicManagerSync_getContent(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::IceStormElection::LogUpdate&, const ::IceStormElection::TopicContentSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TopicManagerSync_getContent<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TopicManagerSync_getContentPtr
newCallback_TopicManagerSync_getContent(T* instance, void (T::*cb)(const ::IceStormElection::LogUpdate&, const ::IceStormElection::TopicContentSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TopicManagerSync_getContent<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Node_invitation : public Callback_Node_invitation_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Node_invitation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Node_invitationPtr
newCallback_Node_invitation(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Node_invitation<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Node_invitationPtr
newCallback_Node_invitation(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Node_invitation<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Node_invitationPtr
newCallback_Node_invitation(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Node_invitation<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Node_invitationPtr
newCallback_Node_invitation(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Node_invitation<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Node_invitation : public Callback_Node_invitation_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Node_invitation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Node_invitationPtr
newCallback_Node_invitation(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Node_invitation<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Node_invitationPtr
newCallback_Node_invitation(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Node_invitation<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Node_invitationPtr
newCallback_Node_invitation(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Node_invitation<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Node_invitationPtr
newCallback_Node_invitation(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Node_invitation<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Node_ready : public Callback_Node_ready_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Node_ready(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Node_readyPtr
newCallback_Node_ready(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Node_ready<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Node_readyPtr
newCallback_Node_ready(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Node_ready<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Node_readyPtr
newCallback_Node_ready(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Node_ready<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Node_readyPtr
newCallback_Node_ready(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Node_ready<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Node_ready : public Callback_Node_ready_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Node_ready(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Node_readyPtr
newCallback_Node_ready(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Node_ready<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Node_readyPtr
newCallback_Node_ready(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Node_ready<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Node_readyPtr
newCallback_Node_ready(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Node_ready<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Node_readyPtr
newCallback_Node_ready(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Node_ready<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Node_accept : public Callback_Node_accept_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Node_accept(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Node_acceptPtr
newCallback_Node_accept(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Node_accept<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Node_acceptPtr
newCallback_Node_accept(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Node_accept<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Node_acceptPtr
newCallback_Node_accept(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Node_accept<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Node_acceptPtr
newCallback_Node_accept(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Node_accept<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Node_accept : public Callback_Node_accept_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Node_accept(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Node_acceptPtr
newCallback_Node_accept(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Node_accept<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Node_acceptPtr
newCallback_Node_accept(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Node_accept<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Node_acceptPtr
newCallback_Node_accept(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Node_accept<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Node_acceptPtr
newCallback_Node_accept(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Node_accept<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Node_areYouCoordinator : public Callback_Node_areYouCoordinator_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Node_areYouCoordinator(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IceStormElection::NodePrx __proxy = ::IceStormElection::NodePrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_areYouCoordinator(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Node_areYouCoordinatorPtr
newCallback_Node_areYouCoordinator(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Node_areYouCoordinator<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Node_areYouCoordinatorPtr
newCallback_Node_areYouCoordinator(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Node_areYouCoordinator<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Node_areYouCoordinator : public Callback_Node_areYouCoordinator_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Node_areYouCoordinator(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IceStormElection::NodePrx __proxy = ::IceStormElection::NodePrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_areYouCoordinator(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Node_areYouCoordinatorPtr
newCallback_Node_areYouCoordinator(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Node_areYouCoordinator<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Node_areYouCoordinatorPtr
newCallback_Node_areYouCoordinator(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Node_areYouCoordinator<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Node_areYouThere : public Callback_Node_areYouThere_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Node_areYouThere(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IceStormElection::NodePrx __proxy = ::IceStormElection::NodePrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_areYouThere(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Node_areYouTherePtr
newCallback_Node_areYouThere(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Node_areYouThere<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Node_areYouTherePtr
newCallback_Node_areYouThere(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Node_areYouThere<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Node_areYouThere : public Callback_Node_areYouThere_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Node_areYouThere(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IceStormElection::NodePrx __proxy = ::IceStormElection::NodePrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_areYouThere(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Node_areYouTherePtr
newCallback_Node_areYouThere(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Node_areYouThere<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Node_areYouTherePtr
newCallback_Node_areYouThere(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Node_areYouThere<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Node_sync : public Callback_Node_sync_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Ice::ObjectPrx&);

    CallbackNC_Node_sync(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IceStormElection::NodePrx __proxy = ::IceStormElection::NodePrx::uncheckedCast(__result->getProxy());
        ::Ice::ObjectPrx __ret;
        try
        {
            __ret = __proxy->end_sync(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Node_syncPtr
newCallback_Node_sync(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ObjectPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Node_sync<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Node_syncPtr
newCallback_Node_sync(T* instance, void (T::*cb)(const ::Ice::ObjectPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Node_sync<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Node_sync : public Callback_Node_sync_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Ice::ObjectPrx&, const CT&);

    Callback_Node_sync(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IceStormElection::NodePrx __proxy = ::IceStormElection::NodePrx::uncheckedCast(__result->getProxy());
        ::Ice::ObjectPrx __ret;
        try
        {
            __ret = __proxy->end_sync(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Node_syncPtr
newCallback_Node_sync(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ObjectPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Node_sync<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Node_syncPtr
newCallback_Node_sync(T* instance, void (T::*cb)(const ::Ice::ObjectPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Node_sync<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Node_nodes : public Callback_Node_nodes_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::IceStormElection::NodeInfoSeq&);

    CallbackNC_Node_nodes(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IceStormElection::NodePrx __proxy = ::IceStormElection::NodePrx::uncheckedCast(__result->getProxy());
        ::IceStormElection::NodeInfoSeq __ret;
        try
        {
            __ret = __proxy->end_nodes(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Node_nodesPtr
newCallback_Node_nodes(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::IceStormElection::NodeInfoSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Node_nodes<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Node_nodesPtr
newCallback_Node_nodes(T* instance, void (T::*cb)(const ::IceStormElection::NodeInfoSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Node_nodes<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Node_nodes : public Callback_Node_nodes_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::IceStormElection::NodeInfoSeq&, const CT&);

    Callback_Node_nodes(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IceStormElection::NodePrx __proxy = ::IceStormElection::NodePrx::uncheckedCast(__result->getProxy());
        ::IceStormElection::NodeInfoSeq __ret;
        try
        {
            __ret = __proxy->end_nodes(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Node_nodesPtr
newCallback_Node_nodes(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::IceStormElection::NodeInfoSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Node_nodes<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Node_nodesPtr
newCallback_Node_nodes(T* instance, void (T::*cb)(const ::IceStormElection::NodeInfoSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Node_nodes<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Node_query : public Callback_Node_query_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::IceStormElection::QueryInfo&);

    CallbackNC_Node_query(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IceStormElection::NodePrx __proxy = ::IceStormElection::NodePrx::uncheckedCast(__result->getProxy());
        ::IceStormElection::QueryInfo __ret;
        try
        {
            __ret = __proxy->end_query(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Node_queryPtr
newCallback_Node_query(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::IceStormElection::QueryInfo&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Node_query<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Node_queryPtr
newCallback_Node_query(T* instance, void (T::*cb)(const ::IceStormElection::QueryInfo&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Node_query<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Node_query : public Callback_Node_query_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::IceStormElection::QueryInfo&, const CT&);

    Callback_Node_query(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::IceStormElection::NodePrx __proxy = ::IceStormElection::NodePrx::uncheckedCast(__result->getProxy());
        ::IceStormElection::QueryInfo __ret;
        try
        {
            __ret = __proxy->end_query(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Node_queryPtr
newCallback_Node_query(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::IceStormElection::QueryInfo&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Node_query<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Node_queryPtr
newCallback_Node_query(T* instance, void (T::*cb)(const ::IceStormElection::QueryInfo&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Node_query<T, CT>(instance, cb, excb, sentcb);
}

}

#endif
