// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `Metrics.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef ICE_API_EXPORTS
#   define ICE_API_EXPORTS
#endif
#include <Ice/Metrics.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/BasicStream.h>
#include <Ice/Object.h>
#include <IceUtil/Iterator.h>
#include <IceUtil/DisableWarnings.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace
{

const ::std::string __IceMX__MetricsAdmin__getMetricsViewNames_name = "getMetricsViewNames";

const ::std::string __IceMX__MetricsAdmin__enableMetricsView_name = "enableMetricsView";

const ::std::string __IceMX__MetricsAdmin__disableMetricsView_name = "disableMetricsView";

const ::std::string __IceMX__MetricsAdmin__getMetricsView_name = "getMetricsView";

const ::std::string __IceMX__MetricsAdmin__getMapMetricsFailures_name = "getMapMetricsFailures";

const ::std::string __IceMX__MetricsAdmin__getMetricsFailures_name = "getMetricsFailures";

}

namespace
{

const char* __IceMX__UnknownMetricsView_name = "IceMX::UnknownMetricsView";

struct __F__IceMX__UnknownMetricsView : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::IceMX::UnknownMetricsView();
    }
};

class __F__IceMX__UnknownMetricsView__Init
{
public:

    __F__IceMX__UnknownMetricsView__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::IceMX::UnknownMetricsView", new __F__IceMX__UnknownMetricsView);
    }

    ~__F__IceMX__UnknownMetricsView__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::IceMX::UnknownMetricsView");
    }
};

const __F__IceMX__UnknownMetricsView__Init __F__IceMX__UnknownMetricsView__i;

}

IceMX::UnknownMetricsView::~UnknownMetricsView() throw()
{
}

::std::string
IceMX::UnknownMetricsView::ice_name() const
{
    return __IceMX__UnknownMetricsView_name;
}

IceMX::UnknownMetricsView*
IceMX::UnknownMetricsView::ice_clone() const
{
    return new UnknownMetricsView(*this);
}

void
IceMX::UnknownMetricsView::ice_throw() const
{
    throw *this;
}

void
IceMX::UnknownMetricsView::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::IceMX::UnknownMetricsView", -1, true);
    __os->endWriteSlice();
}

void
IceMX::UnknownMetricsView::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

namespace Ice
{
#ifdef ICE_HAS_DECLSPEC_IMPORT_EXPORT
template struct ICE_API StreamWriter< ::IceMX::MetricsFailures, ::IceInternal::BasicStream>;
template struct ICE_API StreamReader< ::IceMX::MetricsFailures, ::IceInternal::BasicStream>;
#endif
}
#ifdef __SUNPRO_CC
class ICE_DECLSPEC_EXPORT IceProxy::IceMX::Metrics;
#endif
ICE_DECLSPEC_EXPORT ::IceProxy::Ice::Object* ::IceProxy::IceMX::upCast(::IceProxy::IceMX::Metrics* p) { return p; }

void
::IceProxy::IceMX::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceMX::Metrics>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceMX::Metrics;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::IceMX::Metrics::ice_staticId()
{
    return ::IceMX::Metrics::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceMX::Metrics::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceMX::Metrics);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceMX::Metrics::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceMX::Metrics);
}

::IceProxy::Ice::Object*
IceProxy::IceMX::Metrics::__newInstance() const
{
    return new Metrics;
}
#ifdef __SUNPRO_CC
class ICE_DECLSPEC_EXPORT IceProxy::IceMX::MetricsAdmin;
#endif
ICE_DECLSPEC_EXPORT ::IceProxy::Ice::Object* ::IceProxy::IceMX::upCast(::IceProxy::IceMX::MetricsAdmin* p) { return p; }

void
::IceProxy::IceMX::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceMX::MetricsAdmin>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceMX::MetricsAdmin;
        v->__copyFrom(proxy);
    }
}

::Ice::StringSeq
IceProxy::IceMX::MetricsAdmin::getMetricsViewNames(::Ice::StringSeq& disabledViews, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceMX__MetricsAdmin__getMetricsViewNames_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceMX__MetricsAdmin__getMetricsViewNames_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceMX::MetricsAdmin* __del = dynamic_cast< ::IceDelegate::IceMX::MetricsAdmin*>(__delBase.get());
            return __del->getMetricsViewNames(disabledViews, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceMX::MetricsAdmin::begin_getMetricsViewNames(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceMX__MetricsAdmin__getMetricsViewNames_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceMX__MetricsAdmin__getMetricsViewNames_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceMX__MetricsAdmin__getMetricsViewNames_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::StringSeq
IceProxy::IceMX::MetricsAdmin::end_getMetricsViewNames(::Ice::StringSeq& disabledViews, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceMX__MetricsAdmin__getMetricsViewNames_name);
    ::Ice::StringSeq __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(disabledViews);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::IceMX::MetricsAdmin::enableMetricsView(const ::std::string& name, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceMX__MetricsAdmin__enableMetricsView_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceMX__MetricsAdmin__enableMetricsView_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceMX::MetricsAdmin* __del = dynamic_cast< ::IceDelegate::IceMX::MetricsAdmin*>(__delBase.get());
            __del->enableMetricsView(name, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceMX::MetricsAdmin::begin_enableMetricsView(const ::std::string& name, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceMX__MetricsAdmin__enableMetricsView_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceMX__MetricsAdmin__enableMetricsView_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceMX__MetricsAdmin__enableMetricsView_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::SlicedFormat);
        __os->write(name);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceMX::MetricsAdmin::end_enableMetricsView(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceMX__MetricsAdmin__enableMetricsView_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::IceMX::UnknownMetricsView&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::IceMX::MetricsAdmin::disableMetricsView(const ::std::string& name, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceMX__MetricsAdmin__disableMetricsView_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceMX__MetricsAdmin__disableMetricsView_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceMX::MetricsAdmin* __del = dynamic_cast< ::IceDelegate::IceMX::MetricsAdmin*>(__delBase.get());
            __del->disableMetricsView(name, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceMX::MetricsAdmin::begin_disableMetricsView(const ::std::string& name, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceMX__MetricsAdmin__disableMetricsView_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceMX__MetricsAdmin__disableMetricsView_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceMX__MetricsAdmin__disableMetricsView_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::SlicedFormat);
        __os->write(name);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::IceMX::MetricsAdmin::end_disableMetricsView(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceMX__MetricsAdmin__disableMetricsView_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::IceMX::UnknownMetricsView&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::IceMX::MetricsView
IceProxy::IceMX::MetricsAdmin::getMetricsView(const ::std::string& view, ::Ice::Long& timestamp, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceMX__MetricsAdmin__getMetricsView_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceMX__MetricsAdmin__getMetricsView_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceMX::MetricsAdmin* __del = dynamic_cast< ::IceDelegate::IceMX::MetricsAdmin*>(__delBase.get());
            return __del->getMetricsView(view, timestamp, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceMX::MetricsAdmin::begin_getMetricsView(const ::std::string& view, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceMX__MetricsAdmin__getMetricsView_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceMX__MetricsAdmin__getMetricsView_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceMX__MetricsAdmin__getMetricsView_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::SlicedFormat);
        __os->write(view);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::IceMX::MetricsView
IceProxy::IceMX::MetricsAdmin::end_getMetricsView(::Ice::Long& timestamp, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceMX__MetricsAdmin__getMetricsView_name);
    ::IceMX::MetricsView __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::IceMX::UnknownMetricsView&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(timestamp);
        __is->read(__ret);
        __is->readPendingObjects();
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::IceMX::MetricsFailuresSeq
IceProxy::IceMX::MetricsAdmin::getMapMetricsFailures(const ::std::string& view, const ::std::string& map, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceMX__MetricsAdmin__getMapMetricsFailures_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceMX__MetricsAdmin__getMapMetricsFailures_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceMX::MetricsAdmin* __del = dynamic_cast< ::IceDelegate::IceMX::MetricsAdmin*>(__delBase.get());
            return __del->getMapMetricsFailures(view, map, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceMX::MetricsAdmin::begin_getMapMetricsFailures(const ::std::string& view, const ::std::string& map, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceMX__MetricsAdmin__getMapMetricsFailures_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceMX__MetricsAdmin__getMapMetricsFailures_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceMX__MetricsAdmin__getMapMetricsFailures_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::SlicedFormat);
        __os->write(view);
        __os->write(map);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::IceMX::MetricsFailuresSeq
IceProxy::IceMX::MetricsAdmin::end_getMapMetricsFailures(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceMX__MetricsAdmin__getMapMetricsFailures_name);
    ::IceMX::MetricsFailuresSeq __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::IceMX::UnknownMetricsView&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::IceMX::MetricsFailures
IceProxy::IceMX::MetricsAdmin::getMetricsFailures(const ::std::string& view, const ::std::string& map, const ::std::string& id, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __IceMX__MetricsAdmin__getMetricsFailures_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__IceMX__MetricsAdmin__getMetricsFailures_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::IceMX::MetricsAdmin* __del = dynamic_cast< ::IceDelegate::IceMX::MetricsAdmin*>(__delBase.get());
            return __del->getMetricsFailures(view, map, id, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::IceMX::MetricsAdmin::begin_getMetricsFailures(const ::std::string& view, const ::std::string& map, const ::std::string& id, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__IceMX__MetricsAdmin__getMetricsFailures_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __IceMX__MetricsAdmin__getMetricsFailures_name, __del, __cookie);
    try
    {
        __result->__prepare(__IceMX__MetricsAdmin__getMetricsFailures_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::SlicedFormat);
        __os->write(view);
        __os->write(map);
        __os->write(id);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::IceMX::MetricsFailures
IceProxy::IceMX::MetricsAdmin::end_getMetricsFailures(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __IceMX__MetricsAdmin__getMetricsFailures_name);
    ::IceMX::MetricsFailures __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::IceMX::UnknownMetricsView&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::IceMX::MetricsAdmin::ice_staticId()
{
    return ::IceMX::MetricsAdmin::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceMX::MetricsAdmin::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceMX::MetricsAdmin);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceMX::MetricsAdmin::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceMX::MetricsAdmin);
}

::IceProxy::Ice::Object*
IceProxy::IceMX::MetricsAdmin::__newInstance() const
{
    return new MetricsAdmin;
}
#ifdef __SUNPRO_CC
class ICE_DECLSPEC_EXPORT IceProxy::IceMX::ThreadMetrics;
#endif
ICE_DECLSPEC_EXPORT ::IceProxy::Ice::Object* ::IceProxy::IceMX::upCast(::IceProxy::IceMX::ThreadMetrics* p) { return p; }

void
::IceProxy::IceMX::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceMX::ThreadMetrics>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceMX::ThreadMetrics;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::IceMX::ThreadMetrics::ice_staticId()
{
    return ::IceMX::ThreadMetrics::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceMX::ThreadMetrics::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceMX::ThreadMetrics);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceMX::ThreadMetrics::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceMX::ThreadMetrics);
}

::IceProxy::Ice::Object*
IceProxy::IceMX::ThreadMetrics::__newInstance() const
{
    return new ThreadMetrics;
}
#ifdef __SUNPRO_CC
class ICE_DECLSPEC_EXPORT IceProxy::IceMX::DispatchMetrics;
#endif
ICE_DECLSPEC_EXPORT ::IceProxy::Ice::Object* ::IceProxy::IceMX::upCast(::IceProxy::IceMX::DispatchMetrics* p) { return p; }

void
::IceProxy::IceMX::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceMX::DispatchMetrics>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceMX::DispatchMetrics;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::IceMX::DispatchMetrics::ice_staticId()
{
    return ::IceMX::DispatchMetrics::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceMX::DispatchMetrics::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceMX::DispatchMetrics);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceMX::DispatchMetrics::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceMX::DispatchMetrics);
}

::IceProxy::Ice::Object*
IceProxy::IceMX::DispatchMetrics::__newInstance() const
{
    return new DispatchMetrics;
}
#ifdef __SUNPRO_CC
class ICE_DECLSPEC_EXPORT IceProxy::IceMX::RemoteMetrics;
#endif
ICE_DECLSPEC_EXPORT ::IceProxy::Ice::Object* ::IceProxy::IceMX::upCast(::IceProxy::IceMX::RemoteMetrics* p) { return p; }

void
::IceProxy::IceMX::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceMX::RemoteMetrics>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceMX::RemoteMetrics;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::IceMX::RemoteMetrics::ice_staticId()
{
    return ::IceMX::RemoteMetrics::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceMX::RemoteMetrics::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceMX::RemoteMetrics);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceMX::RemoteMetrics::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceMX::RemoteMetrics);
}

::IceProxy::Ice::Object*
IceProxy::IceMX::RemoteMetrics::__newInstance() const
{
    return new RemoteMetrics;
}
#ifdef __SUNPRO_CC
class ICE_DECLSPEC_EXPORT IceProxy::IceMX::InvocationMetrics;
#endif
ICE_DECLSPEC_EXPORT ::IceProxy::Ice::Object* ::IceProxy::IceMX::upCast(::IceProxy::IceMX::InvocationMetrics* p) { return p; }

void
::IceProxy::IceMX::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceMX::InvocationMetrics>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceMX::InvocationMetrics;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::IceMX::InvocationMetrics::ice_staticId()
{
    return ::IceMX::InvocationMetrics::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceMX::InvocationMetrics::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceMX::InvocationMetrics);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceMX::InvocationMetrics::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceMX::InvocationMetrics);
}

::IceProxy::Ice::Object*
IceProxy::IceMX::InvocationMetrics::__newInstance() const
{
    return new InvocationMetrics;
}
#ifdef __SUNPRO_CC
class ICE_DECLSPEC_EXPORT IceProxy::IceMX::ConnectionMetrics;
#endif
ICE_DECLSPEC_EXPORT ::IceProxy::Ice::Object* ::IceProxy::IceMX::upCast(::IceProxy::IceMX::ConnectionMetrics* p) { return p; }

void
::IceProxy::IceMX::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::IceMX::ConnectionMetrics>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::IceMX::ConnectionMetrics;
        v->__copyFrom(proxy);
    }
}

const ::std::string&
IceProxy::IceMX::ConnectionMetrics::ice_staticId()
{
    return ::IceMX::ConnectionMetrics::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::IceMX::ConnectionMetrics::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::IceMX::ConnectionMetrics);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::IceMX::ConnectionMetrics::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::IceMX::ConnectionMetrics);
}

::IceProxy::Ice::Object*
IceProxy::IceMX::ConnectionMetrics::__newInstance() const
{
    return new ConnectionMetrics;
}

::Ice::StringSeq
IceDelegateM::IceMX::MetricsAdmin::getMetricsViewNames(::Ice::StringSeq& disabledViews, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceMX__MetricsAdmin__getMetricsViewNames_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Ice::StringSeq __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(disabledViews);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::IceMX::MetricsAdmin::enableMetricsView(const ::std::string& name, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceMX__MetricsAdmin__enableMetricsView_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::SlicedFormat);
        __os->write(name);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::IceMX::UnknownMetricsView&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::IceMX::MetricsAdmin::disableMetricsView(const ::std::string& name, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceMX__MetricsAdmin__disableMetricsView_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::SlicedFormat);
        __os->write(name);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::IceMX::UnknownMetricsView&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::IceMX::MetricsView
IceDelegateM::IceMX::MetricsAdmin::getMetricsView(const ::std::string& view, ::Ice::Long& timestamp, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceMX__MetricsAdmin__getMetricsView_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::SlicedFormat);
        __os->write(view);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::IceMX::MetricsView __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::IceMX::UnknownMetricsView&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(timestamp);
        __is->read(__ret);
        __is->readPendingObjects();
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::IceMX::MetricsFailuresSeq
IceDelegateM::IceMX::MetricsAdmin::getMapMetricsFailures(const ::std::string& view, const ::std::string& map, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceMX__MetricsAdmin__getMapMetricsFailures_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::SlicedFormat);
        __os->write(view);
        __os->write(map);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::IceMX::MetricsFailuresSeq __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::IceMX::UnknownMetricsView&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::IceMX::MetricsFailures
IceDelegateM::IceMX::MetricsAdmin::getMetricsFailures(const ::std::string& view, const ::std::string& map, const ::std::string& id, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __IceMX__MetricsAdmin__getMetricsFailures_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::SlicedFormat);
        __os->write(view);
        __os->write(map);
        __os->write(id);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::IceMX::MetricsFailures __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::IceMX::UnknownMetricsView&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::StringSeq
IceDelegateD::IceMX::MetricsAdmin::getMetricsViewNames(::Ice::StringSeq& disabledViews, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::StringSeq& __result, ::Ice::StringSeq& __p_disabledViews, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_disabledViews(__p_disabledViews)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceMX::MetricsAdmin* servant = dynamic_cast< ::IceMX::MetricsAdmin*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getMetricsViewNames(_m_disabledViews, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::StringSeq& _result;
        ::Ice::StringSeq& _m_disabledViews;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceMX__MetricsAdmin__getMetricsViewNames_name, ::Ice::Normal, __context);
    ::Ice::StringSeq __result;
    try
    {
        _DirectI __direct(__result, disabledViews, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::IceMX::MetricsAdmin::enableMetricsView(const ::std::string& name, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_name, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_name(__p_name)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceMX::MetricsAdmin* servant = dynamic_cast< ::IceMX::MetricsAdmin*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->enableMetricsView(_m_name, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::std::string& _m_name;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceMX__MetricsAdmin__enableMetricsView_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(name, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::IceMX::UnknownMetricsView&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::IceMX::MetricsAdmin::disableMetricsView(const ::std::string& name, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_name, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_name(__p_name)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceMX::MetricsAdmin* servant = dynamic_cast< ::IceMX::MetricsAdmin*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->disableMetricsView(_m_name, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::std::string& _m_name;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceMX__MetricsAdmin__disableMetricsView_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(name, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::IceMX::UnknownMetricsView&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::IceMX::MetricsView
IceDelegateD::IceMX::MetricsAdmin::getMetricsView(const ::std::string& view, ::Ice::Long& timestamp, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::IceMX::MetricsView& __result, const ::std::string& __p_view, ::Ice::Long& __p_timestamp, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_view(__p_view),
            _m_timestamp(__p_timestamp)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceMX::MetricsAdmin* servant = dynamic_cast< ::IceMX::MetricsAdmin*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->getMetricsView(_m_view, _m_timestamp, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::IceMX::MetricsView& _result;
        const ::std::string& _m_view;
        ::Ice::Long& _m_timestamp;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceMX__MetricsAdmin__getMetricsView_name, ::Ice::Normal, __context);
    ::IceMX::MetricsView __result;
    try
    {
        _DirectI __direct(__result, view, timestamp, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::IceMX::UnknownMetricsView&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::IceMX::MetricsFailuresSeq
IceDelegateD::IceMX::MetricsAdmin::getMapMetricsFailures(const ::std::string& view, const ::std::string& map, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::IceMX::MetricsFailuresSeq& __result, const ::std::string& __p_view, const ::std::string& __p_map, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_view(__p_view),
            _m_map(__p_map)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceMX::MetricsAdmin* servant = dynamic_cast< ::IceMX::MetricsAdmin*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->getMapMetricsFailures(_m_view, _m_map, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::IceMX::MetricsFailuresSeq& _result;
        const ::std::string& _m_view;
        const ::std::string& _m_map;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceMX__MetricsAdmin__getMapMetricsFailures_name, ::Ice::Normal, __context);
    ::IceMX::MetricsFailuresSeq __result;
    try
    {
        _DirectI __direct(__result, view, map, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::IceMX::UnknownMetricsView&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::IceMX::MetricsFailures
IceDelegateD::IceMX::MetricsAdmin::getMetricsFailures(const ::std::string& view, const ::std::string& map, const ::std::string& id, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::IceMX::MetricsFailures& __result, const ::std::string& __p_view, const ::std::string& __p_map, const ::std::string& __p_id, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_view(__p_view),
            _m_map(__p_map),
            _m_id(__p_id)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::IceMX::MetricsAdmin* servant = dynamic_cast< ::IceMX::MetricsAdmin*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->getMetricsFailures(_m_view, _m_map, _m_id, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::IceMX::MetricsFailures& _result;
        const ::std::string& _m_view;
        const ::std::string& _m_map;
        const ::std::string& _m_id;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __IceMX__MetricsAdmin__getMetricsFailures_name, ::Ice::Normal, __context);
    ::IceMX::MetricsFailures __result;
    try
    {
        _DirectI __direct(__result, view, map, id, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::IceMX::UnknownMetricsView&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

ICE_DECLSPEC_EXPORT ::Ice::Object* IceMX::upCast(::IceMX::Metrics* p) { return p; }
::Ice::ObjectPtr
IceMX::Metrics::ice_clone() const
{
    ::Ice::Object* __p = new Metrics(*this);
    return __p;
}

namespace
{
const ::std::string __IceMX__Metrics_ids[2] =
{
    "::Ice::Object",
    "::IceMX::Metrics"
};

}

bool
IceMX::Metrics::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceMX__Metrics_ids, __IceMX__Metrics_ids + 2, _s);
}

::std::vector< ::std::string>
IceMX::Metrics::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceMX__Metrics_ids[0], &__IceMX__Metrics_ids[2]);
}

const ::std::string&
IceMX::Metrics::ice_id(const ::Ice::Current&) const
{
    return __IceMX__Metrics_ids[1];
}

const ::std::string&
IceMX::Metrics::ice_staticId()
{
    return __IceMX__Metrics_ids[1];
}

void
IceMX::Metrics::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->write(id);
    __os->write(total);
    __os->write(current);
    __os->write(totalLifetime);
    __os->write(failures);
    __os->endWriteSlice();
}

void
IceMX::Metrics::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(id);
    __is->read(total);
    __is->read(current);
    __is->read(totalLifetime);
    __is->read(failures);
    __is->endReadSlice();
}

namespace
{

class __F__IceMX__Metrics : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::IceMX::Metrics::ice_staticId());
        return new ::IceMX::Metrics;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__IceMX__Metrics_Ptr = new __F__IceMX__Metrics;

class __F__IceMX__Metrics__Init
{
public:

    __F__IceMX__Metrics__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::IceMX::Metrics::ice_staticId(), __F__IceMX__Metrics_Ptr);
    }

    ~__F__IceMX__Metrics__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::IceMX::Metrics::ice_staticId());
    }
};

const __F__IceMX__Metrics__Init __F__IceMX__Metrics__i;

}

const ::Ice::ObjectFactoryPtr&
IceMX::Metrics::ice_factory()
{
    return __F__IceMX__Metrics_Ptr;
}

void ICE_DECLSPEC_EXPORT 
IceMX::__patch(MetricsPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceMX::MetricsPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceMX::Metrics::ice_staticId(), v);
    }
}

ICE_DECLSPEC_EXPORT ::Ice::Object* IceMX::upCast(::IceMX::MetricsAdmin* p) { return p; }

namespace
{
const ::std::string __IceMX__MetricsAdmin_ids[2] =
{
    "::Ice::Object",
    "::IceMX::MetricsAdmin"
};

}

bool
IceMX::MetricsAdmin::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceMX__MetricsAdmin_ids, __IceMX__MetricsAdmin_ids + 2, _s);
}

::std::vector< ::std::string>
IceMX::MetricsAdmin::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceMX__MetricsAdmin_ids[0], &__IceMX__MetricsAdmin_ids[2]);
}

const ::std::string&
IceMX::MetricsAdmin::ice_id(const ::Ice::Current&) const
{
    return __IceMX__MetricsAdmin_ids[1];
}

const ::std::string&
IceMX::MetricsAdmin::ice_staticId()
{
    return __IceMX__MetricsAdmin_ids[1];
}

::Ice::DispatchStatus
IceMX::MetricsAdmin::___getMetricsViewNames(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Ice::StringSeq disabledViews;
    ::Ice::StringSeq __ret = getMetricsViewNames(disabledViews, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::SlicedFormat);
    __os->write(disabledViews);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
IceMX::MetricsAdmin::___enableMetricsView(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string name;
    __is->read(name);
    __inS.endReadParams();
    try
    {
        enableMetricsView(name, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::IceMX::UnknownMetricsView& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::SlicedFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
IceMX::MetricsAdmin::___disableMetricsView(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string name;
    __is->read(name);
    __inS.endReadParams();
    try
    {
        disableMetricsView(name, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::IceMX::UnknownMetricsView& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::SlicedFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
IceMX::MetricsAdmin::___getMetricsView(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string view;
    __is->read(view);
    __inS.endReadParams();
    ::Ice::Long timestamp;
    try
    {
        ::IceMX::MetricsView __ret = getMetricsView(view, timestamp, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::SlicedFormat);
        __os->write(timestamp);
        __os->write(__ret);
        __os->writePendingObjects();
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::IceMX::UnknownMetricsView& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::SlicedFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
IceMX::MetricsAdmin::___getMapMetricsFailures(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string view;
    ::std::string map;
    __is->read(view);
    __is->read(map);
    __inS.endReadParams();
    try
    {
        ::IceMX::MetricsFailuresSeq __ret = getMapMetricsFailures(view, map, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::SlicedFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::IceMX::UnknownMetricsView& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::SlicedFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
IceMX::MetricsAdmin::___getMetricsFailures(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string view;
    ::std::string map;
    ::std::string id;
    __is->read(view);
    __is->read(map);
    __is->read(id);
    __inS.endReadParams();
    try
    {
        ::IceMX::MetricsFailures __ret = getMetricsFailures(view, map, id, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::SlicedFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::IceMX::UnknownMetricsView& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::SlicedFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __IceMX__MetricsAdmin_all[] =
{
    "disableMetricsView",
    "enableMetricsView",
    "getMapMetricsFailures",
    "getMetricsFailures",
    "getMetricsView",
    "getMetricsViewNames",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
IceMX::MetricsAdmin::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__IceMX__MetricsAdmin_all, __IceMX__MetricsAdmin_all + 10, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __IceMX__MetricsAdmin_all)
    {
        case 0:
        {
            return ___disableMetricsView(in, current);
        }
        case 1:
        {
            return ___enableMetricsView(in, current);
        }
        case 2:
        {
            return ___getMapMetricsFailures(in, current);
        }
        case 3:
        {
            return ___getMetricsFailures(in, current);
        }
        case 4:
        {
            return ___getMetricsView(in, current);
        }
        case 5:
        {
            return ___getMetricsViewNames(in, current);
        }
        case 6:
        {
            return ___ice_id(in, current);
        }
        case 7:
        {
            return ___ice_ids(in, current);
        }
        case 8:
        {
            return ___ice_isA(in, current);
        }
        case 9:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
IceMX::MetricsAdmin::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
IceMX::MetricsAdmin::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void ICE_DECLSPEC_EXPORT 
IceMX::__patch(MetricsAdminPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceMX::MetricsAdminPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceMX::MetricsAdmin::ice_staticId(), v);
    }
}

ICE_DECLSPEC_EXPORT ::Ice::Object* IceMX::upCast(::IceMX::ThreadMetrics* p) { return p; }
::Ice::ObjectPtr
IceMX::ThreadMetrics::ice_clone() const
{
    ::Ice::Object* __p = new ThreadMetrics(*this);
    return __p;
}

namespace
{
const ::std::string __IceMX__ThreadMetrics_ids[3] =
{
    "::Ice::Object",
    "::IceMX::Metrics",
    "::IceMX::ThreadMetrics"
};

}

bool
IceMX::ThreadMetrics::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceMX__ThreadMetrics_ids, __IceMX__ThreadMetrics_ids + 3, _s);
}

::std::vector< ::std::string>
IceMX::ThreadMetrics::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceMX__ThreadMetrics_ids[0], &__IceMX__ThreadMetrics_ids[3]);
}

const ::std::string&
IceMX::ThreadMetrics::ice_id(const ::Ice::Current&) const
{
    return __IceMX__ThreadMetrics_ids[2];
}

const ::std::string&
IceMX::ThreadMetrics::ice_staticId()
{
    return __IceMX__ThreadMetrics_ids[2];
}

void
IceMX::ThreadMetrics::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, false);
    __os->write(inUseForIO);
    __os->write(inUseForUser);
    __os->write(inUseForOther);
    __os->endWriteSlice();
    ::IceMX::Metrics::__writeImpl(__os);
}

void
IceMX::ThreadMetrics::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(inUseForIO);
    __is->read(inUseForUser);
    __is->read(inUseForOther);
    __is->endReadSlice();
    ::IceMX::Metrics::__readImpl(__is);
}

namespace
{

class __F__IceMX__ThreadMetrics : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::IceMX::ThreadMetrics::ice_staticId());
        return new ::IceMX::ThreadMetrics;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__IceMX__ThreadMetrics_Ptr = new __F__IceMX__ThreadMetrics;

class __F__IceMX__ThreadMetrics__Init
{
public:

    __F__IceMX__ThreadMetrics__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::IceMX::ThreadMetrics::ice_staticId(), __F__IceMX__ThreadMetrics_Ptr);
    }

    ~__F__IceMX__ThreadMetrics__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::IceMX::ThreadMetrics::ice_staticId());
    }
};

const __F__IceMX__ThreadMetrics__Init __F__IceMX__ThreadMetrics__i;

}

const ::Ice::ObjectFactoryPtr&
IceMX::ThreadMetrics::ice_factory()
{
    return __F__IceMX__ThreadMetrics_Ptr;
}

void ICE_DECLSPEC_EXPORT 
IceMX::__patch(ThreadMetricsPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceMX::ThreadMetricsPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceMX::ThreadMetrics::ice_staticId(), v);
    }
}

ICE_DECLSPEC_EXPORT ::Ice::Object* IceMX::upCast(::IceMX::DispatchMetrics* p) { return p; }
::Ice::ObjectPtr
IceMX::DispatchMetrics::ice_clone() const
{
    ::Ice::Object* __p = new DispatchMetrics(*this);
    return __p;
}

namespace
{
const ::std::string __IceMX__DispatchMetrics_ids[3] =
{
    "::Ice::Object",
    "::IceMX::DispatchMetrics",
    "::IceMX::Metrics"
};

}

bool
IceMX::DispatchMetrics::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceMX__DispatchMetrics_ids, __IceMX__DispatchMetrics_ids + 3, _s);
}

::std::vector< ::std::string>
IceMX::DispatchMetrics::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceMX__DispatchMetrics_ids[0], &__IceMX__DispatchMetrics_ids[3]);
}

const ::std::string&
IceMX::DispatchMetrics::ice_id(const ::Ice::Current&) const
{
    return __IceMX__DispatchMetrics_ids[1];
}

const ::std::string&
IceMX::DispatchMetrics::ice_staticId()
{
    return __IceMX__DispatchMetrics_ids[1];
}

void
IceMX::DispatchMetrics::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, false);
    __os->write(userException);
    __os->write(size);
    __os->write(replySize);
    __os->endWriteSlice();
    ::IceMX::Metrics::__writeImpl(__os);
}

void
IceMX::DispatchMetrics::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(userException);
    __is->read(size);
    __is->read(replySize);
    __is->endReadSlice();
    ::IceMX::Metrics::__readImpl(__is);
}

namespace
{

class __F__IceMX__DispatchMetrics : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::IceMX::DispatchMetrics::ice_staticId());
        return new ::IceMX::DispatchMetrics;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__IceMX__DispatchMetrics_Ptr = new __F__IceMX__DispatchMetrics;

class __F__IceMX__DispatchMetrics__Init
{
public:

    __F__IceMX__DispatchMetrics__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::IceMX::DispatchMetrics::ice_staticId(), __F__IceMX__DispatchMetrics_Ptr);
    }

    ~__F__IceMX__DispatchMetrics__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::IceMX::DispatchMetrics::ice_staticId());
    }
};

const __F__IceMX__DispatchMetrics__Init __F__IceMX__DispatchMetrics__i;

}

const ::Ice::ObjectFactoryPtr&
IceMX::DispatchMetrics::ice_factory()
{
    return __F__IceMX__DispatchMetrics_Ptr;
}

void ICE_DECLSPEC_EXPORT 
IceMX::__patch(DispatchMetricsPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceMX::DispatchMetricsPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceMX::DispatchMetrics::ice_staticId(), v);
    }
}

ICE_DECLSPEC_EXPORT ::Ice::Object* IceMX::upCast(::IceMX::RemoteMetrics* p) { return p; }
::Ice::ObjectPtr
IceMX::RemoteMetrics::ice_clone() const
{
    ::Ice::Object* __p = new RemoteMetrics(*this);
    return __p;
}

namespace
{
const ::std::string __IceMX__RemoteMetrics_ids[3] =
{
    "::Ice::Object",
    "::IceMX::Metrics",
    "::IceMX::RemoteMetrics"
};

}

bool
IceMX::RemoteMetrics::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceMX__RemoteMetrics_ids, __IceMX__RemoteMetrics_ids + 3, _s);
}

::std::vector< ::std::string>
IceMX::RemoteMetrics::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceMX__RemoteMetrics_ids[0], &__IceMX__RemoteMetrics_ids[3]);
}

const ::std::string&
IceMX::RemoteMetrics::ice_id(const ::Ice::Current&) const
{
    return __IceMX__RemoteMetrics_ids[2];
}

const ::std::string&
IceMX::RemoteMetrics::ice_staticId()
{
    return __IceMX__RemoteMetrics_ids[2];
}

void
IceMX::RemoteMetrics::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, false);
    __os->write(size);
    __os->write(replySize);
    __os->endWriteSlice();
    ::IceMX::Metrics::__writeImpl(__os);
}

void
IceMX::RemoteMetrics::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(size);
    __is->read(replySize);
    __is->endReadSlice();
    ::IceMX::Metrics::__readImpl(__is);
}

namespace
{

class __F__IceMX__RemoteMetrics : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::IceMX::RemoteMetrics::ice_staticId());
        return new ::IceMX::RemoteMetrics;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__IceMX__RemoteMetrics_Ptr = new __F__IceMX__RemoteMetrics;

class __F__IceMX__RemoteMetrics__Init
{
public:

    __F__IceMX__RemoteMetrics__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::IceMX::RemoteMetrics::ice_staticId(), __F__IceMX__RemoteMetrics_Ptr);
    }

    ~__F__IceMX__RemoteMetrics__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::IceMX::RemoteMetrics::ice_staticId());
    }
};

const __F__IceMX__RemoteMetrics__Init __F__IceMX__RemoteMetrics__i;

}

const ::Ice::ObjectFactoryPtr&
IceMX::RemoteMetrics::ice_factory()
{
    return __F__IceMX__RemoteMetrics_Ptr;
}

void ICE_DECLSPEC_EXPORT 
IceMX::__patch(RemoteMetricsPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceMX::RemoteMetricsPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceMX::RemoteMetrics::ice_staticId(), v);
    }
}

ICE_DECLSPEC_EXPORT ::Ice::Object* IceMX::upCast(::IceMX::InvocationMetrics* p) { return p; }
::Ice::ObjectPtr
IceMX::InvocationMetrics::ice_clone() const
{
    ::Ice::Object* __p = new InvocationMetrics(*this);
    return __p;
}

namespace
{
const ::std::string __IceMX__InvocationMetrics_ids[3] =
{
    "::Ice::Object",
    "::IceMX::InvocationMetrics",
    "::IceMX::Metrics"
};

}

bool
IceMX::InvocationMetrics::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceMX__InvocationMetrics_ids, __IceMX__InvocationMetrics_ids + 3, _s);
}

::std::vector< ::std::string>
IceMX::InvocationMetrics::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceMX__InvocationMetrics_ids[0], &__IceMX__InvocationMetrics_ids[3]);
}

const ::std::string&
IceMX::InvocationMetrics::ice_id(const ::Ice::Current&) const
{
    return __IceMX__InvocationMetrics_ids[1];
}

const ::std::string&
IceMX::InvocationMetrics::ice_staticId()
{
    return __IceMX__InvocationMetrics_ids[1];
}

void
IceMX::InvocationMetrics::__addObject(::IceInternal::GCCountMap& _c)
{
    ::IceInternal::GCCountMap::iterator pos = _c.find(this);
    if(pos == _c.end())
    {
        _c[this] = 1;
    }
    else
    {
        ++pos->second;
    }
}

bool
IceMX::InvocationMetrics::__usesGC()
{
    return true;
}

void
IceMX::InvocationMetrics::__gcReachable(::IceInternal::GCCountMap& _c) const
{
    {
        for(::IceMX::MetricsMap::const_iterator _i0 = remotes.begin(); _i0 != remotes.end(); ++_i0)
        {
            if((*_i0))
            {
                ::IceMX::upCast((*_i0).get())->__addObject(_c);
            }
        }
    }
}

void
IceMX::InvocationMetrics::__gcClear()
{
    {
        for(::IceMX::MetricsMap::iterator _i0 = remotes.begin(); _i0 != remotes.end(); ++_i0)
        {
            if((*_i0))
            {
                if(::IceMX::upCast((*_i0).get())->__usesGC())
                {
                    ::IceMX::upCast((*_i0).get())->__decRefUnsafe();
                    (*_i0).__clearHandleUnsafe();
                }
                else
                {
                    (*_i0) = 0;
                }
            }
        }
    }
}

void
IceMX::InvocationMetrics::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, false);
    __os->write(retry);
    __os->write(userException);
    __os->write(remotes);
    __os->endWriteSlice();
    ::IceMX::Metrics::__writeImpl(__os);
}

void
IceMX::InvocationMetrics::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(retry);
    __is->read(userException);
    __is->read(remotes);
    __is->endReadSlice();
    ::IceMX::Metrics::__readImpl(__is);
}

namespace
{

class __F__IceMX__InvocationMetrics : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::IceMX::InvocationMetrics::ice_staticId());
        return new ::IceMX::InvocationMetrics;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__IceMX__InvocationMetrics_Ptr = new __F__IceMX__InvocationMetrics;

class __F__IceMX__InvocationMetrics__Init
{
public:

    __F__IceMX__InvocationMetrics__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::IceMX::InvocationMetrics::ice_staticId(), __F__IceMX__InvocationMetrics_Ptr);
    }

    ~__F__IceMX__InvocationMetrics__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::IceMX::InvocationMetrics::ice_staticId());
    }
};

const __F__IceMX__InvocationMetrics__Init __F__IceMX__InvocationMetrics__i;

}

const ::Ice::ObjectFactoryPtr&
IceMX::InvocationMetrics::ice_factory()
{
    return __F__IceMX__InvocationMetrics_Ptr;
}

void ICE_DECLSPEC_EXPORT 
IceMX::__patch(InvocationMetricsPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceMX::InvocationMetricsPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceMX::InvocationMetrics::ice_staticId(), v);
    }
}

ICE_DECLSPEC_EXPORT ::Ice::Object* IceMX::upCast(::IceMX::ConnectionMetrics* p) { return p; }
::Ice::ObjectPtr
IceMX::ConnectionMetrics::ice_clone() const
{
    ::Ice::Object* __p = new ConnectionMetrics(*this);
    return __p;
}

namespace
{
const ::std::string __IceMX__ConnectionMetrics_ids[3] =
{
    "::Ice::Object",
    "::IceMX::ConnectionMetrics",
    "::IceMX::Metrics"
};

}

bool
IceMX::ConnectionMetrics::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__IceMX__ConnectionMetrics_ids, __IceMX__ConnectionMetrics_ids + 3, _s);
}

::std::vector< ::std::string>
IceMX::ConnectionMetrics::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__IceMX__ConnectionMetrics_ids[0], &__IceMX__ConnectionMetrics_ids[3]);
}

const ::std::string&
IceMX::ConnectionMetrics::ice_id(const ::Ice::Current&) const
{
    return __IceMX__ConnectionMetrics_ids[1];
}

const ::std::string&
IceMX::ConnectionMetrics::ice_staticId()
{
    return __IceMX__ConnectionMetrics_ids[1];
}

void
IceMX::ConnectionMetrics::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, false);
    __os->write(receivedBytes);
    __os->write(sentBytes);
    __os->endWriteSlice();
    ::IceMX::Metrics::__writeImpl(__os);
}

void
IceMX::ConnectionMetrics::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(receivedBytes);
    __is->read(sentBytes);
    __is->endReadSlice();
    ::IceMX::Metrics::__readImpl(__is);
}

namespace
{

class __F__IceMX__ConnectionMetrics : public ::Ice::ObjectFactory
{
public:
#ifndef NDEBUG
virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
#else
virtual ::Ice::ObjectPtr
    create(const ::std::string&)
#endif
    {
        assert(type == ::IceMX::ConnectionMetrics::ice_staticId());
        return new ::IceMX::ConnectionMetrics;
    }

    virtual void
    destroy()
    {
    }
};
const ::Ice::ObjectFactoryPtr __F__IceMX__ConnectionMetrics_Ptr = new __F__IceMX__ConnectionMetrics;

class __F__IceMX__ConnectionMetrics__Init
{
public:

    __F__IceMX__ConnectionMetrics__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::IceMX::ConnectionMetrics::ice_staticId(), __F__IceMX__ConnectionMetrics_Ptr);
    }

    ~__F__IceMX__ConnectionMetrics__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::IceMX::ConnectionMetrics::ice_staticId());
    }
};

const __F__IceMX__ConnectionMetrics__Init __F__IceMX__ConnectionMetrics__i;

}

const ::Ice::ObjectFactoryPtr&
IceMX::ConnectionMetrics::ice_factory()
{
    return __F__IceMX__ConnectionMetrics_Ptr;
}

void ICE_DECLSPEC_EXPORT 
IceMX::__patch(ConnectionMetricsPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::IceMX::ConnectionMetricsPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::IceMX::ConnectionMetrics::ice_staticId(), v);
    }
}
